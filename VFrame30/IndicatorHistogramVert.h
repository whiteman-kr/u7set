#pragma once
#include "Indicator.h"
#include "../AppSignalLib/AppSignalParam.h"
#include "../lib/Tuning/TuningSignalState.h"

class Comparator;

namespace VFrame30
{
	//
	// Custom setpoint
	//
	class CustomSetPoint : public PropertyObject
	{
		Q_OBJECT

	public:
		CustomSetPoint() = default;
		CustomSetPoint(const CustomSetPoint&) noexcept = default;
		virtual ~CustomSetPoint() = default;

		CustomSetPoint& operator=(const CustomSetPoint&) noexcept = default;

	public:
		virtual void propertyDemand(const QString&) override;

		bool save(Proto::VFrameSetPoint* message) const;
		bool load(const Proto::VFrameSetPoint& message);

	public slots:
		E::IndicatorColorSource colorSource() const;
		void setColorSource(E::IndicatorColorSource value);

		QColor color() const;
		void setColor(const QColor& value);

		const QString& outputAppSignalId() const;
		void setOutputAppSignalId(const QString& value);

	private:
		E::IndicatorColorSource m_colorSource = E::IndicatorColorSource::ClientBehaviorByOutputSignalTag;
		QColor m_color{Qt::darkBlue};			// used only if m_colorSource == StaticColorFromStruct
		QString m_outputAppSignalId;
	};


	//
	// SetpointSource enum
	//
	enum class SetpointSource
	{
		AutoGenerated,
		Custom
	};

	//
	// IndicatorSetpoint
	//
	struct IndicatorSetpoint
	{
		std::shared_ptr<Comparator> comparator;
		SetpointSource source = SetpointSource::AutoGenerated;
		std::shared_ptr<CustomSetPoint> customSetpointData;			// valid only if source == SetpointSource::CustomSetpoints

		std::optional<double> value;
		std::optional<bool> alerted;
		QRgb setpointColor;

		// --
		//
		IndicatorSetpoint(const std::shared_ptr<Comparator>& comparator_,
						  SetpointSource setpointSource_,
						  const std::shared_ptr<CustomSetPoint> customSetpointData_,
						  std::optional<double> value_,
						  std::optional<bool> alerted_,
						  QRgb setpointColor_) :
			comparator(comparator_),
			source(setpointSource_),
			customSetpointData(customSetpointData_),
			value(value_),
			alerted(alerted_),
			setpointColor(setpointColor_)
		{
		}
	};


	//
	// Vertical histogram, the base view
	//
	class IndicatorHistogramVert : public Indicator
	{
		Q_OBJECT
	public:
		IndicatorHistogramVert() = delete;
		explicit IndicatorHistogramVert(SchemaUnit itemUnit);
		virtual ~IndicatorHistogramVert() = default;

	public:
		E::IndicatorScaleType scaleType() const;
		void setScaleType(E::IndicatorScaleType value);

	public:
		virtual void createProperties(SchemaItemIndicator* propertyObject, int signalCount) override;

		virtual bool save(Proto::SchemaItemIndicator* message) const override;
		virtual bool load(const Proto::SchemaItemIndicator& message, SchemaUnit unit) override;

		virtual void draw(CDrawParam* drawParam, const Schema* schema, const SchemaLayer* layer, const SchemaItemIndicator* schemaItem) const override;

	private:
		void drawBar(CDrawParam* drawParam,
					 const AppSignalParam& signalParam,
					 const AppSignalState& appSignalState,
					 const TuningSignalState& tuningSignalState,
					 const QRectF& barRect,
					 int signalIndex,
					 const QBrush& barBrush,
					 const SchemaItemIndicator* schemaItem) const;

		struct DrawGridStruct
		{
			double gridVertPos;
			double gridWidth;
			QString text;
		};
		void drawGrids(const std::vector<DrawGridStruct> grids, CDrawParam* drawParam, const QRectF barRect, const SchemaItemIndicator* item) const;

		// Setpoints drawing
		//
		std::vector<IndicatorSetpoint> comparators(CDrawParam* drawParam,
												   const QString& appSignalId,
												   const SchemaItemIndicator* schemaItem) const;

		std::optional<QBrush> getAlertBrush(const std::vector<IndicatorSetpoint>& setpoints,
											CDrawParam* drawParam,
											const AppSignalState& appSignalState,
											const TuningSignalState& tuningSignalState,
											const SchemaItemIndicator* schemaItem) const;

		struct DrawSetpointStruct
		{
			DrawSetpointStruct(int signalIndex_,
							   const QRectF& barRect_,
							   const IndicatorSetpoint& indicatorSetpoint_) :
				signalIndex(signalIndex_),
				barRect(barRect_),
				indicatorSetpoint(indicatorSetpoint_)
			{
			}

			int signalIndex = 0;
			QRectF barRect{};
			IndicatorSetpoint indicatorSetpoint;
		};

		void drawSetpoints(CDrawParam* drawParam,
						   const std::map<QString, std::vector<IndicatorSetpoint>>& setpoints,
						   const std::vector<QRectF>& barRects,
						   const SchemaItemIndicator* schemaItem) const;

		void drawSetpointItems(CDrawParam* drawParam, const std::vector<DrawSetpointStruct>& setpoints, const SchemaItemIndicator* schemaItem) const;

	private:
		// Scale-specific functions
		//
		double indicatorLog10(double value) const;
		double indicatorPow10(double value) const;

		double pointToScaleValue(double value) const;
		double pointFromScaleValue(double scaleValue) const;

	private:
		double m_startValue = 0;				// Start/End Values for top and bottom of the indicator,
		double m_endValue = 100.0;				// this field is common for all signals and all columns
		// so it's not possible to set different scales for several signals

		double m_barWidth = 0;					// Column width, In inches or pixels, getter and setter converts it to regional units
		bool m_drawBarRect = true;

		double m_leftMargin = mm2in(5);			// In inches or pixels, getter and setter converts it to regional units
		double m_topMargin = mm2in(5);			// In inches or pixels, getter and setter converts it to regional units
		double m_rightMargin = mm2in(5);		// In inches or pixels, getter and setter converts it to regional units
		double m_bottomMargin = mm2in(5);		// In inches or pixels, getter and setter converts it to regional units

		bool m_drawGrid = true;					// Draw grids
		bool m_drawGridForAllBars = false;		// Draw grids for all bars
		bool m_drawGridValues = true;			// Draw values for grid (only if m_drawGrid == true, for next bars depends on DrawGridOnlyForFirstBar)
		bool m_drawGridValueForAllBars = false;	// Draw values for grid for all bars (true) or just for the first one (false) (only if drawGrid == true && drawGridValues == true)
		bool m_drawGridValueUnits = true;		// Draw units for limits values (only if DrawGrid == true && DrawGridValues == true)

		double m_linearGridMainStep = 50.0;			// Step for main grids (only if DrawGrid == true)
		double m_linearGridSmallStep = 10.0;		// Step for small grids (only if DrawGrid == true)

		double m_logarithmicGridMainStep = 1;		// Step for main grids (only if DrawGrid == true)
		double m_logarithmicGridSmallStep = 0.5;	// Step for small grids (only if DrawGrid == true)

		E::IndicatorDrawSetpoints m_drawSetpoints = E::IndicatorDrawSetpoints::AutoGenerated;	// Draw all auto generated setpoints
		PropertyVector<CustomSetPoint> m_customSetPoints;	// Custom setpoint list

		E::IndicatorScaleType m_scaleType = E::IndicatorScaleType::Linear;
	};

}

Q_DECLARE_METATYPE(VFrame30::CustomSetPoint)
Q_DECLARE_METATYPE(PropertyVector<VFrame30::CustomSetPoint>)
