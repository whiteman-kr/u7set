#pragma once

#include <QtCore>
#include <QUdpSocket>
#include "../lib/SocketIO.h"
#include "../lib/SimpleThread.h"
#include "../lib/DataProtocols.h"
#include "../lib/Queue.h"


namespace Tuning
{
	enum OperationCode
	{
		Read = 1200,
		Write = 1400,
	};

	enum DataType
	{
		AnalogSignedInt = 1300,
		AnalogFloat = 1500,
		Discrete = 1700
	};


	struct SocketReply
	{
		quint32 lmIP;

		FotipHeader fotipHeader;

		char fotipData[FOTIP_TX_RX_DATA_SIZE];
		char fotipComparisonResult[FOTIP_COMPARISON_RESULT_SIZE];

		int frameNo;
	};


	struct RequestHeader
	{
		quint16 version;				// current version 1
		quint64 tuningID;				// unique connection ID generated by RPCT
		quint16 subsystemKey;			// key of Subsystem assigned in RPCT Subsystems List Editor
		quint16 operationCode;			// OperationCode enum values
		quint16 flags;
		quint32 startAddressW;			//
		quint16 requestSizeB;			// UDP frame size = 1432 bytes
		quint32 romSizeB;				// = ROM_SIZE_B
		quint16 romFrameSizeB;			// = ROM_FRAME_SIZE_B
		quint16 dataType;				// DataType enum values
	};


	struct SocketRequest
	{
		quint32 lmIP;
		int lmPort;
		int lmNumber;
		int lmSubsystemID;
		quint64 uniqueID;
		quint16 numerator;
		OperationCode operation;
		int startAddressW;
		int frameSizeW;
		DataType dataType;
		int romSizeW;
		bool userRequest;			// true - user request, false - atomatic periodic request

		char fotipData[FOTIP_TX_RX_DATA_SIZE];
	};


	struct TuningSocketRequest
	{
		quint32 lmIP;
		int lmPort;
		int lmNumber;
		int lmSubsystemID;
		quint64 uniqueID;
		quint16 numerator;
		OperationCode operation;
		int startAddressW;
		int frameSizeW;
		DataType dataType;
		int romSizeW;
		bool userRequest;			// true - user request, false - atomatic periodic request
	};


	class TuningSocketRequestQueue : public Queue<TuningSocketRequest>
	{
		Q_OBJECT

	public:
		TuningSocketRequestQueue(quint32 tuningSourceIP);

		virtual bool push(const TuningSocketRequest* ptr) override;

		bool isWaitingForAck() const;
		void stopWaiting();

		void requestIsSent();

		void incWaitCount();
		int waitCount() const;

	signals:
		void request(quint32 tuningSourceIP);

	private:
		quint32 m_tuningSourceIP;
		bool m_waitingForAk = false;
		int m_waitCount = 0;
	};


	class TuningSources;
	class TuningSourceWorker;

	class TuningSocketListener : public SimpleThreadWorker
	{
		Q_OBJECT

	public:
		TuningSocketListener(const HostAddressPort& listenIP, const TuningSources& tuningSources);
		~TuningSocketListener();

	signals:

	private:
		virtual void onThreadStarted() override;
		virtual void onThreadFinished() override;

		void createSocket();
		void closeSocket();

		void startTimer();

	private slots:
		void onTimer();

		void onSocketReadyRead();

		void pushReplyToTuningSourceWorker(const QHostAddress& tuningSourceIP, const RupFotipFrame& reply);

	private:
		HostAddressPort m_listenIP;

		QTimer m_timer;

		QUdpSocket* m_socket = nullptr;

		QHash<quint32, TuningSourceWorker*> m_ipTuningSourceWorkerMap;

		// statistics
		//
		qint64 m_errReplySize = 0;
		qint64 m_errReadSocket = 0;
		qint64 m_errUnknownTuningSource = 0;
	};
}
