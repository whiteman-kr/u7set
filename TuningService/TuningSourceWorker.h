#pragma once

#include <QUdpSocket>

#include "../lib/SimpleThread.h"
#include "../lib/ServiceSettings.h"

#include "TuningSource.h"

namespace Tuning
{
	/*enum class OperationCode
	{
		Read = 1200,
		Write = 1400,
	};

	enum class DataType
	{
		AnalogSignedInt = 1300,
		AnalogFloat = 1500,
		Discrete = 1700
	};


	struct SocketReply
	{
		quint32 lmIP;

		FotipHeader fotipHeader;

		char fotipData[FOTIP_TX_RX_DATA_SIZE];
		char fotipComparisonResult[FOTIP_COMPARISON_RESULT_SIZE];

		int frameNo;
	};


	struct RequestHeader
	{
		quint16 version;				// current version 1
		quint64 tuningID;				// unique connection ID generated by RPCT
		quint16 subsystemKey;			// key of Subsystem assigned in RPCT Subsystems List Editor
		quint16 operationCode;			// OperationCode enum values
		quint16 flags;
		quint32 startAddressW;			//
		quint16 requestSizeB;			// UDP frame size = 1432 bytes
		quint32 romSizeB;				// = ROM_SIZE_B
		quint16 romFrameSizeB;			// = ROM_FRAME_SIZE_B
		quint16 dataType;				// DataType enum values
	};


	struct SocketRequest
	{
		quint32 lmIP;
		int lmPort;
		int lmNumber;
		int lmSubsystemID;
		quint64 uniqueID;
		quint16 numerator;
		OperationCode operation;
		int startAddressW;
		int frameSizeW;
		DataType dataType;
		int romSizeW;
		bool userRequest;			// true - user request, false - atomatic periodic request

		char fotipData[FOTIP_TX_RX_DATA_SIZE];
	};


	struct TuningSocketRequest
	{
		quint32 lmIP;
		int lmPort;
		int lmNumber;
		int lmSubsystemID;
		quint64 uniqueID;
		quint16 numerator;
		OperationCode operation;
		int startAddressW;
		int frameSizeW;
		DataType dataType;
		int romSizeW;
		bool userRequest;			// true - user request, false - atomatic periodic request
	};
*/

	/*class TuningSocketRequestQueue : public Queue<TuningSocketRequest>
	{
		Q_OBJECT

	public:
		TuningSocketRequestQueue(quint32 tuningSourceIP);

		virtual bool push(const TuningSocketRequest* ptr) override;

		bool isWaitingForAck() const;
		void stopWaiting();

		void requestIsSent();

		void incWaitCount();
		int waitCount() const;

	signals:
		void request(quint32 tuningSourceIP);

	private:
		quint32 m_tuningSourceIP;
		bool m_waitingForAk = false;
		int m_waitCount = 0;
	}*/


	class TuningSources;
	class TuningSourceWorker;


	// ----------------------------------------------------------------------------------
	//
	// TuningSourceWorker class declaration
	//
	// ----------------------------------------------------------------------------------

	class TuningSourceWorker : public SimpleThreadWorker
	{
		Q_OBJECT

		struct Read
		{
			quint32 frame;
		};

		struct Write
		{
			quint32 frame;
		};

		struct Apply
		{
			quint32 frame;
		};

		struct TuningCommand
		{
			FotipV2::OpCode opCode = FotipV2::OpCode::Read;

			Read read;
			Write write;
			Apply apply;
		};

	public:
		TuningSourceWorker(const TuningServiceSettings& settings,
						   const TuningSource& source);

		quint32 sourceIP() const;

		void pushReply(const Rup::Frame& reply);
		void incErrReplySize();

	signals:
		void replyReady();

	private:
		virtual void onThreadStarted() override;
		virtual void onThreadFinished() override;

		bool processWaitReply();
		bool processCommandQueue();
		bool processIdle();

		void sendFOTIPRequest(const TuningCommand& tuningCmd);

		void initRupHeader(Rup::Header& rupHeader);
		void initFotipHeader(FotipV2::Header& fotipHeader, const TuningCommand& tuningCmd);
		void initFotipData(FotipV2::Frame& fotip, const TuningCommand& tuningCmd);

		void processReply(RupFotipV2 &reply);

		bool checkRupHeader(const Rup::Header& rupHeader);
		bool checkFotipHeader(const FotipV2::Header& fotipHeader);

	private slots:
		void onTimer();
		void onReplyReady();

	private:

		// data from tuning source
		//
		HostAddressPort m_sourceIP;

		quint64 m_sourceUniqueID = 0;
		quint16 m_lmNumber = 0;
		quint16 m_subsystemCode = 0;

		int m_tuningRomStartAddr = 0;
		int m_tuningRomFrameCount = 0;
		int m_tuningRomFrameSizeW = 0;
		int m_tuningRomSizeW = 0;

		//

		bool m_waitReply = false;

		const int MAX_WAIT_REPLY_COUNTER = 3;

		int m_waitReplyCounter = 0;

		int m_nextFrameToAutoRead = 0;

		QTimer m_timer;

		QUdpSocket m_socket;

		RupFotipV2 m_request;
		RupFotipV2 m_reply;

		Queue<Rup::Frame> m_replyQueue;

		Queue<TuningCommand> m_tuningCommandQueue;

		quint16 m_rupNumerator = 0;

		// statisticts
		//
		qint64 m_requestCount = 0;
		qint64 m_replyCount = 0;

		qint64 m_errUntimelyReplay = 0;
		qint64 m_errSent = 0;
		qint64 m_errPartialSent = 0;
		qint64 m_errReplySize = 0;
		qint64 m_errNoReply = 0;

		// errors in reply RupFrameHeader
		//
		qint64 m_errRupProtocolVersion = 0;
		qint64 m_errRupFrameSize = 0;
		qint64 m_errRupNoTuningData = 0;
		qint64 m_errRupModuleType = 0;
		qint64 m_errRupFramesQuantity = 0;
		qint64 m_errRupFrameNumber = 0;

		// errors in reply FotipHeader
		//
		qint64 m_errFotipProtocolVersion = 0;
		qint64 m_errFotipUniqueID = 0;
		qint64 m_errFotipLmNumber = 0;
		qint64 m_errFotipSubsystemCode = 0;
		qint64 m_errFotipOperationCode = 0;
		qint64 m_errFotipFrameSize = 0;
		qint64 m_errFotipRomSize = 0;
		qint64 m_errFotipRomFrameSize = 0;

		// errors reported by LM in reply FotipHeader.flags
		//
		qint64 m_fotipFlagBoundsCheckSuccess = 0;
		qint64 m_fotipFlagWriteSuccess = 0;
		qint64 m_fotipFlagDataTypeErr = 0;
		qint64 m_fotipFlagOpCodeErr = 0;
		qint64 m_fotipFlagStartAddrErr = 0;
		qint64 m_fotipFlagRomSizeErr = 0;
		qint64 m_fotipFlagRomFrameSizeErr = 0;
		qint64 m_fotipFlagFrameSizeErr = 0;
		qint64 m_fotipFlagProtocolVersionErr = 0;
		qint64 m_fotipFlagSubsystemKeyErr = 0;
		qint64 m_fotipFlagUniueIDErr = 0;
		qint64 m_fotipFlagOffsetErr = 0;
		qint64 m_fotipFlagApplySuccess = 0;
		qint64 m_fotipFlagSetSOR = 0;
	};


	// ----------------------------------------------------------------------------------
	//
	// TuningSourceWorkerThread class declaration
	//
	// ----------------------------------------------------------------------------------

	class TuningSourceWorkerThread : public SimpleThread
	{
	public:
		TuningSourceWorkerThread(const TuningServiceSettings& settings, const TuningSource& source);
		~TuningSourceWorkerThread();

		quint32 sourceIP();

		void pushReply(const Rup::Frame& reply);
		void incErrReplySize();

	private:
		TuningSourceWorker* m_sourceWorker = nullptr;
	};


	typedef QHash<quint32, TuningSourceWorkerThread*> TuningSourceWorkerThreadMap;


	// ----------------------------------------------------------------------------------
	//
	// TuningSocketListener class declaration
	//
	// ----------------------------------------------------------------------------------

	class TuningSocketListener : public SimpleThreadWorker
	{
		Q_OBJECT

	public:
		TuningSocketListener(const HostAddressPort& listenIP, TuningSourceWorkerThreadMap& sourceWorkerMap);
		~TuningSocketListener();

	signals:

	private:
		virtual void onThreadStarted() override;
		virtual void onThreadFinished() override;

		void createSocket();
		void closeSocket();

		void startTimer();

	private slots:
		void onTimer();

		void onSocketReadyRead();

		void pushReplyToTuningSourceWorker(const QHostAddress& tuningSourceIP, const Rup::Frame& reply);
		void incSourceWorkerErrReplySize(const QHostAddress& tuningSourceIP);

	private:
		HostAddressPort m_listenIP;
		TuningSourceWorkerThreadMap& m_sourceWorkerMap;

		QTimer m_timer;

		QUdpSocket* m_socket = nullptr;

		// statistics
		//
		qint64 m_errReplySize = 0;
		qint64 m_errReadSocket = 0;
		qint64 m_errUnknownTuningSource = 0;
	};


	// ----------------------------------------------------------------------------------
	//
	// TuningSocketListenerThread class declaration
	//
	// ----------------------------------------------------------------------------------

	class TuningSocketListenerThread : public SimpleThread
	{
	public:
		TuningSocketListenerThread(const HostAddressPort& listenIP, TuningSourceWorkerThreadMap& sourceWorkerMap);
		~TuningSocketListenerThread();

	private:
		TuningSocketListener* m_socketListener = nullptr;
	};
}
