#pragma once

#include <QtCore>
#include <QUdpSocket>
#include "../lib/SocketIO.h"
#include "../lib/SimpleThread.h"
#include "../lib/Queue.h"
#include "../lib/DataProtocols.h"

namespace TuningIPEN
{

	union FotipHeaderFlags
	{
		struct
		{
			quint16 successfulCheck : 1;
			quint16 successfulWrite : 1;
			quint16 dataTypeError : 1;
			quint16 operationCodeError : 1;
			quint16 startAddressError : 1;
			quint16 romSizeError : 1;
			quint16 romFrameSizeError : 1;
			quint16 frameSizeError : 1;
			quint16 versionError : 1;
			quint16 subsystemKeyError : 1;
			quint16 idError : 1;
		};

		quint16 all;
	};


	union FotipSubsystemKey
	{
		struct
		{
			quint16 lmNumber : 6;
			quint16 subsystemCode : 6;

			quint16 crc : 4;	// CRC of previous twelve bits. CRC-4-ITU = x^4 + x + 1
		};

		quint16 wordVaue;
	};


	const int FOTIP_OPERATION_READ = 1200,
			  FOTIP_OPERATION_WRITE = 1400;

	const int FOTIP_DATA_TYPE_SIGNED_INTEGER = 1300,
			  FOTIP_DATA_TYPE_FLOAT = 1500,
			  FOTIP_DATA_TYPE_IMMITATION_INTERLOCK = 1700;


	const int FOTIP_HEADER_RESERVE_SIZE = 98;


	enum class FotipOpCode
	{
		Read = 1200,
		Write = 1400,
		Apply = 1600
	};


	enum class FotipDataType
	{
		AnalogSignedInt = 1300,
		AnalogFloat = 1500,
		Discrete = 1700
	};


	struct FotipHeader
	{
		quint16 protocolVersion;
		quint64 uniqueId;

		FotipSubsystemKey subsystemKey;

		quint16 operationCode;						// enum FotipOpCode values

		FotipHeaderFlags flags;

		quint32 startAddress;
		quint16 fotipFrameSize;
		quint32 romSize;
		quint16 romFrameSize;
		quint16 dataType;							// enum FotipDataType values

		quint8 reserve[FOTIP_HEADER_RESERVE_SIZE];

		void reverseBytes();
	};


	const int FOTIP_TX_RX_DATA_SIZE = 1016;
	const int FOTIP_COMPARISON_RESULT_SIZE = 64;
	const int FOTIP_DATA_RESERV_SIZE = 224;

	struct FotipFrame
	{
		FotipHeader header;

		char data[FOTIP_TX_RX_DATA_SIZE];

		char comparisonResult[FOTIP_COMPARISON_RESULT_SIZE];

		char reserv[FOTIP_DATA_RESERV_SIZE];
	};


	struct RupFotipFrame
	{
		Rup::Header rupHeader;

		FotipFrame fotip;

		quint64 CRC64;			// = 1 + x + x^3 + x^4 + x^64
	};


	struct SocketReply
	{
		quint32 lmIP;

		FotipHeader fotipHeader;

		char fotipData[FOTIP_TX_RX_DATA_SIZE];
		char fotipComparisonResult[FOTIP_COMPARISON_RESULT_SIZE];

		int frameNo;
	};


	struct RequestHeader
	{
		quint16 version;				// current version 1
		quint64 tuningID;				// unique connection ID generated by RPCT
		quint16 subsystemKey;			// key of Subsystem assigned in RPCT Subsystems List Editor
		quint16 operationCode;			// OperationCode enum values
		quint16 flags;
		quint32 startAddressW;			//
		quint16 requestSizeB;			// UDP frame size = 1432 bytes
		quint32 romSizeB;				// = ROM_SIZE_B
		quint16 romFrameSizeB;			// = ROM_FRAME_SIZE_B
		quint16 dataType;				// DataType enum values
	};


	struct SocketRequest
	{
		quint32 lmIP;
		int lmPort;
		int lmNumber;
		int lmSubsystemID;
		quint64 uniqueID;
		quint16 numerator;
		FotipOpCode operation;
		int startAddressW;
		int frameSizeW;
		FotipDataType dataType;
		int romSizeW;
		bool userRequest;			// true - user request, false - atomatic periodic request

		char fotipData[FOTIP_TX_RX_DATA_SIZE];
	};


	struct TuningSocketRequest
	{
		quint32 lmIP;
		int lmPort;
		int lmNumber;
		int lmSubsystemID;
		quint64 uniqueID;
		quint16 numerator;
		FotipOpCode operation;
		int startAddressW;
		int frameSizeW;
		FotipDataType dataType;
		int romSizeW;
		bool userRequest;			// true - user request, false - atomatic periodic request
	};


	class TuningIPENService;

	class TuningIPENSocketWorker : public SimpleThreadWorker
	{
		Q_OBJECT
	public:

	private:
		HostAddressPort m_tuningIP;
		TuningIPENService* m_tuningService = nullptr;

		QTimer m_timer;

		QUdpSocket* m_socket = nullptr;
		bool m_socketBound = false;

		RupFotipFrame m_ackFrame;
		RupFotipFrame m_reqFrame;

		virtual void onThreadStarted() override;
		virtual void onThreadFinished() override;

		virtual void onTimer();

		void createAndBindSocket();
		void closeSocket();
		void onSocketReadyRead();

		void clear();

		Queue<SocketRequest> m_requests;
		Queue<SocketReply> m_replies;

	private slots:
		void onSocketRequest();

	signals:
		void replyReady();

		void userRequest(FotipFrame fotipFrame);
		void replyWithNoZeroFlags(FotipFrame fotipFrame);

	public:
		TuningIPENSocketWorker(const HostAddressPort& tuningIP, TuningIPENService* tuningService);

		void sendRequest(const SocketRequest& socketRequest);

		bool getReply(SocketReply* reply);
	};

}
