package Network;

import "serialization.proto";

// Get signal list
// 1. Request GetSignalListStartRequest, wait for reply GetSignalListStartReply
// 2. Request GetSignalListStartReply.partCount times GetSignalListNextRequest (and get GetSignalListNextReply in reply)
//
message GetSignalListStartRequest
{
}

message GetSignalListStartReply
{
	optional int32 error = 1 [default = 0];
	optional int32 totalItemCount = 2;
	optional int32 partCount = 3;
	optional int32 itemsPerPart = 4;
}

message GetSignalListNextRequest
{
	optional int32 part = 1;
}

message GetSignalListNextReply
{
	optional int32 error = 1 [default = 0];
	optional int32 part = 2;
	repeated string appSignalIds = 3;
}

// Geetting class AppSignalParam
//
message GetAppSignalParamRequest
{
	repeated uint64 signalHashes = 1;						// Limited to ADS_GET_APP_SIGNAL_PARAM_MAX (500)
}

message GetAppSignalParamReply
{
	optional int32 error = 1 [default = 0];
	repeated Proto.AppSignal appSignals = 2;				// Limited to ADS_GET_APP_SIGNAL_PARAM_MAX (500)
}

// Get class Signal
//
message GetAppSignalRequest
{
    repeated uint64 signalHashes = 1;						// Limited to ADS_GET_APP_SIGNAL_PARAM_MAX (500)
}

message GetAppSignalReply
{
    optional int32 error = 1 [default = 0];
	repeated Proto.AppSignal appSignals = 2;					// Limited to ADS_GET_APP_SIGNAL_PARAM_MAX (500)
}

// Geetting application signal states
//
message GetAppSignalStateRequest
{
	repeated uint64 signalHashes = 1;						// Limited to ADS_GET_APP_SIGNAL_STATE_MAX (2000)
}

message GetAppSignalStateReply
{
	optional int32 error = 1 [default = 0];

	optional int64 serverTimeUtc = 2;
	optional int64 serverTimeLocal = 3;

	repeated Proto.AppSignalState appSignalStates = 4;		// Limited to ADS_GET_APP_SIGNAL_STATE_MAX (2000)
}

// Geetting application signal states changes
//
message GetAppSignalStateChangesRequest
{
}

message GetAppSignalStateChangesReply
{
	optional int32 error = 1 [default = 0];

	optional int64 serverTimeUtc = 2;
	optional int64 serverTimeLocal = 3;

	optional int32 pendingStatesCount = 4 [default = 0];

	repeated Proto.AppSignalState appSignalStates = 5;		// Limited to ADS_GET_APP_SIGNAL_STATE_MAX (2000)
}


// Getting Data Sources info
//

message DataSourceInfo
{
    optional uint64 id = 1 [default = 0];		    // unique id

    optional string lmEquipmentID = 2;
    optional string lmCaption = 3;
    optional int32 lmDataType = 4 [default = 0];
    optional string lmIP = 5;
    optional int32 lmPort = 6 [default = 0];
    optional int32 lmSubsystemID = 7 [default = 0];
    optional string lmSubsystem = 8;
    optional string lmSubsystemChannel = 9;
    optional int32 lmNumber = 10 [default = 0];
    optional int32 lmModuleType = 11 [default = 0];
    optional string lmAdapterID = 12;
    optional bool lmDataEnable = 13 [default = false];
	optional uint32 lmDataID = 14 [default = 0];
    optional uint64 lmUniqueID = 15 [default = 0];
    optional int32 lmRupFramesQuantity = 16 [default = 0];
	optional string lmPresetName = 17;
}

message GetDataSourcesInfoRequest
{
}


message GetDataSourcesInfoReply
{
    optional int32 error = 1 [default = 0];
    repeated DataSourceInfo dataSourceInfo = 2;
}


message AppDataReceiveState
{
    optional int64 receivedFramesCount = 1 [default = 0];
    optional int64 framesReceivedPerSecond = 2 [default = 0];
    optional int64 simFramesCount = 3 [default = 0];
    optional int64 errDatagramSize = 4 [default = 0];
    optional int64 errSimVersion = 5 [default = 0];
    optional int64 errUnknownAppDataSourceIP = 6 [default = 0];
	optional int64 errRupFrameCRC = 7 [default = 0];
}

// Getting Application Data Sources states
//
message AppDataSourceState
{
    optional uint64 id = 1 [default = 0];			    // unique id
    optional bool dataReceives = 2 [default = false];
    optional int64 uptime = 3 [default = 0];			    // time from start of data receiving
    optional uint64 receivedDataID = 4 [default = 0];
	optional int32 rupFramesQueueCurSize = 5 [default = 0];
	optional int32 rupFramesQueueCurMaxSize = 6 [default = 0];
    optional double dataReceivingRate = 7 [default = 0];	    // bytes/sec
    optional int64 receivedDataSize = 8 [default = 0];	    //
    optional int64 receivedFramesCount = 9 [default = 0];
    optional int64 receivedPacketCount = 10 [default = 0];
	optional int64 lostPacketCount = 11 [default = 0];
    optional bool dataProcessingEnabled = 12 [default = false];
    optional int64 processedPacketCount = 13 [default = 0];
    optional int64 lastPacketSystemTime = 14 [default = 0];
    optional int64 rupFramePlantTime = 15 [default = 0];
	optional uint32 rupFrameNumerator = 16 [default = 0];
	optional int32 signalStatesQueueCurSize = 17 [default = 0];
	optional int32 signalStatesQueueCurMaxSize = 18 [default = 0];
    optional int32 acquiredSignalsCount = 19 [default = 0];
    optional int64 errorProtocolVersion = 20 [default = 0];
    optional int64 errorFramesQuantity = 21 [default = 0];
    optional int64 errorFrameNo = 22 [default = 0];
    optional int64 errorDataID = 23 [default = 0];
    optional int64 errorFrameSize = 24 [default = 0];
    optional int64 errorDuplicatePlantTime = 25 [default = 0];
    optional int64 errorNonmonotonicPlantTime = 26 [default = 0];
    optional string lmEquipmentID = 27;

	optional int32 rupFramesQueueSize = 28 [default = 0];
	optional int32 signalStatesQueueSize = 29 [default = 0];
}


message GetAppDataSourcesStatesReply
{
    optional int32 error = 1 [default = 0];
    repeated AppDataSourceState appDataSourcesStates = 2;
}


message AppDataServiceState
{
    required bool CfgServiceIsConnected = 1 [default = false];
    optional uint32 CfgServiceIp = 2 [default = 0];
    optional int32 CfgServicePort = 3 [default = 0];

    required bool ArchiveServiceIsConnected = 4 [default = false];
    optional uint32 ArchiveServiceIp = 5 [default = 0];
    optional int32 ArchiveServicePort = 6 [default = 0];

    optional AppDataReceiveState appDataReceiveState = 7;
}


message SoftwareInfo
{
    required int32 softwareType = 1 [default = 8000];		// E::SoftwareType::Unknown = 8000
    required string equipmentId = 2;
    required int32 majorVersion = 3 [default = 0];
    required int32 minorVersion = 4 [default = 0];
    required int32 commitNo = 5 [default = 0];
    required string buildBranch = 6;
    required string commitSHA = 7;
    required string userName = 8;
    required int32 buildNo = 9 [default = 0];
    required uint32 crc = 10 [default = 0];
	optional string clientDescription = 11;
}

// Get Service Info
//
message GetServiceInfoRequest
{
}

message ServiceInfo
{
    required SoftwareInfo softwareInfo = 1;

    optional int64 uptime = 2 [default = 0];
    optional int32 serviceState = 3 [default = 0];		// ServiceState::Undefined;
    optional int64 serviceUptime = 4 [default = 0];

    optional uint32 clientRequestIP = 5 [default = 0];
    optional int32 clientRequestPort = 6 [default = 0];
}

message GetServiceInfoReply
{
    required int32 error = 1 [default = 0];
    required ServiceInfo serviceInfo = 2;
}

message ConfigurationServiceState
{
    required string currentBuildDirectory = 1;
    required int32 checkBuildAttemptQuantity = 2;
    required int32 buildCheckerState = 3;
}

message ServiceClientInfo
{
    required int32 ip = 3;
    required int64 uptime = 5;
    required bool isActual = 6;
    required int64 replyQuantity = 7;
    required SoftwareInfo softwareInfo = 11;
}

message ServiceClients
{
    repeated ServiceClientInfo clients = 1;
}

message BuildInfo
{
    required string project = 1;
    required int32 id = 2 [default = -1];
    required bool release = 3 [default = false];
    required int64 date = 4;
    required int32 changeset = 5 [default = 0];
    required string user = 6;
    required string workstation = 7;
}

message ConfigurationServiceSettings
{
    required string equipmentID = 1;
    required string autoloadBuildPath = 2;
    required string workDirectory = 3;
}

message ServiceSettings
{
    required string equipmentID = 1;
    required string configIP1 = 2;
    required string configIP2 = 3;
}


// TuningService requests and replies
//

// Tuning sources info request - TDS_GET_TUNING_SOURCES_INFO
//
message GetTuningSourcesInfo
{
}

message GetTuningSourcesInfoReply
{
    optional int32 error = 1 [default = 0];
    repeated DataSourceInfo tuningSourceInfo= 2;

    optional bool singleLmControlMode = 3 [default = true];
    optional string activeClientID = 4;				    // if singleLmControlMode == true then EquipmentID of activeClient
                                                                    // else - empty string
    optional string activeClientIP = 5;				    // similar to activeClientID
}

// Tuning sources states request - TDS_GET_TUNING_SOURCES_STATES
//
message GetTuningSourcesStates
{
}

message SignalsAssociatedToTuningSource
{
    required uint64 sourceID = 1;
    repeated uint64 signalHash = 2;
}

message TuningSourceFilling
{
    required uint64 signalCount = 1;
    repeated SignalsAssociatedToTuningSource signalsPerSource = 2;
}

message TuningSourceState
{
    optional uint64 sourceID = 1 [default = 0];

    optional bool isReply = 2 [default = false];

    optional int64 requestCount = 3 [default = 0];
    optional int64 replyCount = 4 [default = 0];

    optional int32 commandQueueSize = 5 [default = 0];

    optional int64 errUntimelyReplay = 6 [default = 0];
    optional int64 errSent = 7 [default = 0];
    optional int64 errPartialSent = 8 [default = 0];
    optional int64 errReplySize = 9 [default = 0];
    optional int64 errNoReply = 10 [default = 0];

    // errors in reply RupFrameHeader
    //
    optional int64 errRupProtocolVersion = 11 [default = 0];
    optional int64 errRupFrameSize = 12 [default = 0];
    optional int64 errRupNonTuningData = 13 [default = 0];
    optional int64 errRupModuleType = 14 [default = 0];
    optional int64 errRupFramesQuantity = 15 [default = 0];
    optional int64 errRupFrameNumber = 16 [default = 0];

    // errors in reply FotipHeader
    //
    optional int64 errFotipProtocolVersion = 17 [default = 0];
    optional int64 errFotipUniqueID = 18 [default = 0];
    optional int64 errFotipLmNumber = 19 [default = 0];
    optional int64 errFotipSubsystemCode = 20 [default = 0];
    optional int64 errFotipOperationCode = 21 [default = 0];
    optional int64 errFotipFrameSize = 22 [default = 0];
    optional int64 errFotipRomSize = 23 [default = 0];
    optional int64 errFotipRomFrameSize = 24 [default = 0];

    // errors reported by LM in reply FotipHeader.flags
    //
    optional int64 fotipFlagBoundsCheckSuccess = 25 [default = 0];
    optional int64 fotipFlagWriteSuccess = 26 [default = 0];
    optional int64 fotipFlagDataTypeErr = 27 [default = 0];
    optional int64 fotipFlagOpCodeErr = 28 [default = 0];
    optional int64 fotipFlagStartAddrErr = 29 [default = 0];
    optional int64 fotipFlagRomSizeErr = 30 [default = 0];
    optional int64 fotipFlagRomFrameSizeErr = 31 [default = 0];
    optional int64 fotipFlagFrameSizeErr = 32 [default = 0];
    optional int64 fotipFlagProtocolVersionErr = 33 [default = 0];
    optional int64 fotipFlagSubsystemKeyErr = 34 [default = 0];
    optional int64 fotipFlagUniueIDErr = 35 [default = 0];
    optional int64 fotipFlagOffsetErr = 36 [default = 0];
    optional int64 fotipFlagApplySuccess = 37 [default = 0];
    optional int64 fotipFlagSetSOR = 38 [default = 0];

    optional int64 errAnalogLowBoundCheck = 39 [default = 0];
    optional int64 errAnalogHighBoundCheck = 40 [default = 0];

    optional int64 errRupCRC = 41 [default = 0];

    optional bool controlIsActive = 42 [default = false];
    optional bool setSOR = 43 [default = false];

    optional bool hasUnappliedParams = 44 [default = false];

	//

	optional bool writingDisabled = 45 [default = false];
	optional int64 fotipFlagWritingDisabled = 46 [default = 0];
}

message GetTuningSourcesStatesReply
{
    optional int32 error = 1 [default = 0];
    repeated TuningSourceState tuningSourcesState = 2;

    optional bool singleLmControlMode = 3 [default = true];
    optional string activeClientID = 4;				    // if singleLmControlMode == true then EquipmentID of activeClient
                                                                    // else - empty string
    optional string activeClientIP = 5;				    // similar to activeClientID
}

//  Change current controlled TuningSource request - TDS_CHANGE_CONTROLLED_TUNING_SOURCE
//
//  Allowed only if SingleLMControl mode of TuningService is set to TRUE.
//  Otherwise reply is returning error NetworkError::SingleLmControlDisabled.
//
message ChangeConrolledTuningSourceRequest
{
    optional bool takeControl = 1;				    // true - to force control to current client

    optional string tuningSourceEquipmentID = 2;		    // not empty - to change controlled source
                                                                    // empty - to request current controlled source (activateControl field is ignored)

    optional bool activateControl = 3 [default = false];	    // if tuningSourceEquipmentID is not empty:
                                                                    //	    true - to activate tuning source control
								    //	    false - to deactivate tuning source control
}

message ChangeConrolledTuningSourceReply
{
    optional int32 error = 1 [default = 0];
    optional string controlledTuningSourceEquipmentID = 2;	    // if error == Success - current controlled TuningSource
                                                                    // else - empty string
    optional bool controlIsActive = 3 [default = false];
}

// Tuning signals read request - TDS_TUNING_SIGNALS_READ
//
message TuningSignalsRead
{
    repeated uint64 signalHash = 2;
}

message TuningSignalState
{
    optional fixed64 signalHash = 1 [default = 0];
    optional int32 error = 2 [default = 0];

    optional bool valid = 3 [default = false];
    optional Proto.TuningValue value = 4;
    optional Proto.TuningValue readLowBound = 5;
    optional Proto.TuningValue readHighBound = 6;

    optional bool writeInProgress = 7 [default = false];
    optional int32 writeErrorCode = 8 [default = 0];			// NetworkError:  Success, TuningValueOutOfRange, TuningNoReply
	optional fixed64 writeClient = 9 [default = 0];				// Hash code of Client's EquipmentID

    optional sfixed64 successfulReadTime = 10 [default = 0];	// time of last succesfull signal reading (UTC)
    optional sfixed64 writeRequestTime = 11 [default = 0];		// time of last write request (UTC)
	optional sfixed64 successfulWriteTime = 12 [default = 0];	// time of last succesfull signal writing (UTC)
	optional sfixed64 unsuccessfulWriteTime = 13 [default = 0];	// time of last unsuccesfull signal writing (UTC)

	optional bool setSOR = 14 [default = false];
	optional bool writingDisabled = 15 [default = false];
}

message TuningSignalsReadReply
{
    optional int32 error = 1 [default = 0];
    repeated TuningSignalState tuningSignalState = 2;
}

// Write tuning signals request - TDS_TUNING_SIGNALS_WRITE
//
message TuningWriteCommand
{
    optional uint64 signalHash = 1 [default = 0];
    optional Proto.TuningValue value = 2;
}

message TuningSignalsWrite
{
    optional bool autoApply = 2 [default = false];
    repeated TuningWriteCommand commands = 3;
}

message TuningSignalWriteResult
{
    optional uint64 signalHash = 1 [default = 0];
    optional int32 error = 2 [default = 0];
}

message TuningSignalsWriteReply
{
    optional int32 error = 1 [default = 0];
    repeated TuningSignalWriteResult writeResult = 2;
}


// Request to applying tuning signals values - TDS_TUNING_SIGNALS_APPLY
//
message TuningSignalsApply
{
}

message TuningSignalsApplyReply
{
    optional int32 error = 1 [default = 0];
}

// ArchService requests and replies
//

message SaveAppSignalsStatesToArchiveRequest
{
    optional string clientEquipmentID = 1;
    repeated Proto.AppSignalState appSignalStates = 2;
}

message SaveAppSignalsStatesToArchiveReply
{
    optional int32 error = 1 [default = 0];

    optional int32 archError = 2 [default = 100];
}

//

message GetAppSignalStatesFromArchiveStartRequest
{
    optional string clientEquipmentID = 1;
	optional int32 timeType = 2 [default = 1];		// enum TimeType values:
	                                                // 0 - plant time
													// 1 - system time
													// 2 - local time
													// 3 - archive id
    optional sfixed64 startTime = 3 [default = 0];
    optional sfixed64 endTime = 4 [default = 0];

    repeated uint64 signalHashes = 5;				// max hashes count should be less or equal to 32 (ARCH_REQUEST_MAX_SIGNALS at SocketIO.h)

    optional bool removePeriodic = 6 [default = true];
}

message GetAppSignalStatesFromArchiveStartReply
{
    optional int32 error = 1 [default = 0];
    optional int32 archError = 2 [default = 100];
	optional string errorString = 4;
    optional uint32 requestID = 3 [default = 0];
}

//

message GetAppSignalStatesFromArchiveNextRequest
{
    optional uint32 requestID = 1 [default = 0];
}

message GetAppSignalStatesFromArchiveNextReply
{
    optional int32 error = 1 [default = 0];
    optional int32 archError = 2 [default = 100];
    optional uint32 requestID = 3 [default = 0];
	optional string errorString = 10;
    optional bool dataReady = 4 [default = false];
    optional int32 totalStatesCount = 5 [default = 0];		// The actual number of transmitted states can be less than totalStatesCount
    optional int32 sentStatesCount = 6 [default = 0];
    optional int32 statesInPartCount = 7 [default = 0];
    optional bool isLastPart = 8 [default = false];
    repeated Proto.AppSignalState appSignalStates = 9;
}

//

message GetAppSignalStatesFromArchiveCancelRequest
{
    optional uint32 requestID = 1 [default = 0];
}

message GetAppSignalStatesFromArchiveCancelReply
{
    optional int32 error = 1 [default = 0];
    optional int32 archError = 2 [default = 100];
	optional string errorString = 3;
}

// Real-time trends requests and replies
//

message RtTrendsManagementRequest
{
    optional string clientEquipmentID = 1;
    optional int32 samplePeriod = 2;			    // enum E::RtTrandSamplePeriod
    repeated uint64 appendSignalHashes = 3;
    repeated uint64 deleteSignalHashes = 4;
}

message RtTrendsManagementReply
{
    optional int32 error = 1 [default = 0];
    optional string errorString = 2;
	optional int32 samplePeriod = 3;			    // enum E::RtTrandSamplePeriod
	repeated uint64 trackedSignalHashes = 4;
}

//

message RtTrendsGetStateChangesRequest
{
}

message RtTrendsGetStateChangesReply
{
    optional int32 error = 1 [default = 0];
    optional string errorString = 2;

    repeated Proto.AppSignalState signalStates = 3;
}

//
/*
message RtTrendsGetArchiveStatesRequest
{
    optional int32 timeType = 1 [default = 1];		// enum TimeType values:
							// 0 - plant time
							// 1 - system time
							// 2 - local time
							// 3 - archive id
    optional sfixed64 startTime = 2 [default = 0];
    optional sfixed64 endTime = 3 [default = 0];
}

message RtTrendsGetArchiveStatesReply
{
    optional int32 error = 1 [default = 0];
    optional string errorString = 2;

    repeated Proto.AppSignalState signalStates = 3;
}*/



