package Network;

import "serialization.proto";

// Get signal list
// 1. Request GetSignalListStartRequest, wait for reply GetSignalListStartReply
// 2. Request GetSignalListStartReply.partCount times GetSignalListNextRequest (and get GetSignalListNextReply in reply)
//
message GetSignalListStartRequest
{
}

message GetSignalListStartReply
{
	optional int32 error = 1 [default = 0];
	optional int32 totalItemCount = 2;
	optional int32 partCount = 3;
	optional int32 itemsPerPart = 4;
}

message GetSignalListNextRequest
{
	optional int32 part = 1;
}

message GetSignalListNextReply
{
	optional int32 error = 1 [default = 0];
	optional int32 part = 2;
	repeated string appSignalIds = 3;
}

// Geetting application signal params
//
message GetAppSignalParamRequest
{
	repeated uint64 signalHashes = 1;						// Limited to ADS_GET_APP_SIGNAL_PARAM_MAX (500)
}

message GetAppSignalParamReply
{
	optional int32 error = 1 [default = 0];
	repeated Proto.AppSignal appSignalParams = 2;			// Limited to ADS_GET_APP_SIGNAL_PARAM_MAX (500)
}


// Geetting application signal states
//
message GetAppSignalStateRequest
{
	repeated uint64 signalHashes = 1;						// Limited to ADS_GET_APP_SIGNAL_STATE_MAX (2000)
}

message GetAppSignalStateReply
{
	optional int32 error = 1 [default = 0];
	repeated Proto.AppSignalState appSignalStates = 2;		// Limited to ADS_GET_APP_SIGNAL_STATE_MAX (2000)
}


// Getting Data Sources info
//

message DataSourceInfo
{
    optional uint64 id = 1;		    // unique id
    optional string equipmentID = 2;
    optional string caption = 3;
    optional int32 dataType = 4;
    optional string ip = 5;
    optional int32 port = 6;
    optional int32 channel = 7;
    optional int32 subsystemID = 8;
    optional string subsystem = 9;

    optional int32 lmNumber = 10;
    optional int32 lmModuleType = 11;
    optional string lmAdapterID = 12;
    optional bool lmDataEnable = 13;
    optional uint64 lmDataID = 14;
}


message GetDataSourcesInfoRequest
{
}


message GetDataSourcesInfoReply
{
    optional int32 error = 1 [default = 0];
    repeated DataSourceInfo dataSourceInfo = 2;
}


// Getting Application Data Sources states
//

message AppDataSourceState
{
    optional uint64 id = 1;			    // unique id
    optional int64 uptime = 2;			    // time from start of data receiving
    optional int64 receivedDataSize = 3;	    //
    optional double dataReceivingRate = 4;	    // bytes/sec
    optional int64 receivedFramesCount = 5;
    optional bool processingEnabled = 6;
    optional int64 processedPacketCount = 7;
    optional int64 errorProtocolVersion = 8;
    optional int64 errorFramesQuantity = 9;
    optional int64 errorFrameNo = 10;
    optional int64 lostedPackets = 11;
    optional int64 errorDataID = 12;
    optional uint64 receivedDataID = 13;
    optional bool processingSkiped = 14;
    optional int32 state = 15;			    // receive, noData, stopped
    optional int64 errorBadFrameSize = 16;
    optional bool hasErrors = 17;
}


message GetAppDataSourcesStatesReply
{
    optional int32 error = 1 [default = 0];
    repeated AppDataSourceState appDataSourcesStates = 2;
}


// Get Units
//
message GetUnitsRequest
{
}

message Unit
{
    optional int32 id = 1;
    optional string unit = 2;
}

message GetUnitsReply
{
    optional int32 error = 1 [default = 0];
    repeated Unit units = 2;
}

// Get Service Info
//

message GetServiceInfoRequest
{
}

message ServiceInfo
{
    optional int32 type = 1 [default = 0];	    // ServiceType::BaseService
    optional int32 majorVersion = 2 [default = 0];
    optional int32 minorVersion = 3 [default = 0];
    optional int32 buildNo = 4 [default = 0];
    optional uint32 crc = 5 [default = 0];
    optional int64 uptime = 6 [default = 0];
    optional int32 serviceState = 7 [default = 0];    // ServiceState::Undefined;
    optional int64 serviceUptime = 8 [default = 0];

    optional uint32 clientRequestIP = 9 [default = 0];
    optional int32 clientRequestPort = 10 [default = 0];
}

message GetServiceInfoReply
{
    required int32 error = 1 [default = 0];
    required ServiceInfo serviceInfo = 2;
}


// TuningService requests and replies
//

// Tuning sources info request

message GetTuningSourcesInfo
{
    optional string clientEquipmentID = 1;
}

message GetTuningSourcesInfoReply
{
    optional int32 error = 1 [default = 0];
    repeated DataSourceInfo tuningSourceInfo= 2;
}

// Tuning sources states request

message GetTuningSourcesStates
{
    optional string clientEquipmentID = 1;
}

message TuningSourceState
{
    optional uint64 sourceID = 1 [default = 0];

    optional bool isReply = 2 [default = false];

    optional int64 requestCount = 3 [default = 0];
    optional int64 replyCount = 4 [default = 0];

    optional int32 commandQueueSize = 5 [default = 0];

    optional int64 errUntimelyReplay = 6 [default = 0];
    optional int64 errSent = 7 [default = 0];
    optional int64 errPartialSent = 8 [default = 0];
    optional int64 errReplySize = 9 [default = 0];
    optional int64 errNoReply = 10 [default = 0];

    // errors in reply RupFrameHeader
    //
    optional int64 errRupProtocolVersion = 11 [default = 0];
    optional int64 errRupFrameSize = 12 [default = 0];
    optional int64 errRupNonTuningData = 13 [default = 0];
    optional int64 errRupModuleType = 14 [default = 0];
    optional int64 errRupFramesQuantity = 15 [default = 0];
    optional int64 errRupFrameNumber = 16 [default = 0];

    // errors in reply FotipHeader
    //
    optional int64 errFotipProtocolVersion = 17 [default = 0];
    optional int64 errFotipUniqueID = 18 [default = 0];
    optional int64 errFotipLmNumber = 19 [default = 0];
    optional int64 errFotipSubsystemCode = 20 [default = 0];
    optional int64 errFotipOperationCode = 21 [default = 0];
    optional int64 errFotipFrameSize = 22 [default = 0];
    optional int64 errFotipRomSize = 23 [default = 0];
    optional int64 errFotipRomFrameSize = 24 [default = 0];

    // errors reported by LM in reply FotipHeader.flags
    //
    optional int64 fotipFlagBoundsCheckSuccess = 25 [default = 0];
    optional int64 fotipFlagWriteSuccess = 26 [default = 0];
    optional int64 fotipFlagDataTypeErr = 27 [default = 0];
    optional int64 fotipFlagOpCodeErr = 28 [default = 0];
    optional int64 fotipFlagStartAddrErr = 29 [default = 0];
    optional int64 fotipFlagRomSizeErr = 30 [default = 0];
    optional int64 fotipFlagRomFrameSizeErr = 31 [default = 0];
    optional int64 fotipFlagFrameSizeErr = 32 [default = 0];
    optional int64 fotipFlagProtocolVersionErr = 33 [default = 0];
    optional int64 fotipFlagSubsystemKeyErr = 34 [default = 0];
    optional int64 fotipFlagUniueIDErr = 35 [default = 0];
    optional int64 fotipFlagOffsetErr = 36 [default = 0];
    optional int64 fotipFlagApplySuccess = 37 [default = 0];
    optional int64 fotipFlagSetSOR = 38 [default = 0];
}

message GetTuningSourcesStatesReply
{
    optional int32 error = 1 [default = 0];
    repeated TuningSourceState tuningSourcesState = 2;
}

// Tuning signals read request

message TuningSignalsRead
{
    optional string clientEquipmentID = 1;
    repeated uint64 signalHash = 2;
}

message TuningSignalState
{
    optional uint64 signalHash = 1 [default = 0];
    optional int32 error = 2 [default = 0];
    optional bool valid = 3 [default = false];
    optional double value = 4 [default = 0.0];
    optional double readLowBound = 5 [default = 0.0];
    optional double readHighBound = 6 [default = 0.0];
}

message TuningSignalsReadReply
{
    optional int32 error = 1 [default = 0];
    repeated TuningSignalState tuningSignalState = 2;
}

// Write tuning signals request

message TuningSignalWrite
{
    optional uint64 signalHash = 1 [default = 0];
    optional double value = 2 [default = 0.0];
}

message TuningSignalsWrite
{
    optional string clientEquipmentID = 1;
    optional bool autoAppay = 2 [default = false];
    repeated TuningSignalWrite tuningSignalWrite = 3;
}

message TuningSignalsWriteReply
{
    optional int32 error = 1 [default = 0];
}




