// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serialization.proto

#ifndef PROTOBUF_serialization_2eproto__INCLUDED
#define PROTOBUF_serialization_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_serialization_2eproto();
void protobuf_AssignDesc_serialization_2eproto();
void protobuf_ShutdownFile_serialization_2eproto();

class Uuid;
class qvariant;
class wstring;
class FontParam;
class SchemaPoint;
class Envelope;
class EnvelopeSet;
class EnvelopeSetShortDescription;
class Configuration;
class AfbElementCollection;
class AfbElementXml;
class FblElement;
class AfbSignal;
class AfbParam;
class Schema;
class LogicSchema;
class UfbSchema;
class SchemaLayer;
class SchemaItem;
class PosRectImpl;
class PosLineImpl;
class PosConnectionImpl;
class SchemaItemRect;
class SchemaItemLine;
class SchemaItemPath;
class FblConnectionPoint;
class FblItem;
class FblItemRect;
class FblItemLine;
class SchemaItemSignalColumn;
class SchemaItemSignal;
class SchemaItemInput;
class SchemaItemOutput;
class SchemaItemInOut;
class SchemaItemLink;
class SchemaItemAfb;
class SchemaItemConst;
class SchemaItemConnection;
class SchemaItemTransmitter;
class SchemaItemReceiver;
class SchemaItemUfb;
class SchemaItemTerminator;
class SchemaItemValue;
class SchemaItemBus;
class SchemaItemBusComposer;
class SchemaItemBusExtractor;
class SchemaItemControl;
class SchemaItemPushButton;
class SchemaItemLineEdit;
class DeviceObject;
class DeviceRoot;
class DeviceSystem;
class DeviceRack;
class DeviceChassis;
class DeviceModule;
class DeviceController;
class DeviceSignal;
class Workstation;
class Software;
class ModuleConfiguration;
class ModuleConfigurationValue;
class Property;
class Address16;
class AppSignal;
class AppSignalState;
class AppSignalParam;
class AppSignalParamSet;
class Connection;
class SchemaDetailsSet;
class SchemaDetails;

enum SchemaUnit {
  Display = 0,
  Millimeter = 1,
  Inch = 2
};
bool SchemaUnit_IsValid(int value);
const SchemaUnit SchemaUnit_MIN = Display;
const SchemaUnit SchemaUnit_MAX = Inch;
const int SchemaUnit_ARRAYSIZE = SchemaUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* SchemaUnit_descriptor();
inline const ::std::string& SchemaUnit_Name(SchemaUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    SchemaUnit_descriptor(), value);
}
inline bool SchemaUnit_Parse(
    const ::std::string& name, SchemaUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SchemaUnit>(
    SchemaUnit_descriptor(), name, value);
}
enum ConnectionDirrection {
  Input = 0,
  Output = 1
};
bool ConnectionDirrection_IsValid(int value);
const ConnectionDirrection ConnectionDirrection_MIN = Input;
const ConnectionDirrection ConnectionDirrection_MAX = Output;
const int ConnectionDirrection_ARRAYSIZE = ConnectionDirrection_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionDirrection_descriptor();
inline const ::std::string& ConnectionDirrection_Name(ConnectionDirrection value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionDirrection_descriptor(), value);
}
inline bool ConnectionDirrection_Parse(
    const ::std::string& name, ConnectionDirrection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionDirrection>(
    ConnectionDirrection_descriptor(), name, value);
}
enum FblSignalType {
  Analog = 0,
  Discrete = 1
};
bool FblSignalType_IsValid(int value);
const FblSignalType FblSignalType_MIN = Analog;
const FblSignalType FblSignalType_MAX = Discrete;
const int FblSignalType_ARRAYSIZE = FblSignalType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FblSignalType_descriptor();
inline const ::std::string& FblSignalType_Name(FblSignalType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FblSignalType_descriptor(), value);
}
inline bool FblSignalType_Parse(
    const ::std::string& name, FblSignalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FblSignalType>(
    FblSignalType_descriptor(), name, value);
}
enum FblDataFormat {
  UnsignedInt = 0,
  SignedInt = 1,
  Float = 2
};
bool FblDataFormat_IsValid(int value);
const FblDataFormat FblDataFormat_MIN = UnsignedInt;
const FblDataFormat FblDataFormat_MAX = Float;
const int FblDataFormat_ARRAYSIZE = FblDataFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* FblDataFormat_descriptor();
inline const ::std::string& FblDataFormat_Name(FblDataFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    FblDataFormat_descriptor(), value);
}
inline bool FblDataFormat_Parse(
    const ::std::string& name, FblDataFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FblDataFormat>(
    FblDataFormat_descriptor(), name, value);
}
// ===================================================================

class Uuid : public ::google::protobuf::Message {
 public:
  Uuid();
  virtual ~Uuid();

  Uuid(const Uuid& from);

  inline Uuid& operator=(const Uuid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uuid& default_instance();

  void Swap(Uuid* other);

  // implements Message ----------------------------------------------

  Uuid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Uuid& from);
  void MergeFrom(const Uuid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:Proto.Uuid)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Uuid* default_instance_;
};
// -------------------------------------------------------------------

class qvariant : public ::google::protobuf::Message {
 public:
  qvariant();
  virtual ~qvariant();

  qvariant(const qvariant& from);

  inline qvariant& operator=(const qvariant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const qvariant& default_instance();

  void Swap(qvariant* other);

  // implements Message ----------------------------------------------

  qvariant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const qvariant& from);
  void MergeFrom(const qvariant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 intValue = 2 [default = 0];
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional uint32 uintValue = 3 [default = 0];
  inline bool has_uintvalue() const;
  inline void clear_uintvalue();
  static const int kUintValueFieldNumber = 3;
  inline ::google::protobuf::uint32 uintvalue() const;
  inline void set_uintvalue(::google::protobuf::uint32 value);

  // optional double doubleValue = 4 [default = 0];
  inline bool has_doublevalue() const;
  inline void clear_doublevalue();
  static const int kDoubleValueFieldNumber = 4;
  inline double doublevalue() const;
  inline void set_doublevalue(double value);

  // optional bool boolValue = 5 [default = false];
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 5;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  // @@protoc_insertion_point(class_scope:Proto.qvariant)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_uintvalue();
  inline void clear_has_uintvalue();
  inline void set_has_doublevalue();
  inline void clear_has_doublevalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 intvalue_;
  double doublevalue_;
  ::google::protobuf::uint32 uintvalue_;
  bool boolvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static qvariant* default_instance_;
};
// -------------------------------------------------------------------

class wstring : public ::google::protobuf::Message {
 public:
  wstring();
  virtual ~wstring();

  wstring(const wstring& from);

  inline wstring& operator=(const wstring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wstring& default_instance();

  void Swap(wstring* other);

  // implements Message ----------------------------------------------

  wstring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wstring& from);
  void MergeFrom(const wstring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:Proto.wstring)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static wstring* default_instance_;
};
// -------------------------------------------------------------------

class FontParam : public ::google::protobuf::Message {
 public:
  FontParam();
  virtual ~FontParam();

  FontParam(const FontParam& from);

  inline FontParam& operator=(const FontParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FontParam& default_instance();

  void Swap(FontParam* other);

  // implements Message ----------------------------------------------

  FontParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FontParam& from);
  void MergeFrom(const FontParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring name_obsolete = 1;
  inline bool has_name_obsolete() const;
  inline void clear_name_obsolete();
  static const int kNameObsoleteFieldNumber = 1;
  inline const ::Proto::wstring& name_obsolete() const;
  inline ::Proto::wstring* mutable_name_obsolete();
  inline ::Proto::wstring* release_name_obsolete();
  inline void set_allocated_name_obsolete(::Proto::wstring* name_obsolete);

  // required double size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline double size() const;
  inline void set_size(double value);

  // required bool bold = 3;
  inline bool has_bold() const;
  inline void clear_bold();
  static const int kBoldFieldNumber = 3;
  inline bool bold() const;
  inline void set_bold(bool value);

  // required bool italic = 4;
  inline bool has_italic() const;
  inline void clear_italic();
  static const int kItalicFieldNumber = 4;
  inline bool italic() const;
  inline void set_italic(bool value);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Proto.FontParam)
 private:
  inline void set_has_name_obsolete();
  inline void clear_has_name_obsolete();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_bold();
  inline void clear_has_bold();
  inline void set_has_italic();
  inline void clear_has_italic();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* name_obsolete_;
  double size_;
  ::std::string* name_;
  bool bold_;
  bool italic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FontParam* default_instance_;
};
// -------------------------------------------------------------------

class SchemaPoint : public ::google::protobuf::Message {
 public:
  SchemaPoint();
  virtual ~SchemaPoint();

  SchemaPoint(const SchemaPoint& from);

  inline SchemaPoint& operator=(const SchemaPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaPoint& default_instance();

  void Swap(SchemaPoint* other);

  // implements Message ----------------------------------------------

  SchemaPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaPoint& from);
  void MergeFrom(const SchemaPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaPoint* default_instance_;
};
// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 classnamehash = 1;
  inline bool has_classnamehash() const;
  inline void clear_classnamehash();
  static const int kClassnamehashFieldNumber = 1;
  inline ::google::protobuf::uint32 classnamehash() const;
  inline void set_classnamehash(::google::protobuf::uint32 value);

  // optional bytes compressedObject = 2;
  inline bool has_compressedobject() const;
  inline void clear_compressedobject();
  static const int kCompressedObjectFieldNumber = 2;
  inline const ::std::string& compressedobject() const;
  inline void set_compressedobject(const ::std::string& value);
  inline void set_compressedobject(const char* value);
  inline void set_compressedobject(const void* value, size_t size);
  inline ::std::string* mutable_compressedobject();
  inline ::std::string* release_compressedobject();
  inline void set_allocated_compressedobject(::std::string* compressedobject);

  // optional .Proto.SchemaItem schemaitem = 6;
  inline bool has_schemaitem() const;
  inline void clear_schemaitem();
  static const int kSchemaitemFieldNumber = 6;
  inline const ::Proto::SchemaItem& schemaitem() const;
  inline ::Proto::SchemaItem* mutable_schemaitem();
  inline ::Proto::SchemaItem* release_schemaitem();
  inline void set_allocated_schemaitem(::Proto::SchemaItem* schemaitem);

  // optional .Proto.DeviceObject deviceobject = 7;
  inline bool has_deviceobject() const;
  inline void clear_deviceobject();
  static const int kDeviceobjectFieldNumber = 7;
  inline const ::Proto::DeviceObject& deviceobject() const;
  inline ::Proto::DeviceObject* mutable_deviceobject();
  inline ::Proto::DeviceObject* release_deviceobject();
  inline void set_allocated_deviceobject(::Proto::DeviceObject* deviceobject);

  // optional .Proto.Schema schema = 100;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 100;
  inline const ::Proto::Schema& schema() const;
  inline ::Proto::Schema* mutable_schema();
  inline ::Proto::Schema* release_schema();
  inline void set_allocated_schema(::Proto::Schema* schema);

  // optional .Proto.SchemaLayer schemalayer = 101;
  inline bool has_schemalayer() const;
  inline void clear_schemalayer();
  static const int kSchemalayerFieldNumber = 101;
  inline const ::Proto::SchemaLayer& schemalayer() const;
  inline ::Proto::SchemaLayer* mutable_schemalayer();
  inline ::Proto::SchemaLayer* release_schemalayer();
  inline void set_allocated_schemalayer(::Proto::SchemaLayer* schemalayer);

  // optional .Proto.FblElement fblelement = 102;
  inline bool has_fblelement() const;
  inline void clear_fblelement();
  static const int kFblelementFieldNumber = 102;
  inline const ::Proto::FblElement& fblelement() const;
  inline ::Proto::FblElement* mutable_fblelement();
  inline ::Proto::FblElement* release_fblelement();
  inline void set_allocated_fblelement(::Proto::FblElement* fblelement);

  // optional .Proto.Configuration configuration = 103;
  inline bool has_configuration() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 103;
  inline const ::Proto::Configuration& configuration() const;
  inline ::Proto::Configuration* mutable_configuration();
  inline ::Proto::Configuration* release_configuration();
  inline void set_allocated_configuration(::Proto::Configuration* configuration);

  // optional .Proto.Connection connection = 104;
  inline bool has_connection() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 104;
  inline const ::Proto::Connection& connection() const;
  inline ::Proto::Connection* mutable_connection();
  inline ::Proto::Connection* release_connection();
  inline void set_allocated_connection(::Proto::Connection* connection);

  // optional .Proto.SchemaDetailsSet schemaDetailsSet = 105;
  inline bool has_schemadetailsset() const;
  inline void clear_schemadetailsset();
  static const int kSchemaDetailsSetFieldNumber = 105;
  inline const ::Proto::SchemaDetailsSet& schemadetailsset() const;
  inline ::Proto::SchemaDetailsSet* mutable_schemadetailsset();
  inline ::Proto::SchemaDetailsSet* release_schemadetailsset();
  inline void set_allocated_schemadetailsset(::Proto::SchemaDetailsSet* schemadetailsset);

  // @@protoc_insertion_point(class_scope:Proto.Envelope)
 private:
  inline void set_has_classnamehash();
  inline void clear_has_classnamehash();
  inline void set_has_compressedobject();
  inline void clear_has_compressedobject();
  inline void set_has_schemaitem();
  inline void clear_has_schemaitem();
  inline void set_has_deviceobject();
  inline void clear_has_deviceobject();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_schemalayer();
  inline void clear_has_schemalayer();
  inline void set_has_fblelement();
  inline void clear_has_fblelement();
  inline void set_has_configuration();
  inline void clear_has_configuration();
  inline void set_has_connection();
  inline void clear_has_connection();
  inline void set_has_schemadetailsset();
  inline void clear_has_schemadetailsset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* compressedobject_;
  ::Proto::SchemaItem* schemaitem_;
  ::Proto::DeviceObject* deviceobject_;
  ::Proto::Schema* schema_;
  ::Proto::SchemaLayer* schemalayer_;
  ::Proto::FblElement* fblelement_;
  ::Proto::Configuration* configuration_;
  ::Proto::Connection* connection_;
  ::Proto::SchemaDetailsSet* schemadetailsset_;
  ::google::protobuf::uint32 classnamehash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class EnvelopeSet : public ::google::protobuf::Message {
 public:
  EnvelopeSet();
  virtual ~EnvelopeSet();

  EnvelopeSet(const EnvelopeSet& from);

  inline EnvelopeSet& operator=(const EnvelopeSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnvelopeSet& default_instance();

  void Swap(EnvelopeSet* other);

  // implements Message ----------------------------------------------

  EnvelopeSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnvelopeSet& from);
  void MergeFrom(const EnvelopeSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.Envelope items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Proto::Envelope& items(int index) const;
  inline ::Proto::Envelope* mutable_items(int index);
  inline ::Proto::Envelope* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Proto.EnvelopeSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static EnvelopeSet* default_instance_;
};
// -------------------------------------------------------------------

class EnvelopeSetShortDescription : public ::google::protobuf::Message {
 public:
  EnvelopeSetShortDescription();
  virtual ~EnvelopeSetShortDescription();

  EnvelopeSetShortDescription(const EnvelopeSetShortDescription& from);

  inline EnvelopeSetShortDescription& operator=(const EnvelopeSetShortDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnvelopeSetShortDescription& default_instance();

  void Swap(EnvelopeSetShortDescription* other);

  // implements Message ----------------------------------------------

  EnvelopeSetShortDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnvelopeSetShortDescription& from);
  void MergeFrom(const EnvelopeSetShortDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 projectdbversion = 1;
  inline bool has_projectdbversion() const;
  inline void clear_projectdbversion();
  static const int kProjectdbversionFieldNumber = 1;
  inline ::google::protobuf::uint32 projectdbversion() const;
  inline void set_projectdbversion(::google::protobuf::uint32 value);

  // repeated uint32 classnamehash = 2;
  inline int classnamehash_size() const;
  inline void clear_classnamehash();
  static const int kClassnamehashFieldNumber = 2;
  inline ::google::protobuf::uint32 classnamehash(int index) const;
  inline void set_classnamehash(int index, ::google::protobuf::uint32 value);
  inline void add_classnamehash(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      classnamehash() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_classnamehash();

  // optional bool equipmentEditor = 3;
  inline bool has_equipmenteditor() const;
  inline void clear_equipmenteditor();
  static const int kEquipmentEditorFieldNumber = 3;
  inline bool equipmenteditor() const;
  inline void set_equipmenteditor(bool value);

  // optional bool presetEditor = 4;
  inline bool has_preseteditor() const;
  inline void clear_preseteditor();
  static const int kPresetEditorFieldNumber = 4;
  inline bool preseteditor() const;
  inline void set_preseteditor(bool value);

  // @@protoc_insertion_point(class_scope:Proto.EnvelopeSetShortDescription)
 private:
  inline void set_has_projectdbversion();
  inline void clear_has_projectdbversion();
  inline void set_has_equipmenteditor();
  inline void clear_has_equipmenteditor();
  inline void set_has_preseteditor();
  inline void clear_has_preseteditor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > classnamehash_;
  ::google::protobuf::uint32 projectdbversion_;
  bool equipmenteditor_;
  bool preseteditor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static EnvelopeSetShortDescription* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.wstring variables = 4;
  inline bool has_variables() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 4;
  inline const ::Proto::wstring& variables() const;
  inline ::Proto::wstring* mutable_variables();
  inline ::Proto::wstring* release_variables();
  inline void set_allocated_variables(::Proto::wstring* variables);

  // required .Proto.wstring globals = 5;
  inline bool has_globals() const;
  inline void clear_globals();
  static const int kGlobalsFieldNumber = 5;
  inline const ::Proto::wstring& globals() const;
  inline ::Proto::wstring* mutable_globals();
  inline ::Proto::wstring* release_globals();
  inline void set_allocated_globals(::Proto::wstring* globals);

  // repeated .Proto.Uuid schemasIDs = 100;
  inline int schemasids_size() const;
  inline void clear_schemasids();
  static const int kSchemasIDsFieldNumber = 100;
  inline const ::Proto::Uuid& schemasids(int index) const;
  inline ::Proto::Uuid* mutable_schemasids(int index);
  inline ::Proto::Uuid* add_schemasids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
      schemasids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
      mutable_schemasids();

  // repeated .Proto.Envelope schemas = 101;
  inline int schemas_size() const;
  inline void clear_schemas();
  static const int kSchemasFieldNumber = 101;
  inline const ::Proto::Envelope& schemas(int index) const;
  inline ::Proto::Envelope* mutable_schemas(int index);
  inline ::Proto::Envelope* add_schemas();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      schemas() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_schemas();

  // @@protoc_insertion_point(class_scope:Proto.Configuration)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_variables();
  inline void clear_has_variables();
  inline void set_has_globals();
  inline void clear_has_globals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::Proto::wstring* variables_;
  ::Proto::wstring* globals_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Uuid > schemasids_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > schemas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class AfbElementCollection : public ::google::protobuf::Message {
 public:
  AfbElementCollection();
  virtual ~AfbElementCollection();

  AfbElementCollection(const AfbElementCollection& from);

  inline AfbElementCollection& operator=(const AfbElementCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbElementCollection& default_instance();

  void Swap(AfbElementCollection* other);

  // implements Message ----------------------------------------------

  AfbElementCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbElementCollection& from);
  void MergeFrom(const AfbElementCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.AfbElementXml elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Proto::AfbElementXml& elements(int index) const;
  inline ::Proto::AfbElementXml* mutable_elements(int index);
  inline ::Proto::AfbElementXml* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Proto.AfbElementCollection)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml > elements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbElementCollection* default_instance_;
};
// -------------------------------------------------------------------

class AfbElementXml : public ::google::protobuf::Message {
 public:
  AfbElementXml();
  virtual ~AfbElementXml();

  AfbElementXml(const AfbElementXml& from);

  inline AfbElementXml& operator=(const AfbElementXml& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbElementXml& default_instance();

  void Swap(AfbElementXml* other);

  // implements Message ----------------------------------------------

  AfbElementXml* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbElementXml& from);
  void MergeFrom(const AfbElementXml& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Proto.AfbElementXml)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbElementXml* default_instance_;
};
// -------------------------------------------------------------------

class FblElement : public ::google::protobuf::Message {
 public:
  FblElement();
  virtual ~FblElement();

  FblElement(const FblElement& from);

  inline FblElement& operator=(const FblElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblElement& default_instance();

  void Swap(FblElement* other);

  // implements Message ----------------------------------------------

  FblElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblElement& from);
  void MergeFrom(const FblElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required uint32 opcode = 4;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 4;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);

  // optional bool hasRam = 5 [default = false];
  inline bool has_hasram() const;
  inline void clear_hasram();
  static const int kHasRamFieldNumber = 5;
  inline bool hasram() const;
  inline void set_hasram(bool value);

  // optional bool requiredStart = 6 [default = true];
  inline bool has_requiredstart() const;
  inline void clear_requiredstart();
  static const int kRequiredStartFieldNumber = 6;
  inline bool requiredstart() const;
  inline void set_requiredstart(bool value);

  // repeated .Proto.AfbSignal inputs = 11;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 11;
  inline const ::Proto::AfbSignal& inputs(int index) const;
  inline ::Proto::AfbSignal* mutable_inputs(int index);
  inline ::Proto::AfbSignal* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
      mutable_inputs();

  // repeated .Proto.AfbSignal outputs = 12;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 12;
  inline const ::Proto::AfbSignal& outputs(int index) const;
  inline ::Proto::AfbSignal* mutable_outputs(int index);
  inline ::Proto::AfbSignal* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
      mutable_outputs();

  // repeated .Proto.AfbParam params = 13;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 13;
  inline const ::Proto::AfbParam& params(int index) const;
  inline ::Proto::AfbParam* mutable_params(int index);
  inline ::Proto::AfbParam* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
      mutable_params();

  // optional .Proto.wstring description = 14;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 14;
  inline const ::Proto::wstring& description() const;
  inline ::Proto::wstring* mutable_description();
  inline ::Proto::wstring* release_description();
  inline void set_allocated_description(::Proto::wstring* description);

  // @@protoc_insertion_point(class_scope:Proto.FblElement)
 private:
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_hasram();
  inline void clear_has_hasram();
  inline void set_has_requiredstart();
  inline void clear_has_requiredstart();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::google::protobuf::uint32 opcode_;
  bool hasram_;
  bool requiredstart_;
  ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal > inputs_;
  ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal > outputs_;
  ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam > params_;
  ::Proto::wstring* description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblElement* default_instance_;
};
// -------------------------------------------------------------------

class AfbSignal : public ::google::protobuf::Message {
 public:
  AfbSignal();
  virtual ~AfbSignal();

  AfbSignal(const AfbSignal& from);

  inline AfbSignal& operator=(const AfbSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbSignal& default_instance();

  void Swap(AfbSignal* other);

  // implements Message ----------------------------------------------

  AfbSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbSignal& from);
  void MergeFrom(const AfbSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.FblSignalType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Proto::FblSignalType type() const;
  inline void set_type(::Proto::FblSignalType value);

  // optional int32 operandIndex = 3 [default = 0];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 3;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional int32 size = 4 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional .Proto.wstring opName = 5;
  inline bool has_opname() const;
  inline void clear_opname();
  static const int kOpNameFieldNumber = 5;
  inline const ::Proto::wstring& opname() const;
  inline ::Proto::wstring* mutable_opname();
  inline ::Proto::wstring* release_opname();
  inline void set_allocated_opname(::Proto::wstring* opname);

  // optional .Proto.FblDataFormat dataFormat = 6;
  inline bool has_dataformat() const;
  inline void clear_dataformat();
  static const int kDataFormatFieldNumber = 6;
  inline ::Proto::FblDataFormat dataformat() const;
  inline void set_dataformat(::Proto::FblDataFormat value);

  // @@protoc_insertion_point(class_scope:Proto.AfbSignal)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_opname();
  inline void clear_has_opname();
  inline void set_has_dataformat();
  inline void clear_has_dataformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* caption_;
  int type_;
  ::google::protobuf::int32 operandindex_;
  ::Proto::wstring* opname_;
  ::google::protobuf::int32 size_;
  int dataformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbSignal* default_instance_;
};
// -------------------------------------------------------------------

class AfbParam : public ::google::protobuf::Message {
 public:
  AfbParam();
  virtual ~AfbParam();

  AfbParam(const AfbParam& from);

  inline AfbParam& operator=(const AfbParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbParam& default_instance();

  void Swap(AfbParam* other);

  // implements Message ----------------------------------------------

  AfbParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbParam& from);
  void MergeFrom(const AfbParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required bool visible = 7;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 7;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional int32 operandIndex = 8 [default = 0];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 8;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional int32 size = 9 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional bool instantiator = 10 [default = false];
  inline bool has_instantiator() const;
  inline void clear_instantiator();
  static const int kInstantiatorFieldNumber = 10;
  inline bool instantiator() const;
  inline void set_instantiator(bool value);

  // optional bool user = 11 [default = false];
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 11;
  inline bool user() const;
  inline void set_user(bool value);

  // optional .Proto.wstring changedScript = 12;
  inline bool has_changedscript() const;
  inline void clear_changedscript();
  static const int kChangedScriptFieldNumber = 12;
  inline const ::Proto::wstring& changedscript() const;
  inline ::Proto::wstring* mutable_changedscript();
  inline ::Proto::wstring* release_changedscript();
  inline void set_allocated_changedscript(::Proto::wstring* changedscript);

  // optional .Proto.qvariant value = 13;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 13;
  inline const ::Proto::qvariant& value() const;
  inline ::Proto::qvariant* mutable_value();
  inline ::Proto::qvariant* release_value();
  inline void set_allocated_value(::Proto::qvariant* value);

  // optional .Proto.qvariant defaultvalue = 14;
  inline bool has_defaultvalue() const;
  inline void clear_defaultvalue();
  static const int kDefaultvalueFieldNumber = 14;
  inline const ::Proto::qvariant& defaultvalue() const;
  inline ::Proto::qvariant* mutable_defaultvalue();
  inline ::Proto::qvariant* release_defaultvalue();
  inline void set_allocated_defaultvalue(::Proto::qvariant* defaultvalue);

  // optional .Proto.qvariant lowlimit = 15;
  inline bool has_lowlimit() const;
  inline void clear_lowlimit();
  static const int kLowlimitFieldNumber = 15;
  inline const ::Proto::qvariant& lowlimit() const;
  inline ::Proto::qvariant* mutable_lowlimit();
  inline ::Proto::qvariant* release_lowlimit();
  inline void set_allocated_lowlimit(::Proto::qvariant* lowlimit);

  // optional .Proto.qvariant highlimit = 16;
  inline bool has_highlimit() const;
  inline void clear_highlimit();
  static const int kHighlimitFieldNumber = 16;
  inline const ::Proto::qvariant& highlimit() const;
  inline ::Proto::qvariant* mutable_highlimit();
  inline ::Proto::qvariant* release_highlimit();
  inline void set_allocated_highlimit(::Proto::qvariant* highlimit);

  // optional .Proto.wstring opName = 17;
  inline bool has_opname() const;
  inline void clear_opname();
  static const int kOpNameFieldNumber = 17;
  inline const ::Proto::wstring& opname() const;
  inline ::Proto::wstring* mutable_opname();
  inline ::Proto::wstring* release_opname();
  inline void set_allocated_opname(::Proto::wstring* opname);

  // optional .Proto.FblSignalType type = 18;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 18;
  inline ::Proto::FblSignalType type() const;
  inline void set_type(::Proto::FblSignalType value);

  // optional .Proto.FblDataFormat dataFormat = 19;
  inline bool has_dataformat() const;
  inline void clear_dataformat();
  static const int kDataFormatFieldNumber = 19;
  inline ::Proto::FblDataFormat dataformat() const;
  inline void set_dataformat(::Proto::FblDataFormat value);

  // @@protoc_insertion_point(class_scope:Proto.AfbParam)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_instantiator();
  inline void clear_has_instantiator();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_changedscript();
  inline void clear_has_changedscript();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_defaultvalue();
  inline void clear_has_defaultvalue();
  inline void set_has_lowlimit();
  inline void clear_has_lowlimit();
  inline void set_has_highlimit();
  inline void clear_has_highlimit();
  inline void set_has_opname();
  inline void clear_has_opname();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dataformat();
  inline void clear_has_dataformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* caption_;
  ::google::protobuf::int32 operandindex_;
  ::google::protobuf::int32 size_;
  bool visible_;
  bool instantiator_;
  bool user_;
  int type_;
  ::Proto::wstring* changedscript_;
  ::Proto::qvariant* value_;
  ::Proto::qvariant* defaultvalue_;
  ::Proto::qvariant* lowlimit_;
  ::Proto::qvariant* highlimit_;
  ::Proto::wstring* opname_;
  int dataformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbParam* default_instance_;
};
// -------------------------------------------------------------------

class Schema : public ::google::protobuf::Message {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Schema& default_instance();

  void Swap(Schema* other);

  // implements Message ----------------------------------------------

  Schema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring schemaID = 2;
  inline bool has_schemaid() const;
  inline void clear_schemaid();
  static const int kSchemaIDFieldNumber = 2;
  inline const ::Proto::wstring& schemaid() const;
  inline ::Proto::wstring* mutable_schemaid();
  inline ::Proto::wstring* release_schemaid();
  inline void set_allocated_schemaid(::Proto::wstring* schemaid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required double width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline double width() const;
  inline void set_width(double value);

  // required double height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline double height() const;
  inline void set_height(double value);

  // required .Proto.SchemaUnit unit = 6;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 6;
  inline ::Proto::SchemaUnit unit() const;
  inline void set_unit(::Proto::SchemaUnit value);

  // optional bool excludeFromBuild = 7 [default = false];
  inline bool has_excludefrombuild() const;
  inline void clear_excludefrombuild();
  static const int kExcludeFromBuildFieldNumber = 7;
  inline bool excludefrombuild() const;
  inline void set_excludefrombuild(bool value);

  // optional uint32 backgroundColor = 8;
  inline bool has_backgroundcolor() const;
  inline void clear_backgroundcolor();
  static const int kBackgroundColorFieldNumber = 8;
  inline ::google::protobuf::uint32 backgroundcolor() const;
  inline void set_backgroundcolor(::google::protobuf::uint32 value);

  // repeated .Proto.Envelope layers = 100;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 100;
  inline const ::Proto::Envelope& layers(int index) const;
  inline ::Proto::Envelope* mutable_layers(int index);
  inline ::Proto::Envelope* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_layers();

  // required .Proto.AfbElementCollection afbs = 101;
  inline bool has_afbs() const;
  inline void clear_afbs();
  static const int kAfbsFieldNumber = 101;
  inline const ::Proto::AfbElementCollection& afbs() const;
  inline ::Proto::AfbElementCollection* mutable_afbs();
  inline ::Proto::AfbElementCollection* release_afbs();
  inline void set_allocated_afbs(::Proto::AfbElementCollection* afbs);

  // optional .Proto.LogicSchema logic_schema = 200;
  inline bool has_logic_schema() const;
  inline void clear_logic_schema();
  static const int kLogicSchemaFieldNumber = 200;
  inline const ::Proto::LogicSchema& logic_schema() const;
  inline ::Proto::LogicSchema* mutable_logic_schema();
  inline ::Proto::LogicSchema* release_logic_schema();
  inline void set_allocated_logic_schema(::Proto::LogicSchema* logic_schema);

  // optional .Proto.UfbSchema ufb_schema = 201;
  inline bool has_ufb_schema() const;
  inline void clear_ufb_schema();
  static const int kUfbSchemaFieldNumber = 201;
  inline const ::Proto::UfbSchema& ufb_schema() const;
  inline ::Proto::UfbSchema* mutable_ufb_schema();
  inline ::Proto::UfbSchema* release_ufb_schema();
  inline void set_allocated_ufb_schema(::Proto::UfbSchema* ufb_schema);

  // @@protoc_insertion_point(class_scope:Proto.Schema)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_schemaid();
  inline void clear_has_schemaid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_excludefrombuild();
  inline void clear_has_excludefrombuild();
  inline void set_has_backgroundcolor();
  inline void clear_has_backgroundcolor();
  inline void set_has_afbs();
  inline void clear_has_afbs();
  inline void set_has_logic_schema();
  inline void clear_has_logic_schema();
  inline void set_has_ufb_schema();
  inline void clear_has_ufb_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* schemaid_;
  ::Proto::wstring* caption_;
  double width_;
  double height_;
  int unit_;
  bool excludefrombuild_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > layers_;
  ::Proto::AfbElementCollection* afbs_;
  ::Proto::LogicSchema* logic_schema_;
  ::Proto::UfbSchema* ufb_schema_;
  ::google::protobuf::uint32 backgroundcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Schema* default_instance_;
};
// -------------------------------------------------------------------

class LogicSchema : public ::google::protobuf::Message {
 public:
  LogicSchema();
  virtual ~LogicSchema();

  LogicSchema(const LogicSchema& from);

  inline LogicSchema& operator=(const LogicSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicSchema& default_instance();

  void Swap(LogicSchema* other);

  // implements Message ----------------------------------------------

  LogicSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicSchema& from);
  void MergeFrom(const LogicSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.wstring equipmentids = 1;
  inline int equipmentids_size() const;
  inline void clear_equipmentids();
  static const int kEquipmentidsFieldNumber = 1;
  inline const ::Proto::wstring& equipmentids(int index) const;
  inline ::Proto::wstring* mutable_equipmentids(int index);
  inline ::Proto::wstring* add_equipmentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
      equipmentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
      mutable_equipmentids();

  // optional int32 counter = 2 [default = 0];
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 2;
  inline ::google::protobuf::int32 counter() const;
  inline void set_counter(::google::protobuf::int32 value);

  // optional string lmDescriptionFile = 3 [default = "LogicModule0000.xml"];
  inline bool has_lmdescriptionfile() const;
  inline void clear_lmdescriptionfile();
  static const int kLmDescriptionFileFieldNumber = 3;
  inline const ::std::string& lmdescriptionfile() const;
  inline void set_lmdescriptionfile(const ::std::string& value);
  inline void set_lmdescriptionfile(const char* value);
  inline void set_lmdescriptionfile(const char* value, size_t size);
  inline ::std::string* mutable_lmdescriptionfile();
  inline ::std::string* release_lmdescriptionfile();
  inline void set_allocated_lmdescriptionfile(::std::string* lmdescriptionfile);

  // @@protoc_insertion_point(class_scope:Proto.LogicSchema)
 private:
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_lmdescriptionfile();
  inline void clear_has_lmdescriptionfile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::wstring > equipmentids_;
  ::std::string* lmdescriptionfile_;
  static ::std::string* _default_lmdescriptionfile_;
  ::google::protobuf::int32 counter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static LogicSchema* default_instance_;
};
// -------------------------------------------------------------------

class UfbSchema : public ::google::protobuf::Message {
 public:
  UfbSchema();
  virtual ~UfbSchema();

  UfbSchema(const UfbSchema& from);

  inline UfbSchema& operator=(const UfbSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UfbSchema& default_instance();

  void Swap(UfbSchema* other);

  // implements Message ----------------------------------------------

  UfbSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UfbSchema& from);
  void MergeFrom(const UfbSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string description = 1;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 1;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional int32 version = 2 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string lmDescriptionFile = 3 [default = "LogicModule0000.xml"];
  inline bool has_lmdescriptionfile() const;
  inline void clear_lmdescriptionfile();
  static const int kLmDescriptionFileFieldNumber = 3;
  inline const ::std::string& lmdescriptionfile() const;
  inline void set_lmdescriptionfile(const ::std::string& value);
  inline void set_lmdescriptionfile(const char* value);
  inline void set_lmdescriptionfile(const char* value, size_t size);
  inline ::std::string* mutable_lmdescriptionfile();
  inline ::std::string* release_lmdescriptionfile();
  inline void set_allocated_lmdescriptionfile(::std::string* lmdescriptionfile);

  // @@protoc_insertion_point(class_scope:Proto.UfbSchema)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_lmdescriptionfile();
  inline void clear_has_lmdescriptionfile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  ::std::string* lmdescriptionfile_;
  static ::std::string* _default_lmdescriptionfile_;
  ::google::protobuf::int32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static UfbSchema* default_instance_;
};
// -------------------------------------------------------------------

class SchemaLayer : public ::google::protobuf::Message {
 public:
  SchemaLayer();
  virtual ~SchemaLayer();

  SchemaLayer(const SchemaLayer& from);

  inline SchemaLayer& operator=(const SchemaLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaLayer& default_instance();

  void Swap(SchemaLayer* other);

  // implements Message ----------------------------------------------

  SchemaLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaLayer& from);
  void MergeFrom(const SchemaLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::Proto::wstring& name() const;
  inline ::Proto::wstring* mutable_name();
  inline ::Proto::wstring* release_name();
  inline void set_allocated_name(::Proto::wstring* name);

  // required bool compile = 3;
  inline bool has_compile() const;
  inline void clear_compile();
  static const int kCompileFieldNumber = 3;
  inline bool compile() const;
  inline void set_compile(bool value);

  // required bool show = 4;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 4;
  inline bool show() const;
  inline void set_show(bool value);

  // required bool print = 5;
  inline bool has_print() const;
  inline void clear_print();
  static const int kPrintFieldNumber = 5;
  inline bool print() const;
  inline void set_print(bool value);

  // repeated .Proto.Envelope items = 15;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 15;
  inline const ::Proto::Envelope& items(int index) const;
  inline ::Proto::Envelope* mutable_items(int index);
  inline ::Proto::Envelope* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Proto.SchemaLayer)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_compile();
  inline void clear_has_compile();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_print();
  inline void clear_has_print();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* name_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > items_;
  bool compile_;
  bool show_;
  bool print_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaLayer* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItem : public ::google::protobuf::Message {
 public:
  SchemaItem();
  virtual ~SchemaItem();

  SchemaItem(const SchemaItem& from);

  inline SchemaItem& operator=(const SchemaItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItem& default_instance();

  void Swap(SchemaItem* other);

  // implements Message ----------------------------------------------

  SchemaItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItem& from);
  void MergeFrom(const SchemaItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required bool isStatic = 2;
  inline bool has_isstatic() const;
  inline void clear_isstatic();
  static const int kIsStaticFieldNumber = 2;
  inline bool isstatic() const;
  inline void set_isstatic(bool value);

  // required bool isLocked = 3;
  inline bool has_islocked() const;
  inline void clear_islocked();
  static const int kIsLockedFieldNumber = 3;
  inline bool islocked() const;
  inline void set_islocked(bool value);

  // required .Proto.SchemaUnit itemUnit = 4;
  inline bool has_itemunit() const;
  inline void clear_itemunit();
  static const int kItemUnitFieldNumber = 4;
  inline ::Proto::SchemaUnit itemunit() const;
  inline void set_itemunit(::Proto::SchemaUnit value);

  // optional bool acceptClick = 5 [default = false];
  inline bool has_acceptclick() const;
  inline void clear_acceptclick();
  static const int kAcceptClickFieldNumber = 5;
  inline bool acceptclick() const;
  inline void set_acceptclick(bool value);

  // optional string clickScript = 7;
  inline bool has_clickscript() const;
  inline void clear_clickscript();
  static const int kClickScriptFieldNumber = 7;
  inline const ::std::string& clickscript() const;
  inline void set_clickscript(const ::std::string& value);
  inline void set_clickscript(const char* value);
  inline void set_clickscript(const char* value, size_t size);
  inline ::std::string* mutable_clickscript();
  inline ::std::string* release_clickscript();
  inline void set_allocated_clickscript(::std::string* clickscript);

  // optional bool isCommented = 8 [default = false];
  inline bool has_iscommented() const;
  inline void clear_iscommented();
  static const int kIsCommentedFieldNumber = 8;
  inline bool iscommented() const;
  inline void set_iscommented(bool value);

  // optional string objectName = 9;
  inline bool has_objectname() const;
  inline void clear_objectname();
  static const int kObjectNameFieldNumber = 9;
  inline const ::std::string& objectname() const;
  inline void set_objectname(const ::std::string& value);
  inline void set_objectname(const char* value);
  inline void set_objectname(const char* value, size_t size);
  inline ::std::string* mutable_objectname();
  inline ::std::string* release_objectname();
  inline void set_allocated_objectname(::std::string* objectname);

  // optional string preDrawScript = 30;
  inline bool has_predrawscript() const;
  inline void clear_predrawscript();
  static const int kPreDrawScriptFieldNumber = 30;
  inline const ::std::string& predrawscript() const;
  inline void set_predrawscript(const ::std::string& value);
  inline void set_predrawscript(const char* value);
  inline void set_predrawscript(const char* value, size_t size);
  inline ::std::string* mutable_predrawscript();
  inline ::std::string* release_predrawscript();
  inline void set_allocated_predrawscript(::std::string* predrawscript);

  // optional .Proto.PosRectImpl PosRectImpl = 10;
  inline bool has_posrectimpl() const;
  inline void clear_posrectimpl();
  static const int kPosRectImplFieldNumber = 10;
  inline const ::Proto::PosRectImpl& posrectimpl() const;
  inline ::Proto::PosRectImpl* mutable_posrectimpl();
  inline ::Proto::PosRectImpl* release_posrectimpl();
  inline void set_allocated_posrectimpl(::Proto::PosRectImpl* posrectimpl);

  // optional .Proto.PosLineImpl PosLineImpl = 11;
  inline bool has_poslineimpl() const;
  inline void clear_poslineimpl();
  static const int kPosLineImplFieldNumber = 11;
  inline const ::Proto::PosLineImpl& poslineimpl() const;
  inline ::Proto::PosLineImpl* mutable_poslineimpl();
  inline ::Proto::PosLineImpl* release_poslineimpl();
  inline void set_allocated_poslineimpl(::Proto::PosLineImpl* poslineimpl);

  // optional .Proto.PosConnectionImpl PosConnectionImpl = 12;
  inline bool has_posconnectionimpl() const;
  inline void clear_posconnectionimpl();
  static const int kPosConnectionImplFieldNumber = 12;
  inline const ::Proto::PosConnectionImpl& posconnectionimpl() const;
  inline ::Proto::PosConnectionImpl* mutable_posconnectionimpl();
  inline ::Proto::PosConnectionImpl* release_posconnectionimpl();
  inline void set_allocated_posconnectionimpl(::Proto::PosConnectionImpl* posconnectionimpl);

  // optional .Proto.FblItem FblItem = 106;
  inline bool has_fblitem() const;
  inline void clear_fblitem();
  static const int kFblItemFieldNumber = 106;
  inline const ::Proto::FblItem& fblitem() const;
  inline ::Proto::FblItem* mutable_fblitem();
  inline ::Proto::FblItem* release_fblitem();
  inline void set_allocated_fblitem(::Proto::FblItem* fblitem);

  // optional .Proto.FblItemRect FblItemRect = 107;
  inline bool has_fblitemrect() const;
  inline void clear_fblitemrect();
  static const int kFblItemRectFieldNumber = 107;
  inline const ::Proto::FblItemRect& fblitemrect() const;
  inline ::Proto::FblItemRect* mutable_fblitemrect();
  inline ::Proto::FblItemRect* release_fblitemrect();
  inline void set_allocated_fblitemrect(::Proto::FblItemRect* fblitemrect);

  // optional .Proto.FblItemLine FblItemLine = 108;
  inline bool has_fblitemline() const;
  inline void clear_fblitemline();
  static const int kFblItemLineFieldNumber = 108;
  inline const ::Proto::FblItemLine& fblitemline() const;
  inline ::Proto::FblItemLine* mutable_fblitemline();
  inline ::Proto::FblItemLine* release_fblitemline();
  inline void set_allocated_fblitemline(::Proto::FblItemLine* fblitemline);

  // optional .Proto.SchemaItemRect Rect = 116;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 116;
  inline const ::Proto::SchemaItemRect& rect() const;
  inline ::Proto::SchemaItemRect* mutable_rect();
  inline ::Proto::SchemaItemRect* release_rect();
  inline void set_allocated_rect(::Proto::SchemaItemRect* rect);

  // optional .Proto.SchemaItemLine Line = 117;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 117;
  inline const ::Proto::SchemaItemLine& line() const;
  inline ::Proto::SchemaItemLine* mutable_line();
  inline ::Proto::SchemaItemLine* release_line();
  inline void set_allocated_line(::Proto::SchemaItemLine* line);

  // optional .Proto.SchemaItemPath Path = 118;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 118;
  inline const ::Proto::SchemaItemPath& path() const;
  inline ::Proto::SchemaItemPath* mutable_path();
  inline ::Proto::SchemaItemPath* release_path();
  inline void set_allocated_path(::Proto::SchemaItemPath* path);

  // optional .Proto.SchemaItemSignal Signal = 124;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 124;
  inline const ::Proto::SchemaItemSignal& signal() const;
  inline ::Proto::SchemaItemSignal* mutable_signal();
  inline ::Proto::SchemaItemSignal* release_signal();
  inline void set_allocated_signal(::Proto::SchemaItemSignal* signal);

  // optional .Proto.SchemaItemInput InputSignal = 125;
  inline bool has_inputsignal() const;
  inline void clear_inputsignal();
  static const int kInputSignalFieldNumber = 125;
  inline const ::Proto::SchemaItemInput& inputsignal() const;
  inline ::Proto::SchemaItemInput* mutable_inputsignal();
  inline ::Proto::SchemaItemInput* release_inputsignal();
  inline void set_allocated_inputsignal(::Proto::SchemaItemInput* inputsignal);

  // optional .Proto.SchemaItemOutput OutputSignal = 126;
  inline bool has_outputsignal() const;
  inline void clear_outputsignal();
  static const int kOutputSignalFieldNumber = 126;
  inline const ::Proto::SchemaItemOutput& outputsignal() const;
  inline ::Proto::SchemaItemOutput* mutable_outputsignal();
  inline ::Proto::SchemaItemOutput* release_outputsignal();
  inline void set_allocated_outputsignal(::Proto::SchemaItemOutput* outputsignal);

  // optional .Proto.SchemaItemLink Link = 127;
  inline bool has_link() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 127;
  inline const ::Proto::SchemaItemLink& link() const;
  inline ::Proto::SchemaItemLink* mutable_link();
  inline ::Proto::SchemaItemLink* release_link();
  inline void set_allocated_link(::Proto::SchemaItemLink* link);

  // optional .Proto.SchemaItemAfb Afb = 128;
  inline bool has_afb() const;
  inline void clear_afb();
  static const int kAfbFieldNumber = 128;
  inline const ::Proto::SchemaItemAfb& afb() const;
  inline ::Proto::SchemaItemAfb* mutable_afb();
  inline ::Proto::SchemaItemAfb* release_afb();
  inline void set_allocated_afb(::Proto::SchemaItemAfb* afb);

  // optional .Proto.SchemaItemConst ConstItem = 129;
  inline bool has_constitem() const;
  inline void clear_constitem();
  static const int kConstItemFieldNumber = 129;
  inline const ::Proto::SchemaItemConst& constitem() const;
  inline ::Proto::SchemaItemConst* mutable_constitem();
  inline ::Proto::SchemaItemConst* release_constitem();
  inline void set_allocated_constitem(::Proto::SchemaItemConst* constitem);

  // optional .Proto.SchemaItemConnection ConnectionItem = 130;
  inline bool has_connectionitem() const;
  inline void clear_connectionitem();
  static const int kConnectionItemFieldNumber = 130;
  inline const ::Proto::SchemaItemConnection& connectionitem() const;
  inline ::Proto::SchemaItemConnection* mutable_connectionitem();
  inline ::Proto::SchemaItemConnection* release_connectionitem();
  inline void set_allocated_connectionitem(::Proto::SchemaItemConnection* connectionitem);

  // optional .Proto.SchemaItemTransmitter TransmitterItem = 131;
  inline bool has_transmitteritem() const;
  inline void clear_transmitteritem();
  static const int kTransmitterItemFieldNumber = 131;
  inline const ::Proto::SchemaItemTransmitter& transmitteritem() const;
  inline ::Proto::SchemaItemTransmitter* mutable_transmitteritem();
  inline ::Proto::SchemaItemTransmitter* release_transmitteritem();
  inline void set_allocated_transmitteritem(::Proto::SchemaItemTransmitter* transmitteritem);

  // optional .Proto.SchemaItemReceiver ReceiverItem = 132;
  inline bool has_receiveritem() const;
  inline void clear_receiveritem();
  static const int kReceiverItemFieldNumber = 132;
  inline const ::Proto::SchemaItemReceiver& receiveritem() const;
  inline ::Proto::SchemaItemReceiver* mutable_receiveritem();
  inline ::Proto::SchemaItemReceiver* release_receiveritem();
  inline void set_allocated_receiveritem(::Proto::SchemaItemReceiver* receiveritem);

  // optional .Proto.SchemaItemInOut InOutSignal = 133;
  inline bool has_inoutsignal() const;
  inline void clear_inoutsignal();
  static const int kInOutSignalFieldNumber = 133;
  inline const ::Proto::SchemaItemInOut& inoutsignal() const;
  inline ::Proto::SchemaItemInOut* mutable_inoutsignal();
  inline ::Proto::SchemaItemInOut* release_inoutsignal();
  inline void set_allocated_inoutsignal(::Proto::SchemaItemInOut* inoutsignal);

  // optional .Proto.SchemaItemUfb ufb = 134;
  inline bool has_ufb() const;
  inline void clear_ufb();
  static const int kUfbFieldNumber = 134;
  inline const ::Proto::SchemaItemUfb& ufb() const;
  inline ::Proto::SchemaItemUfb* mutable_ufb();
  inline ::Proto::SchemaItemUfb* release_ufb();
  inline void set_allocated_ufb(::Proto::SchemaItemUfb* ufb);

  // optional .Proto.SchemaItemTerminator terminator = 135;
  inline bool has_terminator() const;
  inline void clear_terminator();
  static const int kTerminatorFieldNumber = 135;
  inline const ::Proto::SchemaItemTerminator& terminator() const;
  inline ::Proto::SchemaItemTerminator* mutable_terminator();
  inline ::Proto::SchemaItemTerminator* release_terminator();
  inline void set_allocated_terminator(::Proto::SchemaItemTerminator* terminator);

  // optional .Proto.SchemaItemValue Value = 136;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 136;
  inline const ::Proto::SchemaItemValue& value() const;
  inline ::Proto::SchemaItemValue* mutable_value();
  inline ::Proto::SchemaItemValue* release_value();
  inline void set_allocated_value(::Proto::SchemaItemValue* value);

  // optional .Proto.SchemaItemBus BusItem = 150;
  inline bool has_busitem() const;
  inline void clear_busitem();
  static const int kBusItemFieldNumber = 150;
  inline const ::Proto::SchemaItemBus& busitem() const;
  inline ::Proto::SchemaItemBus* mutable_busitem();
  inline ::Proto::SchemaItemBus* release_busitem();
  inline void set_allocated_busitem(::Proto::SchemaItemBus* busitem);

  // optional .Proto.SchemaItemBusComposer BusComposer = 151;
  inline bool has_buscomposer() const;
  inline void clear_buscomposer();
  static const int kBusComposerFieldNumber = 151;
  inline const ::Proto::SchemaItemBusComposer& buscomposer() const;
  inline ::Proto::SchemaItemBusComposer* mutable_buscomposer();
  inline ::Proto::SchemaItemBusComposer* release_buscomposer();
  inline void set_allocated_buscomposer(::Proto::SchemaItemBusComposer* buscomposer);

  // optional .Proto.SchemaItemBusExtractor BusExtractor = 152;
  inline bool has_busextractor() const;
  inline void clear_busextractor();
  static const int kBusExtractorFieldNumber = 152;
  inline const ::Proto::SchemaItemBusExtractor& busextractor() const;
  inline ::Proto::SchemaItemBusExtractor* mutable_busextractor();
  inline ::Proto::SchemaItemBusExtractor* release_busextractor();
  inline void set_allocated_busextractor(::Proto::SchemaItemBusExtractor* busextractor);

  // optional .Proto.SchemaItemControl control = 200;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 200;
  inline const ::Proto::SchemaItemControl& control() const;
  inline ::Proto::SchemaItemControl* mutable_control();
  inline ::Proto::SchemaItemControl* release_control();
  inline void set_allocated_control(::Proto::SchemaItemControl* control);

  // optional .Proto.SchemaItemPushButton pushButton = 210;
  inline bool has_pushbutton() const;
  inline void clear_pushbutton();
  static const int kPushButtonFieldNumber = 210;
  inline const ::Proto::SchemaItemPushButton& pushbutton() const;
  inline ::Proto::SchemaItemPushButton* mutable_pushbutton();
  inline ::Proto::SchemaItemPushButton* release_pushbutton();
  inline void set_allocated_pushbutton(::Proto::SchemaItemPushButton* pushbutton);

  // optional .Proto.SchemaItemLineEdit lineEdit = 211;
  inline bool has_lineedit() const;
  inline void clear_lineedit();
  static const int kLineEditFieldNumber = 211;
  inline const ::Proto::SchemaItemLineEdit& lineedit() const;
  inline ::Proto::SchemaItemLineEdit* mutable_lineedit();
  inline ::Proto::SchemaItemLineEdit* release_lineedit();
  inline void set_allocated_lineedit(::Proto::SchemaItemLineEdit* lineedit);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItem)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_isstatic();
  inline void clear_has_isstatic();
  inline void set_has_islocked();
  inline void clear_has_islocked();
  inline void set_has_itemunit();
  inline void clear_has_itemunit();
  inline void set_has_acceptclick();
  inline void clear_has_acceptclick();
  inline void set_has_clickscript();
  inline void clear_has_clickscript();
  inline void set_has_iscommented();
  inline void clear_has_iscommented();
  inline void set_has_objectname();
  inline void clear_has_objectname();
  inline void set_has_predrawscript();
  inline void clear_has_predrawscript();
  inline void set_has_posrectimpl();
  inline void clear_has_posrectimpl();
  inline void set_has_poslineimpl();
  inline void clear_has_poslineimpl();
  inline void set_has_posconnectionimpl();
  inline void clear_has_posconnectionimpl();
  inline void set_has_fblitem();
  inline void clear_has_fblitem();
  inline void set_has_fblitemrect();
  inline void clear_has_fblitemrect();
  inline void set_has_fblitemline();
  inline void clear_has_fblitemline();
  inline void set_has_rect();
  inline void clear_has_rect();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_inputsignal();
  inline void clear_has_inputsignal();
  inline void set_has_outputsignal();
  inline void clear_has_outputsignal();
  inline void set_has_link();
  inline void clear_has_link();
  inline void set_has_afb();
  inline void clear_has_afb();
  inline void set_has_constitem();
  inline void clear_has_constitem();
  inline void set_has_connectionitem();
  inline void clear_has_connectionitem();
  inline void set_has_transmitteritem();
  inline void clear_has_transmitteritem();
  inline void set_has_receiveritem();
  inline void clear_has_receiveritem();
  inline void set_has_inoutsignal();
  inline void clear_has_inoutsignal();
  inline void set_has_ufb();
  inline void clear_has_ufb();
  inline void set_has_terminator();
  inline void clear_has_terminator();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_busitem();
  inline void clear_has_busitem();
  inline void set_has_buscomposer();
  inline void clear_has_buscomposer();
  inline void set_has_busextractor();
  inline void clear_has_busextractor();
  inline void set_has_control();
  inline void clear_has_control();
  inline void set_has_pushbutton();
  inline void clear_has_pushbutton();
  inline void set_has_lineedit();
  inline void clear_has_lineedit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  int itemunit_;
  bool isstatic_;
  bool islocked_;
  bool acceptclick_;
  bool iscommented_;
  ::std::string* clickscript_;
  ::std::string* objectname_;
  ::std::string* predrawscript_;
  ::Proto::PosRectImpl* posrectimpl_;
  ::Proto::PosLineImpl* poslineimpl_;
  ::Proto::PosConnectionImpl* posconnectionimpl_;
  ::Proto::FblItem* fblitem_;
  ::Proto::FblItemRect* fblitemrect_;
  ::Proto::FblItemLine* fblitemline_;
  ::Proto::SchemaItemRect* rect_;
  ::Proto::SchemaItemLine* line_;
  ::Proto::SchemaItemPath* path_;
  ::Proto::SchemaItemSignal* signal_;
  ::Proto::SchemaItemInput* inputsignal_;
  ::Proto::SchemaItemOutput* outputsignal_;
  ::Proto::SchemaItemLink* link_;
  ::Proto::SchemaItemAfb* afb_;
  ::Proto::SchemaItemConst* constitem_;
  ::Proto::SchemaItemConnection* connectionitem_;
  ::Proto::SchemaItemTransmitter* transmitteritem_;
  ::Proto::SchemaItemReceiver* receiveritem_;
  ::Proto::SchemaItemInOut* inoutsignal_;
  ::Proto::SchemaItemUfb* ufb_;
  ::Proto::SchemaItemTerminator* terminator_;
  ::Proto::SchemaItemValue* value_;
  ::Proto::SchemaItemBus* busitem_;
  ::Proto::SchemaItemBusComposer* buscomposer_;
  ::Proto::SchemaItemBusExtractor* busextractor_;
  ::Proto::SchemaItemControl* control_;
  ::Proto::SchemaItemPushButton* pushbutton_;
  ::Proto::SchemaItemLineEdit* lineedit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItem* default_instance_;
};
// -------------------------------------------------------------------

class PosRectImpl : public ::google::protobuf::Message {
 public:
  PosRectImpl();
  virtual ~PosRectImpl();

  PosRectImpl(const PosRectImpl& from);

  inline PosRectImpl& operator=(const PosRectImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosRectImpl& default_instance();

  void Swap(PosRectImpl* other);

  // implements Message ----------------------------------------------

  PosRectImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosRectImpl& from);
  void MergeFrom(const PosRectImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double leftDocPt = 1;
  inline bool has_leftdocpt() const;
  inline void clear_leftdocpt();
  static const int kLeftDocPtFieldNumber = 1;
  inline double leftdocpt() const;
  inline void set_leftdocpt(double value);

  // required double topDocPt = 2;
  inline bool has_topdocpt() const;
  inline void clear_topdocpt();
  static const int kTopDocPtFieldNumber = 2;
  inline double topdocpt() const;
  inline void set_topdocpt(double value);

  // required double widthDocPt = 3;
  inline bool has_widthdocpt() const;
  inline void clear_widthdocpt();
  static const int kWidthDocPtFieldNumber = 3;
  inline double widthdocpt() const;
  inline void set_widthdocpt(double value);

  // required double heightDocPt = 4;
  inline bool has_heightdocpt() const;
  inline void clear_heightdocpt();
  static const int kHeightDocPtFieldNumber = 4;
  inline double heightdocpt() const;
  inline void set_heightdocpt(double value);

  // @@protoc_insertion_point(class_scope:Proto.PosRectImpl)
 private:
  inline void set_has_leftdocpt();
  inline void clear_has_leftdocpt();
  inline void set_has_topdocpt();
  inline void clear_has_topdocpt();
  inline void set_has_widthdocpt();
  inline void clear_has_widthdocpt();
  inline void set_has_heightdocpt();
  inline void clear_has_heightdocpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double leftdocpt_;
  double topdocpt_;
  double widthdocpt_;
  double heightdocpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosRectImpl* default_instance_;
};
// -------------------------------------------------------------------

class PosLineImpl : public ::google::protobuf::Message {
 public:
  PosLineImpl();
  virtual ~PosLineImpl();

  PosLineImpl(const PosLineImpl& from);

  inline PosLineImpl& operator=(const PosLineImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosLineImpl& default_instance();

  void Swap(PosLineImpl* other);

  // implements Message ----------------------------------------------

  PosLineImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosLineImpl& from);
  void MergeFrom(const PosLineImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double startXDocPt = 1;
  inline bool has_startxdocpt() const;
  inline void clear_startxdocpt();
  static const int kStartXDocPtFieldNumber = 1;
  inline double startxdocpt() const;
  inline void set_startxdocpt(double value);

  // required double startYDocPt = 2;
  inline bool has_startydocpt() const;
  inline void clear_startydocpt();
  static const int kStartYDocPtFieldNumber = 2;
  inline double startydocpt() const;
  inline void set_startydocpt(double value);

  // required double endXDocPt = 3;
  inline bool has_endxdocpt() const;
  inline void clear_endxdocpt();
  static const int kEndXDocPtFieldNumber = 3;
  inline double endxdocpt() const;
  inline void set_endxdocpt(double value);

  // required double endYDocPt = 4;
  inline bool has_endydocpt() const;
  inline void clear_endydocpt();
  static const int kEndYDocPtFieldNumber = 4;
  inline double endydocpt() const;
  inline void set_endydocpt(double value);

  // @@protoc_insertion_point(class_scope:Proto.PosLineImpl)
 private:
  inline void set_has_startxdocpt();
  inline void clear_has_startxdocpt();
  inline void set_has_startydocpt();
  inline void clear_has_startydocpt();
  inline void set_has_endxdocpt();
  inline void clear_has_endxdocpt();
  inline void set_has_endydocpt();
  inline void clear_has_endydocpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double startxdocpt_;
  double startydocpt_;
  double endxdocpt_;
  double endydocpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosLineImpl* default_instance_;
};
// -------------------------------------------------------------------

class PosConnectionImpl : public ::google::protobuf::Message {
 public:
  PosConnectionImpl();
  virtual ~PosConnectionImpl();

  PosConnectionImpl(const PosConnectionImpl& from);

  inline PosConnectionImpl& operator=(const PosConnectionImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosConnectionImpl& default_instance();

  void Swap(PosConnectionImpl* other);

  // implements Message ----------------------------------------------

  PosConnectionImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosConnectionImpl& from);
  void MergeFrom(const PosConnectionImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.SchemaPoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::Proto::SchemaPoint& points(int index) const;
  inline ::Proto::SchemaPoint* mutable_points(int index);
  inline ::Proto::SchemaPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Proto.PosConnectionImpl)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosConnectionImpl* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemRect : public ::google::protobuf::Message {
 public:
  SchemaItemRect();
  virtual ~SchemaItemRect();

  SchemaItemRect(const SchemaItemRect& from);

  inline SchemaItemRect& operator=(const SchemaItemRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemRect& default_instance();

  void Swap(SchemaItemRect* other);

  // implements Message ----------------------------------------------

  SchemaItemRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemRect& from);
  void MergeFrom(const SchemaItemRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // required uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // required .Proto.wstring text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::Proto::wstring& text() const;
  inline ::Proto::wstring* mutable_text();
  inline ::Proto::wstring* release_text();
  inline void set_allocated_text(::Proto::wstring* text);

  // required uint32 textColor = 5;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 5;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // required .Proto.FontParam font = 6;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 6;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // required bool fill = 7;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 7;
  inline bool fill() const;
  inline void set_fill(bool value);

  // optional bool drawrect = 8 [default = true];
  inline bool has_drawrect() const;
  inline void clear_drawrect();
  static const int kDrawrectFieldNumber = 8;
  inline bool drawrect() const;
  inline void set_drawrect(bool value);

  // optional int32 horzAlign = 9 [default = 4];
  inline bool has_horzalign() const;
  inline void clear_horzalign();
  static const int kHorzAlignFieldNumber = 9;
  inline ::google::protobuf::int32 horzalign() const;
  inline void set_horzalign(::google::protobuf::int32 value);

  // optional int32 vertAlign = 10 [default = 128];
  inline bool has_vertalign() const;
  inline void clear_vertalign();
  static const int kVertAlignFieldNumber = 10;
  inline ::google::protobuf::int32 vertalign() const;
  inline void set_vertalign(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemRect)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_drawrect();
  inline void clear_has_drawrect();
  inline void set_has_horzalign();
  inline void clear_has_horzalign();
  inline void set_has_vertalign();
  inline void clear_has_vertalign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::Proto::wstring* text_;
  ::Proto::FontParam* font_;
  ::google::protobuf::uint32 textcolor_;
  bool fill_;
  bool drawrect_;
  ::google::protobuf::int32 horzalign_;
  ::google::protobuf::int32 vertalign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemRect* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemLine : public ::google::protobuf::Message {
 public:
  SchemaItemLine();
  virtual ~SchemaItemLine();

  SchemaItemLine(const SchemaItemLine& from);

  inline SchemaItemLine& operator=(const SchemaItemLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemLine& default_instance();

  void Swap(SchemaItemLine* other);

  // implements Message ----------------------------------------------

  SchemaItemLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemLine& from);
  void MergeFrom(const SchemaItemLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemLine)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemLine* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemPath : public ::google::protobuf::Message {
 public:
  SchemaItemPath();
  virtual ~SchemaItemPath();

  SchemaItemPath(const SchemaItemPath& from);

  inline SchemaItemPath& operator=(const SchemaItemPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemPath& default_instance();

  void Swap(SchemaItemPath* other);

  // implements Message ----------------------------------------------

  SchemaItemPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemPath& from);
  void MergeFrom(const SchemaItemPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemPath)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemPath* default_instance_;
};
// -------------------------------------------------------------------

class FblConnectionPoint : public ::google::protobuf::Message {
 public:
  FblConnectionPoint();
  virtual ~FblConnectionPoint();

  FblConnectionPoint(const FblConnectionPoint& from);

  inline FblConnectionPoint& operator=(const FblConnectionPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblConnectionPoint& default_instance();

  void Swap(FblConnectionPoint* other);

  // implements Message ----------------------------------------------

  FblConnectionPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblConnectionPoint& from);
  void MergeFrom(const FblConnectionPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.SchemaPoint point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::Proto::SchemaPoint& point() const;
  inline ::Proto::SchemaPoint* mutable_point();
  inline ::Proto::SchemaPoint* release_point();
  inline void set_allocated_point(::Proto::SchemaPoint* point);

  // optional .Proto.ConnectionDirrection dirrection = 2;
  inline bool has_dirrection() const;
  inline void clear_dirrection();
  static const int kDirrectionFieldNumber = 2;
  inline ::Proto::ConnectionDirrection dirrection() const;
  inline void set_dirrection(::Proto::ConnectionDirrection value);

  // optional .Proto.Uuid uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // optional int32 operandIndex = 4 [default = -1];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 4;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional string caption = 5 [default = ""];
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 5;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // repeated .Proto.Uuid associatedIos = 6;
  inline int associatedios_size() const;
  inline void clear_associatedios();
  static const int kAssociatedIosFieldNumber = 6;
  inline const ::Proto::Uuid& associatedios(int index) const;
  inline ::Proto::Uuid* mutable_associatedios(int index);
  inline ::Proto::Uuid* add_associatedios();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
      associatedios() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
      mutable_associatedios();

  // @@protoc_insertion_point(class_scope:Proto.FblConnectionPoint)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_dirrection();
  inline void clear_has_dirrection();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_caption();
  inline void clear_has_caption();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::SchemaPoint* point_;
  ::Proto::Uuid* uuid_;
  int dirrection_;
  ::google::protobuf::int32 operandindex_;
  ::std::string* caption_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Uuid > associatedios_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblConnectionPoint* default_instance_;
};
// -------------------------------------------------------------------

class FblItem : public ::google::protobuf::Message {
 public:
  FblItem();
  virtual ~FblItem();

  FblItem(const FblItem& from);

  inline FblItem& operator=(const FblItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItem& default_instance();

  void Swap(FblItem* other);

  // implements Message ----------------------------------------------

  FblItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItem& from);
  void MergeFrom(const FblItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.FblConnectionPoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::Proto::FblConnectionPoint& points(int index) const;
  inline ::Proto::FblConnectionPoint* mutable_points(int index);
  inline ::Proto::FblConnectionPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Proto.FblItem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItem* default_instance_;
};
// -------------------------------------------------------------------

class FblItemRect : public ::google::protobuf::Message {
 public:
  FblItemRect();
  virtual ~FblItemRect();

  FblItemRect(const FblItemRect& from);

  inline FblItemRect& operator=(const FblItemRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItemRect& default_instance();

  void Swap(FblItemRect* other);

  // implements Message ----------------------------------------------

  FblItemRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItemRect& from);
  void MergeFrom(const FblItemRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // required uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // required uint32 textColor = 4;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 4;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // required .Proto.FontParam font = 5;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 5;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // optional string label = 6;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 6;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional string userText = 7;
  inline bool has_usertext() const;
  inline void clear_usertext();
  static const int kUserTextFieldNumber = 7;
  inline const ::std::string& usertext() const;
  inline void set_usertext(const ::std::string& value);
  inline void set_usertext(const char* value);
  inline void set_usertext(const char* value, size_t size);
  inline ::std::string* mutable_usertext();
  inline ::std::string* release_usertext();
  inline void set_allocated_usertext(::std::string* usertext);

  // optional int32 userTextPos = 8 [default = 1];
  inline bool has_usertextpos() const;
  inline void clear_usertextpos();
  static const int kUserTextPosFieldNumber = 8;
  inline ::google::protobuf::int32 usertextpos() const;
  inline void set_usertextpos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.FblItemRect)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_usertext();
  inline void clear_has_usertext();
  inline void set_has_usertextpos();
  inline void clear_has_usertextpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::Proto::FontParam* font_;
  ::std::string* label_;
  ::google::protobuf::uint32 textcolor_;
  ::google::protobuf::int32 usertextpos_;
  ::std::string* usertext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItemRect* default_instance_;
};
// -------------------------------------------------------------------

class FblItemLine : public ::google::protobuf::Message {
 public:
  FblItemLine();
  virtual ~FblItemLine();

  FblItemLine(const FblItemLine& from);

  inline FblItemLine& operator=(const FblItemLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItemLine& default_instance();

  void Swap(FblItemLine* other);

  // implements Message ----------------------------------------------

  FblItemLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItemLine& from);
  void MergeFrom(const FblItemLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.FblItemLine)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItemLine* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemSignalColumn : public ::google::protobuf::Message {
 public:
  SchemaItemSignalColumn();
  virtual ~SchemaItemSignalColumn();

  SchemaItemSignalColumn(const SchemaItemSignalColumn& from);

  inline SchemaItemSignalColumn& operator=(const SchemaItemSignalColumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemSignalColumn& default_instance();

  void Swap(SchemaItemSignalColumn* other);

  // implements Message ----------------------------------------------

  SchemaItemSignalColumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemSignalColumn& from);
  void MergeFrom(const SchemaItemSignalColumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double width = 1 [default = 20];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline double width() const;
  inline void set_width(double value);

  // optional int32 data = 2 [default = 0];
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);

  // optional int32 horzAlign = 3 [default = 1];
  inline bool has_horzalign() const;
  inline void clear_horzalign();
  static const int kHorzAlignFieldNumber = 3;
  inline ::google::protobuf::int32 horzalign() const;
  inline void set_horzalign(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemSignalColumn)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_horzalign();
  inline void clear_has_horzalign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double width_;
  ::google::protobuf::int32 data_;
  ::google::protobuf::int32 horzalign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemSignalColumn* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemSignal : public ::google::protobuf::Message {
 public:
  SchemaItemSignal();
  virtual ~SchemaItemSignal();

  SchemaItemSignal(const SchemaItemSignal& from);

  inline SchemaItemSignal& operator=(const SchemaItemSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemSignal& default_instance();

  void Swap(SchemaItemSignal* other);

  // implements Message ----------------------------------------------

  SchemaItemSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemSignal& from);
  void MergeFrom(const SchemaItemSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.wstring appSignalIDs = 1;
  inline int appsignalids_size() const;
  inline void clear_appsignalids();
  static const int kAppSignalIDsFieldNumber = 1;
  inline const ::Proto::wstring& appsignalids(int index) const;
  inline ::Proto::wstring* mutable_appsignalids(int index);
  inline ::Proto::wstring* add_appsignalids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
      appsignalids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
      mutable_appsignalids();

  // optional int32 precision = 2 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional int32 analogFormat = 3 [default = 102];
  inline bool has_analogformat() const;
  inline void clear_analogformat();
  static const int kAnalogFormatFieldNumber = 3;
  inline ::google::protobuf::int32 analogformat() const;
  inline void set_analogformat(::google::protobuf::int32 value);

  // repeated .Proto.SchemaItemSignalColumn columns = 4;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 4;
  inline const ::Proto::SchemaItemSignalColumn& columns(int index) const;
  inline ::Proto::SchemaItemSignalColumn* mutable_columns(int index);
  inline ::Proto::SchemaItemSignalColumn* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaItemSignalColumn >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaItemSignalColumn >*
      mutable_columns();

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemSignal)
 private:
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_analogformat();
  inline void clear_has_analogformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::wstring > appsignalids_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 analogformat_;
  ::google::protobuf::RepeatedPtrField< ::Proto::SchemaItemSignalColumn > columns_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemSignal* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemInput : public ::google::protobuf::Message {
 public:
  SchemaItemInput();
  virtual ~SchemaItemInput();

  SchemaItemInput(const SchemaItemInput& from);

  inline SchemaItemInput& operator=(const SchemaItemInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemInput& default_instance();

  void Swap(SchemaItemInput* other);

  // implements Message ----------------------------------------------

  SchemaItemInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemInput& from);
  void MergeFrom(const SchemaItemInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemInput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemInput* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemOutput : public ::google::protobuf::Message {
 public:
  SchemaItemOutput();
  virtual ~SchemaItemOutput();

  SchemaItemOutput(const SchemaItemOutput& from);

  inline SchemaItemOutput& operator=(const SchemaItemOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemOutput& default_instance();

  void Swap(SchemaItemOutput* other);

  // implements Message ----------------------------------------------

  SchemaItemOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemOutput& from);
  void MergeFrom(const SchemaItemOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemOutput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemOutput* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemInOut : public ::google::protobuf::Message {
 public:
  SchemaItemInOut();
  virtual ~SchemaItemInOut();

  SchemaItemInOut(const SchemaItemInOut& from);

  inline SchemaItemInOut& operator=(const SchemaItemInOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemInOut& default_instance();

  void Swap(SchemaItemInOut* other);

  // implements Message ----------------------------------------------

  SchemaItemInOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemInOut& from);
  void MergeFrom(const SchemaItemInOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemInOut)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemInOut* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemLink : public ::google::protobuf::Message {
 public:
  SchemaItemLink();
  virtual ~SchemaItemLink();

  SchemaItemLink(const SchemaItemLink& from);

  inline SchemaItemLink& operator=(const SchemaItemLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemLink& default_instance();

  void Swap(SchemaItemLink* other);

  // implements Message ----------------------------------------------

  SchemaItemLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemLink& from);
  void MergeFrom(const SchemaItemLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemLink)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemLink* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemAfb : public ::google::protobuf::Message {
 public:
  SchemaItemAfb();
  virtual ~SchemaItemAfb();

  SchemaItemAfb(const SchemaItemAfb& from);

  inline SchemaItemAfb& operator=(const SchemaItemAfb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemAfb& default_instance();

  void Swap(SchemaItemAfb* other);

  // implements Message ----------------------------------------------

  SchemaItemAfb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemAfb& from);
  void MergeFrom(const SchemaItemAfb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.AfbParam params = 2;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::Proto::AfbParam& params(int index) const;
  inline ::Proto::AfbParam* mutable_params(int index);
  inline ::Proto::AfbParam* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
      mutable_params();

  // optional .Proto.wstring afbStrid = 3;
  inline bool has_afbstrid() const;
  inline void clear_afbstrid();
  static const int kAfbStridFieldNumber = 3;
  inline const ::Proto::wstring& afbstrid() const;
  inline ::Proto::wstring* mutable_afbstrid();
  inline ::Proto::wstring* release_afbstrid();
  inline void set_allocated_afbstrid(::Proto::wstring* afbstrid);

  // optional int32 precision = 4 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional .Proto.AfbElementXml deprecated_afbelement = 5;
  inline bool has_deprecated_afbelement() const;
  inline void clear_deprecated_afbelement();
  static const int kDeprecatedAfbelementFieldNumber = 5;
  inline const ::Proto::AfbElementXml& deprecated_afbelement() const;
  inline ::Proto::AfbElementXml* mutable_deprecated_afbelement();
  inline ::Proto::AfbElementXml* release_deprecated_afbelement();
  inline void set_allocated_deprecated_afbelement(::Proto::AfbElementXml* deprecated_afbelement);

  // optional string deprecated_label = 6;
  inline bool has_deprecated_label() const;
  inline void clear_deprecated_label();
  static const int kDeprecatedLabelFieldNumber = 6;
  inline const ::std::string& deprecated_label() const;
  inline void set_deprecated_label(const ::std::string& value);
  inline void set_deprecated_label(const char* value);
  inline void set_deprecated_label(const char* value, size_t size);
  inline ::std::string* mutable_deprecated_label();
  inline ::std::string* release_deprecated_label();
  inline void set_allocated_deprecated_label(::std::string* deprecated_label);

  // optional .Proto.AfbElementXml afbelement = 7;
  inline bool has_afbelement() const;
  inline void clear_afbelement();
  static const int kAfbelementFieldNumber = 7;
  inline const ::Proto::AfbElementXml& afbelement() const;
  inline ::Proto::AfbElementXml* mutable_afbelement();
  inline ::Proto::AfbElementXml* release_afbelement();
  inline void set_allocated_afbelement(::Proto::AfbElementXml* afbelement);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemAfb)
 private:
  inline void set_has_afbstrid();
  inline void clear_has_afbstrid();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_deprecated_afbelement();
  inline void clear_has_deprecated_afbelement();
  inline void set_has_deprecated_label();
  inline void clear_has_deprecated_label();
  inline void set_has_afbelement();
  inline void clear_has_afbelement();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam > params_;
  ::Proto::wstring* afbstrid_;
  ::Proto::AfbElementXml* deprecated_afbelement_;
  ::std::string* deprecated_label_;
  ::Proto::AfbElementXml* afbelement_;
  ::google::protobuf::int32 precision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemAfb* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemConst : public ::google::protobuf::Message {
 public:
  SchemaItemConst();
  virtual ~SchemaItemConst();

  SchemaItemConst(const SchemaItemConst& from);

  inline SchemaItemConst& operator=(const SchemaItemConst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemConst& default_instance();

  void Swap(SchemaItemConst* other);

  // implements Message ----------------------------------------------

  SchemaItemConst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemConst& from);
  void MergeFrom(const SchemaItemConst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 intValue = 2 [default = 0];
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional double floatValue = 3 [default = 0];
  inline bool has_floatvalue() const;
  inline void clear_floatvalue();
  static const int kFloatValueFieldNumber = 3;
  inline double floatvalue() const;
  inline void set_floatvalue(double value);

  // optional int32 precision = 4 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional int32 horzAlign = 5 [default = 4];
  inline bool has_horzalign() const;
  inline void clear_horzalign();
  static const int kHorzAlignFieldNumber = 5;
  inline ::google::protobuf::int32 horzalign() const;
  inline void set_horzalign(::google::protobuf::int32 value);

  // optional int32 vertAlign = 6 [default = 128];
  inline bool has_vertalign() const;
  inline void clear_vertalign();
  static const int kVertAlignFieldNumber = 6;
  inline ::google::protobuf::int32 vertalign() const;
  inline void set_vertalign(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemConst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_floatvalue();
  inline void clear_has_floatvalue();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_horzalign();
  inline void clear_has_horzalign();
  inline void set_has_vertalign();
  inline void clear_has_vertalign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 intvalue_;
  double floatvalue_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 horzalign_;
  ::google::protobuf::int32 vertalign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemConst* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemConnection : public ::google::protobuf::Message {
 public:
  SchemaItemConnection();
  virtual ~SchemaItemConnection();

  SchemaItemConnection(const SchemaItemConnection& from);

  inline SchemaItemConnection& operator=(const SchemaItemConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemConnection& default_instance();

  void Swap(SchemaItemConnection* other);

  // implements Message ----------------------------------------------

  SchemaItemConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemConnection& from);
  void MergeFrom(const SchemaItemConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string connectionid = 1;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionidFieldNumber = 1;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemConnection)
 private:
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* connectionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemConnection* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemTransmitter : public ::google::protobuf::Message {
 public:
  SchemaItemTransmitter();
  virtual ~SchemaItemTransmitter();

  SchemaItemTransmitter(const SchemaItemTransmitter& from);

  inline SchemaItemTransmitter& operator=(const SchemaItemTransmitter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemTransmitter& default_instance();

  void Swap(SchemaItemTransmitter* other);

  // implements Message ----------------------------------------------

  SchemaItemTransmitter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemTransmitter& from);
  void MergeFrom(const SchemaItemTransmitter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pinCount = 1 [default = 1];
  inline bool has_pincount() const;
  inline void clear_pincount();
  static const int kPinCountFieldNumber = 1;
  inline ::google::protobuf::int32 pincount() const;
  inline void set_pincount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemTransmitter)
 private:
  inline void set_has_pincount();
  inline void clear_has_pincount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pincount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemTransmitter* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemReceiver : public ::google::protobuf::Message {
 public:
  SchemaItemReceiver();
  virtual ~SchemaItemReceiver();

  SchemaItemReceiver(const SchemaItemReceiver& from);

  inline SchemaItemReceiver& operator=(const SchemaItemReceiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemReceiver& default_instance();

  void Swap(SchemaItemReceiver* other);

  // implements Message ----------------------------------------------

  SchemaItemReceiver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemReceiver& from);
  void MergeFrom(const SchemaItemReceiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool showValidity = 1 [default = true];
  inline bool has_showvalidity() const;
  inline void clear_showvalidity();
  static const int kShowValidityFieldNumber = 1;
  inline bool showvalidity() const;
  inline void set_showvalidity(bool value);

  // optional string appSignalId = 2;
  inline bool has_appsignalid() const;
  inline void clear_appsignalid();
  static const int kAppSignalIdFieldNumber = 2;
  inline const ::std::string& appsignalid() const;
  inline void set_appsignalid(const ::std::string& value);
  inline void set_appsignalid(const char* value);
  inline void set_appsignalid(const char* value, size_t size);
  inline ::std::string* mutable_appsignalid();
  inline ::std::string* release_appsignalid();
  inline void set_allocated_appsignalid(::std::string* appsignalid);

  // optional int32 dataType = 3 [default = 0];
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDataTypeFieldNumber = 3;
  inline ::google::protobuf::int32 datatype() const;
  inline void set_datatype(::google::protobuf::int32 value);

  // optional int32 precision = 4 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional int32 analogFormat = 5 [default = 102];
  inline bool has_analogformat() const;
  inline void clear_analogformat();
  static const int kAnalogFormatFieldNumber = 5;
  inline ::google::protobuf::int32 analogformat() const;
  inline void set_analogformat(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemReceiver)
 private:
  inline void set_has_showvalidity();
  inline void clear_has_showvalidity();
  inline void set_has_appsignalid();
  inline void clear_has_appsignalid();
  inline void set_has_datatype();
  inline void clear_has_datatype();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_analogformat();
  inline void clear_has_analogformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* appsignalid_;
  bool showvalidity_;
  ::google::protobuf::int32 datatype_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 analogformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemReceiver* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemUfb : public ::google::protobuf::Message {
 public:
  SchemaItemUfb();
  virtual ~SchemaItemUfb();

  SchemaItemUfb(const SchemaItemUfb& from);

  inline SchemaItemUfb& operator=(const SchemaItemUfb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemUfb& default_instance();

  void Swap(SchemaItemUfb* other);

  // implements Message ----------------------------------------------

  SchemaItemUfb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemUfb& from);
  void MergeFrom(const SchemaItemUfb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ufbSchemaId = 1;
  inline bool has_ufbschemaid() const;
  inline void clear_ufbschemaid();
  static const int kUfbSchemaIdFieldNumber = 1;
  inline const ::std::string& ufbschemaid() const;
  inline void set_ufbschemaid(const ::std::string& value);
  inline void set_ufbschemaid(const char* value);
  inline void set_ufbschemaid(const char* value, size_t size);
  inline ::std::string* mutable_ufbschemaid();
  inline ::std::string* release_ufbschemaid();
  inline void set_allocated_ufbschemaid(::std::string* ufbschemaid);

  // optional string ufbCaption = 2;
  inline bool has_ufbcaption() const;
  inline void clear_ufbcaption();
  static const int kUfbCaptionFieldNumber = 2;
  inline const ::std::string& ufbcaption() const;
  inline void set_ufbcaption(const ::std::string& value);
  inline void set_ufbcaption(const char* value);
  inline void set_ufbcaption(const char* value, size_t size);
  inline ::std::string* mutable_ufbcaption();
  inline ::std::string* release_ufbcaption();
  inline void set_allocated_ufbcaption(::std::string* ufbcaption);

  // optional int32 ufbVersion = 3 [default = -1];
  inline bool has_ufbversion() const;
  inline void clear_ufbversion();
  static const int kUfbVersionFieldNumber = 3;
  inline ::google::protobuf::int32 ufbversion() const;
  inline void set_ufbversion(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemUfb)
 private:
  inline void set_has_ufbschemaid();
  inline void clear_has_ufbschemaid();
  inline void set_has_ufbcaption();
  inline void clear_has_ufbcaption();
  inline void set_has_ufbversion();
  inline void clear_has_ufbversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ufbschemaid_;
  ::std::string* ufbcaption_;
  ::google::protobuf::int32 ufbversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemUfb* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemTerminator : public ::google::protobuf::Message {
 public:
  SchemaItemTerminator();
  virtual ~SchemaItemTerminator();

  SchemaItemTerminator(const SchemaItemTerminator& from);

  inline SchemaItemTerminator& operator=(const SchemaItemTerminator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemTerminator& default_instance();

  void Swap(SchemaItemTerminator* other);

  // implements Message ----------------------------------------------

  SchemaItemTerminator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemTerminator& from);
  void MergeFrom(const SchemaItemTerminator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemTerminator)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemTerminator* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemValue : public ::google::protobuf::Message {
 public:
  SchemaItemValue();
  virtual ~SchemaItemValue();

  SchemaItemValue(const SchemaItemValue& from);

  inline SchemaItemValue& operator=(const SchemaItemValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemValue& default_instance();

  void Swap(SchemaItemValue* other);

  // implements Message ----------------------------------------------

  SchemaItemValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemValue& from);
  void MergeFrom(const SchemaItemValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // optional uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // optional uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // optional string textAnalog = 4;
  inline bool has_textanalog() const;
  inline void clear_textanalog();
  static const int kTextAnalogFieldNumber = 4;
  inline const ::std::string& textanalog() const;
  inline void set_textanalog(const ::std::string& value);
  inline void set_textanalog(const char* value);
  inline void set_textanalog(const char* value, size_t size);
  inline ::std::string* mutable_textanalog();
  inline ::std::string* release_textanalog();
  inline void set_allocated_textanalog(::std::string* textanalog);

  // optional uint32 textColor = 5;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 5;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // optional .Proto.FontParam font = 6;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 6;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // optional bool fill = 7;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 7;
  inline bool fill() const;
  inline void set_fill(bool value);

  // optional bool drawrect = 8 [default = true];
  inline bool has_drawrect() const;
  inline void clear_drawrect();
  static const int kDrawrectFieldNumber = 8;
  inline bool drawrect() const;
  inline void set_drawrect(bool value);

  // optional int32 horzAlign = 9 [default = 4];
  inline bool has_horzalign() const;
  inline void clear_horzalign();
  static const int kHorzAlignFieldNumber = 9;
  inline ::google::protobuf::int32 horzalign() const;
  inline void set_horzalign(::google::protobuf::int32 value);

  // optional int32 vertAlign = 10 [default = 128];
  inline bool has_vertalign() const;
  inline void clear_vertalign();
  static const int kVertAlignFieldNumber = 10;
  inline ::google::protobuf::int32 vertalign() const;
  inline void set_vertalign(::google::protobuf::int32 value);

  // optional string signalId = 11;
  inline bool has_signalid() const;
  inline void clear_signalid();
  static const int kSignalIdFieldNumber = 11;
  inline const ::std::string& signalid() const;
  inline void set_signalid(const ::std::string& value);
  inline void set_signalid(const char* value);
  inline void set_signalid(const char* value, size_t size);
  inline ::std::string* mutable_signalid();
  inline ::std::string* release_signalid();
  inline void set_allocated_signalid(::std::string* signalid);

  // optional int32 signalSource = 12 [default = 0];
  inline bool has_signalsource() const;
  inline void clear_signalsource();
  static const int kSignalSourceFieldNumber = 12;
  inline ::google::protobuf::int32 signalsource() const;
  inline void set_signalsource(::google::protobuf::int32 value);

  // optional int32 precision = 13 [default = -1];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 13;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional string textDiscrete0 = 14;
  inline bool has_textdiscrete0() const;
  inline void clear_textdiscrete0();
  static const int kTextDiscrete0FieldNumber = 14;
  inline const ::std::string& textdiscrete0() const;
  inline void set_textdiscrete0(const ::std::string& value);
  inline void set_textdiscrete0(const char* value);
  inline void set_textdiscrete0(const char* value, size_t size);
  inline ::std::string* mutable_textdiscrete0();
  inline ::std::string* release_textdiscrete0();
  inline void set_allocated_textdiscrete0(::std::string* textdiscrete0);

  // optional string textDiscrete1 = 15;
  inline bool has_textdiscrete1() const;
  inline void clear_textdiscrete1();
  static const int kTextDiscrete1FieldNumber = 15;
  inline const ::std::string& textdiscrete1() const;
  inline void set_textdiscrete1(const ::std::string& value);
  inline void set_textdiscrete1(const char* value);
  inline void set_textdiscrete1(const char* value, size_t size);
  inline ::std::string* mutable_textdiscrete1();
  inline ::std::string* release_textdiscrete1();
  inline void set_allocated_textdiscrete1(::std::string* textdiscrete1);

  // optional string textNonValid = 16;
  inline bool has_textnonvalid() const;
  inline void clear_textnonvalid();
  static const int kTextNonValidFieldNumber = 16;
  inline const ::std::string& textnonvalid() const;
  inline void set_textnonvalid(const ::std::string& value);
  inline void set_textnonvalid(const char* value);
  inline void set_textnonvalid(const char* value, size_t size);
  inline ::std::string* mutable_textnonvalid();
  inline ::std::string* release_textnonvalid();
  inline void set_allocated_textnonvalid(::std::string* textnonvalid);

  // optional uint32 fillColorNonValid0 = 30;
  inline bool has_fillcolornonvalid0() const;
  inline void clear_fillcolornonvalid0();
  static const int kFillColorNonValid0FieldNumber = 30;
  inline ::google::protobuf::uint32 fillcolornonvalid0() const;
  inline void set_fillcolornonvalid0(::google::protobuf::uint32 value);

  // optional uint32 fillColorNonValid1 = 31;
  inline bool has_fillcolornonvalid1() const;
  inline void clear_fillcolornonvalid1();
  static const int kFillColorNonValid1FieldNumber = 31;
  inline ::google::protobuf::uint32 fillcolornonvalid1() const;
  inline void set_fillcolornonvalid1(::google::protobuf::uint32 value);

  // optional uint32 textColorNonValid0 = 32;
  inline bool has_textcolornonvalid0() const;
  inline void clear_textcolornonvalid0();
  static const int kTextColorNonValid0FieldNumber = 32;
  inline ::google::protobuf::uint32 textcolornonvalid0() const;
  inline void set_textcolornonvalid0(::google::protobuf::uint32 value);

  // optional uint32 textColorNonValid1 = 33;
  inline bool has_textcolornonvalid1() const;
  inline void clear_textcolornonvalid1();
  static const int kTextColorNonValid1FieldNumber = 33;
  inline ::google::protobuf::uint32 textcolornonvalid1() const;
  inline void set_textcolornonvalid1(::google::protobuf::uint32 value);

  // optional uint32 fillColorAnalog0 = 42;
  inline bool has_fillcoloranalog0() const;
  inline void clear_fillcoloranalog0();
  static const int kFillColorAnalog0FieldNumber = 42;
  inline ::google::protobuf::uint32 fillcoloranalog0() const;
  inline void set_fillcoloranalog0(::google::protobuf::uint32 value);

  // optional uint32 fillColorAnalog1 = 43;
  inline bool has_fillcoloranalog1() const;
  inline void clear_fillcoloranalog1();
  static const int kFillColorAnalog1FieldNumber = 43;
  inline ::google::protobuf::uint32 fillcoloranalog1() const;
  inline void set_fillcoloranalog1(::google::protobuf::uint32 value);

  // optional uint32 textColorAnalog0 = 44;
  inline bool has_textcoloranalog0() const;
  inline void clear_textcoloranalog0();
  static const int kTextColorAnalog0FieldNumber = 44;
  inline ::google::protobuf::uint32 textcoloranalog0() const;
  inline void set_textcoloranalog0(::google::protobuf::uint32 value);

  // optional uint32 textColorAnalog1 = 45;
  inline bool has_textcoloranalog1() const;
  inline void clear_textcoloranalog1();
  static const int kTextColorAnalog1FieldNumber = 45;
  inline ::google::protobuf::uint32 textcoloranalog1() const;
  inline void set_textcoloranalog1(::google::protobuf::uint32 value);

  // optional uint32 fillColorDiscrYes0 = 46;
  inline bool has_fillcolordiscryes0() const;
  inline void clear_fillcolordiscryes0();
  static const int kFillColorDiscrYes0FieldNumber = 46;
  inline ::google::protobuf::uint32 fillcolordiscryes0() const;
  inline void set_fillcolordiscryes0(::google::protobuf::uint32 value);

  // optional uint32 fillColorDiscrYes1 = 47;
  inline bool has_fillcolordiscryes1() const;
  inline void clear_fillcolordiscryes1();
  static const int kFillColorDiscrYes1FieldNumber = 47;
  inline ::google::protobuf::uint32 fillcolordiscryes1() const;
  inline void set_fillcolordiscryes1(::google::protobuf::uint32 value);

  // optional uint32 textColorDiscrYes0 = 48;
  inline bool has_textcolordiscryes0() const;
  inline void clear_textcolordiscryes0();
  static const int kTextColorDiscrYes0FieldNumber = 48;
  inline ::google::protobuf::uint32 textcolordiscryes0() const;
  inline void set_textcolordiscryes0(::google::protobuf::uint32 value);

  // optional uint32 textColorDiscrYes1 = 49;
  inline bool has_textcolordiscryes1() const;
  inline void clear_textcolordiscryes1();
  static const int kTextColorDiscrYes1FieldNumber = 49;
  inline ::google::protobuf::uint32 textcolordiscryes1() const;
  inline void set_textcolordiscryes1(::google::protobuf::uint32 value);

  // optional uint32 fillColorDiscrNo0 = 50;
  inline bool has_fillcolordiscrno0() const;
  inline void clear_fillcolordiscrno0();
  static const int kFillColorDiscrNo0FieldNumber = 50;
  inline ::google::protobuf::uint32 fillcolordiscrno0() const;
  inline void set_fillcolordiscrno0(::google::protobuf::uint32 value);

  // optional uint32 fillColorDiscrNo1 = 51;
  inline bool has_fillcolordiscrno1() const;
  inline void clear_fillcolordiscrno1();
  static const int kFillColorDiscrNo1FieldNumber = 51;
  inline ::google::protobuf::uint32 fillcolordiscrno1() const;
  inline void set_fillcolordiscrno1(::google::protobuf::uint32 value);

  // optional uint32 textColorDiscrNo0 = 52;
  inline bool has_textcolordiscrno0() const;
  inline void clear_textcolordiscrno0();
  static const int kTextColorDiscrNo0FieldNumber = 52;
  inline ::google::protobuf::uint32 textcolordiscrno0() const;
  inline void set_textcolordiscrno0(::google::protobuf::uint32 value);

  // optional uint32 textColorDiscrNo1 = 53;
  inline bool has_textcolordiscrno1() const;
  inline void clear_textcolordiscrno1();
  static const int kTextColorDiscrNo1FieldNumber = 53;
  inline ::google::protobuf::uint32 textcolordiscrno1() const;
  inline void set_textcolordiscrno1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemValue)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_textanalog();
  inline void clear_has_textanalog();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_drawrect();
  inline void clear_has_drawrect();
  inline void set_has_horzalign();
  inline void clear_has_horzalign();
  inline void set_has_vertalign();
  inline void clear_has_vertalign();
  inline void set_has_signalid();
  inline void clear_has_signalid();
  inline void set_has_signalsource();
  inline void clear_has_signalsource();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_textdiscrete0();
  inline void clear_has_textdiscrete0();
  inline void set_has_textdiscrete1();
  inline void clear_has_textdiscrete1();
  inline void set_has_textnonvalid();
  inline void clear_has_textnonvalid();
  inline void set_has_fillcolornonvalid0();
  inline void clear_has_fillcolornonvalid0();
  inline void set_has_fillcolornonvalid1();
  inline void clear_has_fillcolornonvalid1();
  inline void set_has_textcolornonvalid0();
  inline void clear_has_textcolornonvalid0();
  inline void set_has_textcolornonvalid1();
  inline void clear_has_textcolornonvalid1();
  inline void set_has_fillcoloranalog0();
  inline void clear_has_fillcoloranalog0();
  inline void set_has_fillcoloranalog1();
  inline void clear_has_fillcoloranalog1();
  inline void set_has_textcoloranalog0();
  inline void clear_has_textcoloranalog0();
  inline void set_has_textcoloranalog1();
  inline void clear_has_textcoloranalog1();
  inline void set_has_fillcolordiscryes0();
  inline void clear_has_fillcolordiscryes0();
  inline void set_has_fillcolordiscryes1();
  inline void clear_has_fillcolordiscryes1();
  inline void set_has_textcolordiscryes0();
  inline void clear_has_textcolordiscryes0();
  inline void set_has_textcolordiscryes1();
  inline void clear_has_textcolordiscryes1();
  inline void set_has_fillcolordiscrno0();
  inline void clear_has_fillcolordiscrno0();
  inline void set_has_fillcolordiscrno1();
  inline void clear_has_fillcolordiscrno1();
  inline void set_has_textcolordiscrno0();
  inline void clear_has_textcolordiscrno0();
  inline void set_has_textcolordiscrno1();
  inline void clear_has_textcolordiscrno1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::std::string* textanalog_;
  ::Proto::FontParam* font_;
  ::google::protobuf::uint32 textcolor_;
  bool fill_;
  bool drawrect_;
  ::google::protobuf::int32 horzalign_;
  ::google::protobuf::int32 vertalign_;
  ::std::string* signalid_;
  ::google::protobuf::int32 signalsource_;
  ::google::protobuf::int32 precision_;
  ::std::string* textdiscrete0_;
  ::std::string* textdiscrete1_;
  ::std::string* textnonvalid_;
  ::google::protobuf::uint32 fillcolornonvalid0_;
  ::google::protobuf::uint32 fillcolornonvalid1_;
  ::google::protobuf::uint32 textcolornonvalid0_;
  ::google::protobuf::uint32 textcolornonvalid1_;
  ::google::protobuf::uint32 fillcoloranalog0_;
  ::google::protobuf::uint32 fillcoloranalog1_;
  ::google::protobuf::uint32 textcoloranalog0_;
  ::google::protobuf::uint32 textcoloranalog1_;
  ::google::protobuf::uint32 fillcolordiscryes0_;
  ::google::protobuf::uint32 fillcolordiscryes1_;
  ::google::protobuf::uint32 textcolordiscryes0_;
  ::google::protobuf::uint32 textcolordiscryes1_;
  ::google::protobuf::uint32 fillcolordiscrno0_;
  ::google::protobuf::uint32 fillcolordiscrno1_;
  ::google::protobuf::uint32 textcolordiscrno0_;
  ::google::protobuf::uint32 textcolordiscrno1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemValue* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemBus : public ::google::protobuf::Message {
 public:
  SchemaItemBus();
  virtual ~SchemaItemBus();

  SchemaItemBus(const SchemaItemBus& from);

  inline SchemaItemBus& operator=(const SchemaItemBus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemBus& default_instance();

  void Swap(SchemaItemBus* other);

  // implements Message ----------------------------------------------

  SchemaItemBus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemBus& from);
  void MergeFrom(const SchemaItemBus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string busTypeId = 2;
  inline bool has_bustypeid() const;
  inline void clear_bustypeid();
  static const int kBusTypeIdFieldNumber = 2;
  inline const ::std::string& bustypeid() const;
  inline void set_bustypeid(const ::std::string& value);
  inline void set_bustypeid(const char* value);
  inline void set_bustypeid(const char* value, size_t size);
  inline ::std::string* mutable_bustypeid();
  inline ::std::string* release_bustypeid();
  inline void set_allocated_bustypeid(::std::string* bustypeid);

  // optional fixed64 busTypeHash = 3;
  inline bool has_bustypehash() const;
  inline void clear_bustypehash();
  static const int kBusTypeHashFieldNumber = 3;
  inline ::google::protobuf::uint64 bustypehash() const;
  inline void set_bustypehash(::google::protobuf::uint64 value);

  // optional string busTypeXml = 4;
  inline bool has_bustypexml() const;
  inline void clear_bustypexml();
  static const int kBusTypeXmlFieldNumber = 4;
  inline const ::std::string& bustypexml() const;
  inline void set_bustypexml(const ::std::string& value);
  inline void set_bustypexml(const char* value);
  inline void set_bustypexml(const char* value, size_t size);
  inline ::std::string* mutable_bustypexml();
  inline ::std::string* release_bustypexml();
  inline void set_allocated_bustypexml(::std::string* bustypexml);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemBus)
 private:
  inline void set_has_bustypeid();
  inline void clear_has_bustypeid();
  inline void set_has_bustypehash();
  inline void clear_has_bustypehash();
  inline void set_has_bustypexml();
  inline void clear_has_bustypexml();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bustypeid_;
  ::google::protobuf::uint64 bustypehash_;
  ::std::string* bustypexml_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemBus* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemBusComposer : public ::google::protobuf::Message {
 public:
  SchemaItemBusComposer();
  virtual ~SchemaItemBusComposer();

  SchemaItemBusComposer(const SchemaItemBusComposer& from);

  inline SchemaItemBusComposer& operator=(const SchemaItemBusComposer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemBusComposer& default_instance();

  void Swap(SchemaItemBusComposer* other);

  // implements Message ----------------------------------------------

  SchemaItemBusComposer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemBusComposer& from);
  void MergeFrom(const SchemaItemBusComposer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemBusComposer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemBusComposer* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemBusExtractor : public ::google::protobuf::Message {
 public:
  SchemaItemBusExtractor();
  virtual ~SchemaItemBusExtractor();

  SchemaItemBusExtractor(const SchemaItemBusExtractor& from);

  inline SchemaItemBusExtractor& operator=(const SchemaItemBusExtractor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemBusExtractor& default_instance();

  void Swap(SchemaItemBusExtractor* other);

  // implements Message ----------------------------------------------

  SchemaItemBusExtractor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemBusExtractor& from);
  void MergeFrom(const SchemaItemBusExtractor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemBusExtractor)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemBusExtractor* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemControl : public ::google::protobuf::Message {
 public:
  SchemaItemControl();
  virtual ~SchemaItemControl();

  SchemaItemControl(const SchemaItemControl& from);

  inline SchemaItemControl& operator=(const SchemaItemControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemControl& default_instance();

  void Swap(SchemaItemControl* other);

  // implements Message ----------------------------------------------

  SchemaItemControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemControl& from);
  void MergeFrom(const SchemaItemControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string styleSheet = 1;
  inline bool has_stylesheet() const;
  inline void clear_stylesheet();
  static const int kStyleSheetFieldNumber = 1;
  inline const ::std::string& stylesheet() const;
  inline void set_stylesheet(const ::std::string& value);
  inline void set_stylesheet(const char* value);
  inline void set_stylesheet(const char* value, size_t size);
  inline ::std::string* mutable_stylesheet();
  inline ::std::string* release_stylesheet();
  inline void set_allocated_stylesheet(::std::string* stylesheet);

  // optional string toolTip = 2;
  inline bool has_tooltip() const;
  inline void clear_tooltip();
  static const int kToolTipFieldNumber = 2;
  inline const ::std::string& tooltip() const;
  inline void set_tooltip(const ::std::string& value);
  inline void set_tooltip(const char* value);
  inline void set_tooltip(const char* value, size_t size);
  inline ::std::string* mutable_tooltip();
  inline ::std::string* release_tooltip();
  inline void set_allocated_tooltip(::std::string* tooltip);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemControl)
 private:
  inline void set_has_stylesheet();
  inline void clear_has_stylesheet();
  inline void set_has_tooltip();
  inline void clear_has_tooltip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stylesheet_;
  ::std::string* tooltip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemControl* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemPushButton : public ::google::protobuf::Message {
 public:
  SchemaItemPushButton();
  virtual ~SchemaItemPushButton();

  SchemaItemPushButton(const SchemaItemPushButton& from);

  inline SchemaItemPushButton& operator=(const SchemaItemPushButton& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemPushButton& default_instance();

  void Swap(SchemaItemPushButton* other);

  // implements Message ----------------------------------------------

  SchemaItemPushButton* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemPushButton& from);
  void MergeFrom(const SchemaItemPushButton& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool checkable = 2;
  inline bool has_checkable() const;
  inline void clear_checkable();
  static const int kCheckableFieldNumber = 2;
  inline bool checkable() const;
  inline void set_checkable(bool value);

  // optional bool checkedDefault = 3;
  inline bool has_checkeddefault() const;
  inline void clear_checkeddefault();
  static const int kCheckedDefaultFieldNumber = 3;
  inline bool checkeddefault() const;
  inline void set_checkeddefault(bool value);

  // optional bool autoRepeat = 4;
  inline bool has_autorepeat() const;
  inline void clear_autorepeat();
  static const int kAutoRepeatFieldNumber = 4;
  inline bool autorepeat() const;
  inline void set_autorepeat(bool value);

  // optional int32 autoRepeatDelay = 5;
  inline bool has_autorepeatdelay() const;
  inline void clear_autorepeatdelay();
  static const int kAutoRepeatDelayFieldNumber = 5;
  inline ::google::protobuf::int32 autorepeatdelay() const;
  inline void set_autorepeatdelay(::google::protobuf::int32 value);

  // optional int32 autoRepeatInterval = 6;
  inline bool has_autorepeatinterval() const;
  inline void clear_autorepeatinterval();
  static const int kAutoRepeatIntervalFieldNumber = 6;
  inline ::google::protobuf::int32 autorepeatinterval() const;
  inline void set_autorepeatinterval(::google::protobuf::int32 value);

  // optional string scriptAfterCreate = 21;
  inline bool has_scriptaftercreate() const;
  inline void clear_scriptaftercreate();
  static const int kScriptAfterCreateFieldNumber = 21;
  inline const ::std::string& scriptaftercreate() const;
  inline void set_scriptaftercreate(const ::std::string& value);
  inline void set_scriptaftercreate(const char* value);
  inline void set_scriptaftercreate(const char* value, size_t size);
  inline ::std::string* mutable_scriptaftercreate();
  inline ::std::string* release_scriptaftercreate();
  inline void set_allocated_scriptaftercreate(::std::string* scriptaftercreate);

  // optional string scriptClicked = 22;
  inline bool has_scriptclicked() const;
  inline void clear_scriptclicked();
  static const int kScriptClickedFieldNumber = 22;
  inline const ::std::string& scriptclicked() const;
  inline void set_scriptclicked(const ::std::string& value);
  inline void set_scriptclicked(const char* value);
  inline void set_scriptclicked(const char* value, size_t size);
  inline ::std::string* mutable_scriptclicked();
  inline ::std::string* release_scriptclicked();
  inline void set_allocated_scriptclicked(::std::string* scriptclicked);

  // optional string scriptPressed = 23;
  inline bool has_scriptpressed() const;
  inline void clear_scriptpressed();
  static const int kScriptPressedFieldNumber = 23;
  inline const ::std::string& scriptpressed() const;
  inline void set_scriptpressed(const ::std::string& value);
  inline void set_scriptpressed(const char* value);
  inline void set_scriptpressed(const char* value, size_t size);
  inline ::std::string* mutable_scriptpressed();
  inline ::std::string* release_scriptpressed();
  inline void set_allocated_scriptpressed(::std::string* scriptpressed);

  // optional string scriptReleased = 24;
  inline bool has_scriptreleased() const;
  inline void clear_scriptreleased();
  static const int kScriptReleasedFieldNumber = 24;
  inline const ::std::string& scriptreleased() const;
  inline void set_scriptreleased(const ::std::string& value);
  inline void set_scriptreleased(const char* value);
  inline void set_scriptreleased(const char* value, size_t size);
  inline ::std::string* mutable_scriptreleased();
  inline ::std::string* release_scriptreleased();
  inline void set_allocated_scriptreleased(::std::string* scriptreleased);

  // optional string scriptToggled = 25;
  inline bool has_scripttoggled() const;
  inline void clear_scripttoggled();
  static const int kScriptToggledFieldNumber = 25;
  inline const ::std::string& scripttoggled() const;
  inline void set_scripttoggled(const ::std::string& value);
  inline void set_scripttoggled(const char* value);
  inline void set_scripttoggled(const char* value, size_t size);
  inline ::std::string* mutable_scripttoggled();
  inline ::std::string* release_scripttoggled();
  inline void set_allocated_scripttoggled(::std::string* scripttoggled);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemPushButton)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_checkable();
  inline void clear_has_checkable();
  inline void set_has_checkeddefault();
  inline void clear_has_checkeddefault();
  inline void set_has_autorepeat();
  inline void clear_has_autorepeat();
  inline void set_has_autorepeatdelay();
  inline void clear_has_autorepeatdelay();
  inline void set_has_autorepeatinterval();
  inline void clear_has_autorepeatinterval();
  inline void set_has_scriptaftercreate();
  inline void clear_has_scriptaftercreate();
  inline void set_has_scriptclicked();
  inline void clear_has_scriptclicked();
  inline void set_has_scriptpressed();
  inline void clear_has_scriptpressed();
  inline void set_has_scriptreleased();
  inline void clear_has_scriptreleased();
  inline void set_has_scripttoggled();
  inline void clear_has_scripttoggled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  bool checkable_;
  bool checkeddefault_;
  bool autorepeat_;
  ::google::protobuf::int32 autorepeatdelay_;
  ::std::string* scriptaftercreate_;
  ::std::string* scriptclicked_;
  ::std::string* scriptpressed_;
  ::std::string* scriptreleased_;
  ::std::string* scripttoggled_;
  ::google::protobuf::int32 autorepeatinterval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemPushButton* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemLineEdit : public ::google::protobuf::Message {
 public:
  SchemaItemLineEdit();
  virtual ~SchemaItemLineEdit();

  SchemaItemLineEdit(const SchemaItemLineEdit& from);

  inline SchemaItemLineEdit& operator=(const SchemaItemLineEdit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemLineEdit& default_instance();

  void Swap(SchemaItemLineEdit* other);

  // implements Message ----------------------------------------------

  SchemaItemLineEdit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemLineEdit& from);
  void MergeFrom(const SchemaItemLineEdit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional int32 horzAlign = 2;
  inline bool has_horzalign() const;
  inline void clear_horzalign();
  static const int kHorzAlignFieldNumber = 2;
  inline ::google::protobuf::int32 horzalign() const;
  inline void set_horzalign(::google::protobuf::int32 value);

  // optional int32 vertAlign = 3;
  inline bool has_vertalign() const;
  inline void clear_vertalign();
  static const int kVertAlignFieldNumber = 3;
  inline ::google::protobuf::int32 vertalign() const;
  inline void set_vertalign(::google::protobuf::int32 value);

  // optional int32 maxLength = 4;
  inline bool has_maxlength() const;
  inline void clear_maxlength();
  static const int kMaxLengthFieldNumber = 4;
  inline ::google::protobuf::int32 maxlength() const;
  inline void set_maxlength(::google::protobuf::int32 value);

  // optional string placeholderText = 5;
  inline bool has_placeholdertext() const;
  inline void clear_placeholdertext();
  static const int kPlaceholderTextFieldNumber = 5;
  inline const ::std::string& placeholdertext() const;
  inline void set_placeholdertext(const ::std::string& value);
  inline void set_placeholdertext(const char* value);
  inline void set_placeholdertext(const char* value, size_t size);
  inline ::std::string* mutable_placeholdertext();
  inline ::std::string* release_placeholdertext();
  inline void set_allocated_placeholdertext(::std::string* placeholdertext);

  // optional bool readOnly = 6;
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadOnlyFieldNumber = 6;
  inline bool readonly() const;
  inline void set_readonly(bool value);

  // optional string scriptAfterCreate = 21;
  inline bool has_scriptaftercreate() const;
  inline void clear_scriptaftercreate();
  static const int kScriptAfterCreateFieldNumber = 21;
  inline const ::std::string& scriptaftercreate() const;
  inline void set_scriptaftercreate(const ::std::string& value);
  inline void set_scriptaftercreate(const char* value);
  inline void set_scriptaftercreate(const char* value, size_t size);
  inline ::std::string* mutable_scriptaftercreate();
  inline ::std::string* release_scriptaftercreate();
  inline void set_allocated_scriptaftercreate(::std::string* scriptaftercreate);

  // optional string scriptEditingFinished = 22;
  inline bool has_scripteditingfinished() const;
  inline void clear_scripteditingfinished();
  static const int kScriptEditingFinishedFieldNumber = 22;
  inline const ::std::string& scripteditingfinished() const;
  inline void set_scripteditingfinished(const ::std::string& value);
  inline void set_scripteditingfinished(const char* value);
  inline void set_scripteditingfinished(const char* value, size_t size);
  inline ::std::string* mutable_scripteditingfinished();
  inline ::std::string* release_scripteditingfinished();
  inline void set_allocated_scripteditingfinished(::std::string* scripteditingfinished);

  // optional string scriptReturnPressed = 23;
  inline bool has_scriptreturnpressed() const;
  inline void clear_scriptreturnpressed();
  static const int kScriptReturnPressedFieldNumber = 23;
  inline const ::std::string& scriptreturnpressed() const;
  inline void set_scriptreturnpressed(const ::std::string& value);
  inline void set_scriptreturnpressed(const char* value);
  inline void set_scriptreturnpressed(const char* value, size_t size);
  inline ::std::string* mutable_scriptreturnpressed();
  inline ::std::string* release_scriptreturnpressed();
  inline void set_allocated_scriptreturnpressed(::std::string* scriptreturnpressed);

  // optional string scriptTextChanged = 24;
  inline bool has_scripttextchanged() const;
  inline void clear_scripttextchanged();
  static const int kScriptTextChangedFieldNumber = 24;
  inline const ::std::string& scripttextchanged() const;
  inline void set_scripttextchanged(const ::std::string& value);
  inline void set_scripttextchanged(const char* value);
  inline void set_scripttextchanged(const char* value, size_t size);
  inline ::std::string* mutable_scripttextchanged();
  inline ::std::string* release_scripttextchanged();
  inline void set_allocated_scripttextchanged(::std::string* scripttextchanged);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemLineEdit)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_horzalign();
  inline void clear_has_horzalign();
  inline void set_has_vertalign();
  inline void clear_has_vertalign();
  inline void set_has_maxlength();
  inline void clear_has_maxlength();
  inline void set_has_placeholdertext();
  inline void clear_has_placeholdertext();
  inline void set_has_readonly();
  inline void clear_has_readonly();
  inline void set_has_scriptaftercreate();
  inline void clear_has_scriptaftercreate();
  inline void set_has_scripteditingfinished();
  inline void clear_has_scripteditingfinished();
  inline void set_has_scriptreturnpressed();
  inline void clear_has_scriptreturnpressed();
  inline void set_has_scripttextchanged();
  inline void clear_has_scripttextchanged();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::int32 horzalign_;
  ::google::protobuf::int32 vertalign_;
  ::std::string* placeholdertext_;
  ::google::protobuf::int32 maxlength_;
  bool readonly_;
  ::std::string* scriptaftercreate_;
  ::std::string* scripteditingfinished_;
  ::std::string* scriptreturnpressed_;
  ::std::string* scripttextchanged_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemLineEdit* default_instance_;
};
// -------------------------------------------------------------------

class DeviceObject : public ::google::protobuf::Message {
 public:
  DeviceObject();
  virtual ~DeviceObject();

  DeviceObject(const DeviceObject& from);

  inline DeviceObject& operator=(const DeviceObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceObject& default_instance();

  void Swap(DeviceObject* other);

  // implements Message ----------------------------------------------

  DeviceObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceObject& from);
  void MergeFrom(const DeviceObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring equipmentId = 2;
  inline bool has_equipmentid() const;
  inline void clear_equipmentid();
  static const int kEquipmentIdFieldNumber = 2;
  inline const ::Proto::wstring& equipmentid() const;
  inline ::Proto::wstring* mutable_equipmentid();
  inline ::Proto::wstring* release_equipmentid();
  inline void set_allocated_equipmentid(::Proto::wstring* equipmentid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // optional .Proto.wstring childRestriction = 4;
  inline bool has_childrestriction() const;
  inline void clear_childrestriction();
  static const int kChildRestrictionFieldNumber = 4;
  inline const ::Proto::wstring& childrestriction() const;
  inline ::Proto::wstring* mutable_childrestriction();
  inline ::Proto::wstring* release_childrestriction();
  inline void set_allocated_childrestriction(::Proto::wstring* childrestriction);

  // optional int32 place = 5 [default = 0];
  inline bool has_place() const;
  inline void clear_place();
  static const int kPlaceFieldNumber = 5;
  inline ::google::protobuf::int32 place() const;
  inline void set_place(::google::protobuf::int32 value);

  // optional string specific_properties_struct = 6;
  inline bool has_specific_properties_struct() const;
  inline void clear_specific_properties_struct();
  static const int kSpecificPropertiesStructFieldNumber = 6;
  inline const ::std::string& specific_properties_struct() const;
  inline void set_specific_properties_struct(const ::std::string& value);
  inline void set_specific_properties_struct(const char* value);
  inline void set_specific_properties_struct(const char* value, size_t size);
  inline ::std::string* mutable_specific_properties_struct();
  inline ::std::string* release_specific_properties_struct();
  inline void set_allocated_specific_properties_struct(::std::string* specific_properties_struct);

  // repeated .Proto.Property properties = 7;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 7;
  inline const ::Proto::Property& properties(int index) const;
  inline ::Proto::Property* mutable_properties(int index);
  inline ::Proto::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Property >*
      mutable_properties();

  // optional bool preset = 32 [default = false];
  inline bool has_preset() const;
  inline void clear_preset();
  static const int kPresetFieldNumber = 32;
  inline bool preset() const;
  inline void set_preset(bool value);

  // optional bool presetRoot = 33 [default = false];
  inline bool has_presetroot() const;
  inline void clear_presetroot();
  static const int kPresetRootFieldNumber = 33;
  inline bool presetroot() const;
  inline void set_presetroot(bool value);

  // optional .Proto.wstring presetName = 34;
  inline bool has_presetname() const;
  inline void clear_presetname();
  static const int kPresetNameFieldNumber = 34;
  inline const ::Proto::wstring& presetname() const;
  inline ::Proto::wstring* mutable_presetname();
  inline ::Proto::wstring* release_presetname();
  inline void set_allocated_presetname(::Proto::wstring* presetname);

  // optional .Proto.Uuid presetObjectUuid = 35;
  inline bool has_presetobjectuuid() const;
  inline void clear_presetobjectuuid();
  static const int kPresetObjectUuidFieldNumber = 35;
  inline const ::Proto::Uuid& presetobjectuuid() const;
  inline ::Proto::Uuid* mutable_presetobjectuuid();
  inline ::Proto::Uuid* release_presetobjectuuid();
  inline void set_allocated_presetobjectuuid(::Proto::Uuid* presetobjectuuid);

  // optional int32 childCountHint = 36 [default = 0];
  inline bool has_childcounthint() const;
  inline void clear_childcounthint();
  static const int kChildCountHintFieldNumber = 36;
  inline ::google::protobuf::int32 childcounthint() const;
  inline void set_childcounthint(::google::protobuf::int32 value);

  // optional .Proto.DeviceRoot Root = 100;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 100;
  inline const ::Proto::DeviceRoot& root() const;
  inline ::Proto::DeviceRoot* mutable_root();
  inline ::Proto::DeviceRoot* release_root();
  inline void set_allocated_root(::Proto::DeviceRoot* root);

  // optional .Proto.DeviceSystem System = 101;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 101;
  inline const ::Proto::DeviceSystem& system() const;
  inline ::Proto::DeviceSystem* mutable_system();
  inline ::Proto::DeviceSystem* release_system();
  inline void set_allocated_system(::Proto::DeviceSystem* system);

  // optional .Proto.DeviceRack Rack = 102;
  inline bool has_rack() const;
  inline void clear_rack();
  static const int kRackFieldNumber = 102;
  inline const ::Proto::DeviceRack& rack() const;
  inline ::Proto::DeviceRack* mutable_rack();
  inline ::Proto::DeviceRack* release_rack();
  inline void set_allocated_rack(::Proto::DeviceRack* rack);

  // optional .Proto.DeviceChassis Chassis = 103;
  inline bool has_chassis() const;
  inline void clear_chassis();
  static const int kChassisFieldNumber = 103;
  inline const ::Proto::DeviceChassis& chassis() const;
  inline ::Proto::DeviceChassis* mutable_chassis();
  inline ::Proto::DeviceChassis* release_chassis();
  inline void set_allocated_chassis(::Proto::DeviceChassis* chassis);

  // optional .Proto.DeviceModule Module = 104;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 104;
  inline const ::Proto::DeviceModule& module() const;
  inline ::Proto::DeviceModule* mutable_module();
  inline ::Proto::DeviceModule* release_module();
  inline void set_allocated_module(::Proto::DeviceModule* module);

  // optional .Proto.DeviceController Controller = 105;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 105;
  inline const ::Proto::DeviceController& controller() const;
  inline ::Proto::DeviceController* mutable_controller();
  inline ::Proto::DeviceController* release_controller();
  inline void set_allocated_controller(::Proto::DeviceController* controller);

  // optional .Proto.DeviceSignal Signal = 106;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 106;
  inline const ::Proto::DeviceSignal& signal() const;
  inline ::Proto::DeviceSignal* mutable_signal();
  inline ::Proto::DeviceSignal* release_signal();
  inline void set_allocated_signal(::Proto::DeviceSignal* signal);

  // optional .Proto.Workstation Workstation = 107;
  inline bool has_workstation() const;
  inline void clear_workstation();
  static const int kWorkstationFieldNumber = 107;
  inline const ::Proto::Workstation& workstation() const;
  inline ::Proto::Workstation* mutable_workstation();
  inline ::Proto::Workstation* release_workstation();
  inline void set_allocated_workstation(::Proto::Workstation* workstation);

  // optional .Proto.Software Software = 108;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 108;
  inline const ::Proto::Software& software() const;
  inline ::Proto::Software* mutable_software();
  inline ::Proto::Software* release_software();
  inline void set_allocated_software(::Proto::Software* software);

  // repeated .Proto.Envelope children = 200;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 200;
  inline const ::Proto::Envelope& children(int index) const;
  inline ::Proto::Envelope* mutable_children(int index);
  inline ::Proto::Envelope* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:Proto.DeviceObject)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_equipmentid();
  inline void clear_has_equipmentid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_childrestriction();
  inline void clear_has_childrestriction();
  inline void set_has_place();
  inline void clear_has_place();
  inline void set_has_specific_properties_struct();
  inline void clear_has_specific_properties_struct();
  inline void set_has_preset();
  inline void clear_has_preset();
  inline void set_has_presetroot();
  inline void clear_has_presetroot();
  inline void set_has_presetname();
  inline void clear_has_presetname();
  inline void set_has_presetobjectuuid();
  inline void clear_has_presetobjectuuid();
  inline void set_has_childcounthint();
  inline void clear_has_childcounthint();
  inline void set_has_root();
  inline void clear_has_root();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_rack();
  inline void clear_has_rack();
  inline void set_has_chassis();
  inline void clear_has_chassis();
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_workstation();
  inline void clear_has_workstation();
  inline void set_has_software();
  inline void clear_has_software();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* equipmentid_;
  ::Proto::wstring* caption_;
  ::Proto::wstring* childrestriction_;
  ::std::string* specific_properties_struct_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Property > properties_;
  ::google::protobuf::int32 place_;
  bool preset_;
  bool presetroot_;
  ::Proto::wstring* presetname_;
  ::Proto::Uuid* presetobjectuuid_;
  ::Proto::DeviceRoot* root_;
  ::Proto::DeviceSystem* system_;
  ::Proto::DeviceRack* rack_;
  ::Proto::DeviceChassis* chassis_;
  ::Proto::DeviceModule* module_;
  ::Proto::DeviceController* controller_;
  ::Proto::DeviceSignal* signal_;
  ::Proto::Workstation* workstation_;
  ::Proto::Software* software_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > children_;
  ::google::protobuf::int32 childcounthint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceObject* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRoot : public ::google::protobuf::Message {
 public:
  DeviceRoot();
  virtual ~DeviceRoot();

  DeviceRoot(const DeviceRoot& from);

  inline DeviceRoot& operator=(const DeviceRoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceRoot& default_instance();

  void Swap(DeviceRoot* other);

  // implements Message ----------------------------------------------

  DeviceRoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceRoot& from);
  void MergeFrom(const DeviceRoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceRoot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceRoot* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSystem : public ::google::protobuf::Message {
 public:
  DeviceSystem();
  virtual ~DeviceSystem();

  DeviceSystem(const DeviceSystem& from);

  inline DeviceSystem& operator=(const DeviceSystem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSystem& default_instance();

  void Swap(DeviceSystem* other);

  // implements Message ----------------------------------------------

  DeviceSystem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSystem& from);
  void MergeFrom(const DeviceSystem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceSystem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceSystem* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRack : public ::google::protobuf::Message {
 public:
  DeviceRack();
  virtual ~DeviceRack();

  DeviceRack(const DeviceRack& from);

  inline DeviceRack& operator=(const DeviceRack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceRack& default_instance();

  void Swap(DeviceRack* other);

  // implements Message ----------------------------------------------

  DeviceRack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceRack& from);
  void MergeFrom(const DeviceRack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceRack)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceRack* default_instance_;
};
// -------------------------------------------------------------------

class DeviceChassis : public ::google::protobuf::Message {
 public:
  DeviceChassis();
  virtual ~DeviceChassis();

  DeviceChassis(const DeviceChassis& from);

  inline DeviceChassis& operator=(const DeviceChassis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceChassis& default_instance();

  void Swap(DeviceChassis* other);

  // implements Message ----------------------------------------------

  DeviceChassis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceChassis& from);
  void MergeFrom(const DeviceChassis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DeviceChassis)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceChassis* default_instance_;
};
// -------------------------------------------------------------------

class DeviceModule : public ::google::protobuf::Message {
 public:
  DeviceModule();
  virtual ~DeviceModule();

  DeviceModule(const DeviceModule& from);

  inline DeviceModule& operator=(const DeviceModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceModule& default_instance();

  void Swap(DeviceModule* other);

  // implements Message ----------------------------------------------

  DeviceModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceModule& from);
  void MergeFrom(const DeviceModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 typeObsolete = 1 [default = 0];
  inline bool has_typeobsolete() const;
  inline void clear_typeobsolete();
  static const int kTypeObsoleteFieldNumber = 1;
  inline ::google::protobuf::int32 typeobsolete() const;
  inline void set_typeobsolete(::google::protobuf::int32 value);

  // optional string configurationScript = 2;
  inline bool has_configurationscript() const;
  inline void clear_configurationscript();
  static const int kConfigurationScriptFieldNumber = 2;
  inline const ::std::string& configurationscript() const;
  inline void set_configurationscript(const ::std::string& value);
  inline void set_configurationscript(const char* value);
  inline void set_configurationscript(const char* value, size_t size);
  inline ::std::string* mutable_configurationscript();
  inline ::std::string* release_configurationscript();
  inline void set_allocated_configurationscript(::std::string* configurationscript);

  // optional int32 moduleType = 3;
  inline bool has_moduletype() const;
  inline void clear_moduletype();
  static const int kModuleTypeFieldNumber = 3;
  inline ::google::protobuf::int32 moduletype() const;
  inline void set_moduletype(::google::protobuf::int32 value);

  // optional string rawDataDescription = 4;
  inline bool has_rawdatadescription() const;
  inline void clear_rawdatadescription();
  static const int kRawDataDescriptionFieldNumber = 4;
  inline const ::std::string& rawdatadescription() const;
  inline void set_rawdatadescription(const ::std::string& value);
  inline void set_rawdatadescription(const char* value);
  inline void set_rawdatadescription(const char* value, size_t size);
  inline ::std::string* mutable_rawdatadescription();
  inline ::std::string* release_rawdatadescription();
  inline void set_allocated_rawdatadescription(::std::string* rawdatadescription);

  // @@protoc_insertion_point(class_scope:Proto.DeviceModule)
 private:
  inline void set_has_typeobsolete();
  inline void clear_has_typeobsolete();
  inline void set_has_configurationscript();
  inline void clear_has_configurationscript();
  inline void set_has_moduletype();
  inline void clear_has_moduletype();
  inline void set_has_rawdatadescription();
  inline void clear_has_rawdatadescription();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* configurationscript_;
  ::google::protobuf::int32 typeobsolete_;
  ::google::protobuf::int32 moduletype_;
  ::std::string* rawdatadescription_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceModule* default_instance_;
};
// -------------------------------------------------------------------

class DeviceController : public ::google::protobuf::Message {
 public:
  DeviceController();
  virtual ~DeviceController();

  DeviceController(const DeviceController& from);

  inline DeviceController& operator=(const DeviceController& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceController& default_instance();

  void Swap(DeviceController* other);

  // implements Message ----------------------------------------------

  DeviceController* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceController& from);
  void MergeFrom(const DeviceController& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceController)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceController* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSignal : public ::google::protobuf::Message {
 public:
  DeviceSignal();
  virtual ~DeviceSignal();

  DeviceSignal(const DeviceSignal& from);

  inline DeviceSignal& operator=(const DeviceSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSignal& default_instance();

  void Swap(DeviceSignal* other);

  // implements Message ----------------------------------------------

  DeviceSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSignal& from);
  void MergeFrom(const DeviceSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 obsoletetype = 1 [default = 0];
  inline bool has_obsoletetype() const;
  inline void clear_obsoletetype();
  static const int kObsoletetypeFieldNumber = 1;
  inline ::google::protobuf::int32 obsoletetype() const;
  inline void set_obsoletetype(::google::protobuf::int32 value);

  // optional int32 byteOrder = 2 [default = 0];
  inline bool has_byteorder() const;
  inline void clear_byteorder();
  static const int kByteOrderFieldNumber = 2;
  inline ::google::protobuf::int32 byteorder() const;
  inline void set_byteorder(::google::protobuf::int32 value);

  // optional int32 format = 3 [default = 0];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 3;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);

  // optional int32 size = 4 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int32 valueOffset = 7 [default = 0];
  inline bool has_valueoffset() const;
  inline void clear_valueoffset();
  static const int kValueOffsetFieldNumber = 7;
  inline ::google::protobuf::int32 valueoffset() const;
  inline void set_valueoffset(::google::protobuf::int32 value);

  // optional int32 valueBit = 8 [default = 0];
  inline bool has_valuebit() const;
  inline void clear_valuebit();
  static const int kValueBitFieldNumber = 8;
  inline ::google::protobuf::int32 valuebit() const;
  inline void set_valuebit(::google::protobuf::int32 value);

  // optional int32 type = 9 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 function = 10 [default = 0];
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 10;
  inline ::google::protobuf::int32 function() const;
  inline void set_function(::google::protobuf::int32 value);

  // optional int32 memoryArea = 11 [default = 0];
  inline bool has_memoryarea() const;
  inline void clear_memoryarea();
  static const int kMemoryAreaFieldNumber = 11;
  inline ::google::protobuf::int32 memoryarea() const;
  inline void set_memoryarea(::google::protobuf::int32 value);

  // optional int32 appSignalLowAdc = 12 [default = 0];
  inline bool has_appsignallowadc() const;
  inline void clear_appsignallowadc();
  static const int kAppSignalLowAdcFieldNumber = 12;
  inline ::google::protobuf::int32 appsignallowadc() const;
  inline void set_appsignallowadc(::google::protobuf::int32 value);

  // optional int32 appSignalHighAdc = 13 [default = 65535];
  inline bool has_appsignalhighadc() const;
  inline void clear_appsignalhighadc();
  static const int kAppSignalHighAdcFieldNumber = 13;
  inline ::google::protobuf::int32 appsignalhighadc() const;
  inline void set_appsignalhighadc(::google::protobuf::int32 value);

  // optional double appSignalLowEngUnits = 14 [default = 0];
  inline bool has_appsignallowengunits() const;
  inline void clear_appsignallowengunits();
  static const int kAppSignalLowEngUnitsFieldNumber = 14;
  inline double appsignallowengunits() const;
  inline void set_appsignallowengunits(double value);

  // optional double appSignalHighEngUnits = 15 [default = 100];
  inline bool has_appsignalhighengunits() const;
  inline void clear_appsignalhighengunits();
  static const int kAppSignalHighEngUnitsFieldNumber = 15;
  inline double appsignalhighengunits() const;
  inline void set_appsignalhighengunits(double value);

  // optional int32 appSignalDataFormat = 16 [default = 2];
  inline bool has_appsignaldataformat() const;
  inline void clear_appsignaldataformat();
  static const int kAppSignalDataFormatFieldNumber = 16;
  inline ::google::protobuf::int32 appsignaldataformat() const;
  inline void set_appsignaldataformat(::google::protobuf::int32 value);

  // optional string validitySignalId = 20;
  inline bool has_validitysignalid() const;
  inline void clear_validitysignalid();
  static const int kValiditySignalIdFieldNumber = 20;
  inline const ::std::string& validitysignalid() const;
  inline void set_validitysignalid(const ::std::string& value);
  inline void set_validitysignalid(const char* value);
  inline void set_validitysignalid(const char* value, size_t size);
  inline ::std::string* mutable_validitysignalid();
  inline ::std::string* release_validitysignalid();
  inline void set_allocated_validitysignalid(::std::string* validitysignalid);

  // @@protoc_insertion_point(class_scope:Proto.DeviceSignal)
 private:
  inline void set_has_obsoletetype();
  inline void clear_has_obsoletetype();
  inline void set_has_byteorder();
  inline void clear_has_byteorder();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_valueoffset();
  inline void clear_has_valueoffset();
  inline void set_has_valuebit();
  inline void clear_has_valuebit();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_memoryarea();
  inline void clear_has_memoryarea();
  inline void set_has_appsignallowadc();
  inline void clear_has_appsignallowadc();
  inline void set_has_appsignalhighadc();
  inline void clear_has_appsignalhighadc();
  inline void set_has_appsignallowengunits();
  inline void clear_has_appsignallowengunits();
  inline void set_has_appsignalhighengunits();
  inline void clear_has_appsignalhighengunits();
  inline void set_has_appsignaldataformat();
  inline void clear_has_appsignaldataformat();
  inline void set_has_validitysignalid();
  inline void clear_has_validitysignalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 obsoletetype_;
  ::google::protobuf::int32 byteorder_;
  ::google::protobuf::int32 format_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 valueoffset_;
  ::google::protobuf::int32 valuebit_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 function_;
  ::google::protobuf::int32 memoryarea_;
  ::google::protobuf::int32 appsignallowadc_;
  double appsignallowengunits_;
  ::google::protobuf::int32 appsignalhighadc_;
  ::google::protobuf::int32 appsignaldataformat_;
  double appsignalhighengunits_;
  ::std::string* validitysignalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceSignal* default_instance_;
};
// -------------------------------------------------------------------

class Workstation : public ::google::protobuf::Message {
 public:
  Workstation();
  virtual ~Workstation();

  Workstation(const Workstation& from);

  inline Workstation& operator=(const Workstation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Workstation& default_instance();

  void Swap(Workstation* other);

  // implements Message ----------------------------------------------

  Workstation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Workstation& from);
  void MergeFrom(const Workstation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Workstation)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Workstation* default_instance_;
};
// -------------------------------------------------------------------

class Software : public ::google::protobuf::Message {
 public:
  Software();
  virtual ~Software();

  Software(const Software& from);

  inline Software& operator=(const Software& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Software& default_instance();

  void Swap(Software* other);

  // implements Message ----------------------------------------------

  Software* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Software& from);
  void MergeFrom(const Software& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Software)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Software* default_instance_;
};
// -------------------------------------------------------------------

class ModuleConfiguration : public ::google::protobuf::Message {
 public:
  ModuleConfiguration();
  virtual ~ModuleConfiguration();

  ModuleConfiguration(const ModuleConfiguration& from);

  inline ModuleConfiguration& operator=(const ModuleConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleConfiguration& default_instance();

  void Swap(ModuleConfiguration* other);

  // implements Message ----------------------------------------------

  ModuleConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleConfiguration& from);
  void MergeFrom(const ModuleConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string struct_description = 1;
  inline bool has_struct_description() const;
  inline void clear_struct_description();
  static const int kStructDescriptionFieldNumber = 1;
  inline const ::std::string& struct_description() const;
  inline void set_struct_description(const ::std::string& value);
  inline void set_struct_description(const char* value);
  inline void set_struct_description(const char* value, size_t size);
  inline ::std::string* mutable_struct_description();
  inline ::std::string* release_struct_description();
  inline void set_allocated_struct_description(::std::string* struct_description);

  // repeated .Proto.ModuleConfigurationValue values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::Proto::ModuleConfigurationValue& values(int index) const;
  inline ::Proto::ModuleConfigurationValue* mutable_values(int index);
  inline ::Proto::ModuleConfigurationValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >*
      mutable_values();

  // optional string name = 3 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Proto.ModuleConfiguration)
 private:
  inline void set_has_struct_description();
  inline void clear_has_struct_description();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* struct_description_;
  ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue > values_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static ModuleConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class ModuleConfigurationValue : public ::google::protobuf::Message {
 public:
  ModuleConfigurationValue();
  virtual ~ModuleConfigurationValue();

  ModuleConfigurationValue(const ModuleConfigurationValue& from);

  inline ModuleConfigurationValue& operator=(const ModuleConfigurationValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleConfigurationValue& default_instance();

  void Swap(ModuleConfigurationValue* other);

  // implements Message ----------------------------------------------

  ModuleConfigurationValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleConfigurationValue& from);
  void MergeFrom(const ModuleConfigurationValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Proto.ModuleConfigurationValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static ModuleConfigurationValue* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  void Swap(Property* other);

  // implements Message ----------------------------------------------

  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Proto.Property)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class Address16 : public ::google::protobuf::Message {
 public:
  Address16();
  virtual ~Address16();

  Address16(const Address16& from);

  inline Address16& operator=(const Address16& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address16& default_instance();

  void Swap(Address16* other);

  // implements Message ----------------------------------------------

  Address16* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address16& from);
  void MergeFrom(const Address16& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 offset = 1 [default = -1];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // required int32 bit = 2 [default = -1];
  inline bool has_bit() const;
  inline void clear_bit();
  static const int kBitFieldNumber = 2;
  inline ::google::protobuf::int32 bit() const;
  inline void set_bit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Address16)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_bit();
  inline void clear_has_bit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 bit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Address16* default_instance_;
};
// -------------------------------------------------------------------

class AppSignal : public ::google::protobuf::Message {
 public:
  AppSignal();
  virtual ~AppSignal();

  AppSignal(const AppSignal& from);

  inline AppSignal& operator=(const AppSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppSignal& default_instance();

  void Swap(AppSignal* other);

  // implements Message ----------------------------------------------

  AppSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppSignal& from);
  void MergeFrom(const AppSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 signalGroupID = 2;
  inline bool has_signalgroupid() const;
  inline void clear_signalgroupid();
  static const int kSignalGroupIDFieldNumber = 2;
  inline ::google::protobuf::int32 signalgroupid() const;
  inline void set_signalgroupid(::google::protobuf::int32 value);

  // optional int32 signalInstanceID = 3;
  inline bool has_signalinstanceid() const;
  inline void clear_signalinstanceid();
  static const int kSignalInstanceIDFieldNumber = 3;
  inline ::google::protobuf::int32 signalinstanceid() const;
  inline void set_signalinstanceid(::google::protobuf::int32 value);

  // optional int32 changesetID = 4;
  inline bool has_changesetid() const;
  inline void clear_changesetid();
  static const int kChangesetIDFieldNumber = 4;
  inline ::google::protobuf::int32 changesetid() const;
  inline void set_changesetid(::google::protobuf::int32 value);

  // optional bool checkedOut = 5;
  inline bool has_checkedout() const;
  inline void clear_checkedout();
  static const int kCheckedOutFieldNumber = 5;
  inline bool checkedout() const;
  inline void set_checkedout(bool value);

  // optional int32 userID = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 6;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 subsystemChannel = 7;
  inline bool has_subsystemchannel() const;
  inline void clear_subsystemchannel();
  static const int kSubsystemChannelFieldNumber = 7;
  inline ::google::protobuf::int32 subsystemchannel() const;
  inline void set_subsystemchannel(::google::protobuf::int32 value);

  // optional int32 type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int64 created = 9;
  inline bool has_created() const;
  inline void clear_created();
  static const int kCreatedFieldNumber = 9;
  inline ::google::protobuf::int64 created() const;
  inline void set_created(::google::protobuf::int64 value);

  // optional bool deleted = 10;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 10;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // optional int64 instanceCreated = 11;
  inline bool has_instancecreated() const;
  inline void clear_instancecreated();
  static const int kInstanceCreatedFieldNumber = 11;
  inline ::google::protobuf::int64 instancecreated() const;
  inline void set_instancecreated(::google::protobuf::int64 value);

  // optional int32 instanceAction = 12;
  inline bool has_instanceaction() const;
  inline void clear_instanceaction();
  static const int kInstanceActionFieldNumber = 12;
  inline ::google::protobuf::int32 instanceaction() const;
  inline void set_instanceaction(::google::protobuf::int32 value);

  // optional string appSignalID = 13;
  inline bool has_appsignalid() const;
  inline void clear_appsignalid();
  static const int kAppSignalIDFieldNumber = 13;
  inline const ::std::string& appsignalid() const;
  inline void set_appsignalid(const ::std::string& value);
  inline void set_appsignalid(const char* value);
  inline void set_appsignalid(const char* value, size_t size);
  inline ::std::string* mutable_appsignalid();
  inline ::std::string* release_appsignalid();
  inline void set_allocated_appsignalid(::std::string* appsignalid);

  // optional string customAppSignalID = 14;
  inline bool has_customappsignalid() const;
  inline void clear_customappsignalid();
  static const int kCustomAppSignalIDFieldNumber = 14;
  inline const ::std::string& customappsignalid() const;
  inline void set_customappsignalid(const ::std::string& value);
  inline void set_customappsignalid(const char* value);
  inline void set_customappsignalid(const char* value, size_t size);
  inline ::std::string* mutable_customappsignalid();
  inline ::std::string* release_customappsignalid();
  inline void set_allocated_customappsignalid(::std::string* customappsignalid);

  // optional string caption = 15;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 15;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional int32 dataFormat = 16;
  inline bool has_dataformat() const;
  inline void clear_dataformat();
  static const int kDataFormatFieldNumber = 16;
  inline ::google::protobuf::int32 dataformat() const;
  inline void set_dataformat(::google::protobuf::int32 value);

  // optional int32 dataSize = 17;
  inline bool has_datasize() const;
  inline void clear_datasize();
  static const int kDataSizeFieldNumber = 17;
  inline ::google::protobuf::int32 datasize() const;
  inline void set_datasize(::google::protobuf::int32 value);

  // optional int32 lowADC = 18;
  inline bool has_lowadc() const;
  inline void clear_lowadc();
  static const int kLowADCFieldNumber = 18;
  inline ::google::protobuf::int32 lowadc() const;
  inline void set_lowadc(::google::protobuf::int32 value);

  // optional int32 highADC = 19;
  inline bool has_highadc() const;
  inline void clear_highadc();
  static const int kHighADCFieldNumber = 19;
  inline ::google::protobuf::int32 highadc() const;
  inline void set_highadc(::google::protobuf::int32 value);

  // optional double lowEngeneeringUnits = 20;
  inline bool has_lowengeneeringunits() const;
  inline void clear_lowengeneeringunits();
  static const int kLowEngeneeringUnitsFieldNumber = 20;
  inline double lowengeneeringunits() const;
  inline void set_lowengeneeringunits(double value);

  // optional double highEngeneeringUnits = 21;
  inline bool has_highengeneeringunits() const;
  inline void clear_highengeneeringunits();
  static const int kHighEngeneeringUnitsFieldNumber = 21;
  inline double highengeneeringunits() const;
  inline void set_highengeneeringunits(double value);

  // optional int32 unitID = 22;
  inline bool has_unitid() const;
  inline void clear_unitid();
  static const int kUnitIDFieldNumber = 22;
  inline ::google::protobuf::int32 unitid() const;
  inline void set_unitid(::google::protobuf::int32 value);

  // optional double adjustment = 23;
  inline bool has_adjustment() const;
  inline void clear_adjustment();
  static const int kAdjustmentFieldNumber = 23;
  inline double adjustment() const;
  inline void set_adjustment(double value);

  // optional double lowValidRange = 24;
  inline bool has_lowvalidrange() const;
  inline void clear_lowvalidrange();
  static const int kLowValidRangeFieldNumber = 24;
  inline double lowvalidrange() const;
  inline void set_lowvalidrange(double value);

  // optional double highValidRange = 25;
  inline bool has_highvalidrange() const;
  inline void clear_highvalidrange();
  static const int kHighValidRangeFieldNumber = 25;
  inline double highvalidrange() const;
  inline void set_highvalidrange(double value);

  // optional double unbalanceLimit = 26;
  inline bool has_unbalancelimit() const;
  inline void clear_unbalancelimit();
  static const int kUnbalanceLimitFieldNumber = 26;
  inline double unbalancelimit() const;
  inline void set_unbalancelimit(double value);

  // optional double inputLowLimit = 27;
  inline bool has_inputlowlimit() const;
  inline void clear_inputlowlimit();
  static const int kInputLowLimitFieldNumber = 27;
  inline double inputlowlimit() const;
  inline void set_inputlowlimit(double value);

  // optional double inputHighLimit = 28;
  inline bool has_inputhighlimit() const;
  inline void clear_inputhighlimit();
  static const int kInputHighLimitFieldNumber = 28;
  inline double inputhighlimit() const;
  inline void set_inputhighlimit(double value);

  // optional int32 inputUnitID = 29;
  inline bool has_inputunitid() const;
  inline void clear_inputunitid();
  static const int kInputUnitIDFieldNumber = 29;
  inline ::google::protobuf::int32 inputunitid() const;
  inline void set_inputunitid(::google::protobuf::int32 value);

  // optional int32 inputSensorID = 30;
  inline bool has_inputsensorid() const;
  inline void clear_inputsensorid();
  static const int kInputSensorIDFieldNumber = 30;
  inline ::google::protobuf::int32 inputsensorid() const;
  inline void set_inputsensorid(::google::protobuf::int32 value);

  // optional double outputLowLimit = 31;
  inline bool has_outputlowlimit() const;
  inline void clear_outputlowlimit();
  static const int kOutputLowLimitFieldNumber = 31;
  inline double outputlowlimit() const;
  inline void set_outputlowlimit(double value);

  // optional double outputHighLimit = 32;
  inline bool has_outputhighlimit() const;
  inline void clear_outputhighlimit();
  static const int kOutputHighLimitFieldNumber = 32;
  inline double outputhighlimit() const;
  inline void set_outputhighlimit(double value);

  // optional int32 outputUnitID = 33;
  inline bool has_outputunitid() const;
  inline void clear_outputunitid();
  static const int kOutputUnitIDFieldNumber = 33;
  inline ::google::protobuf::int32 outputunitid() const;
  inline void set_outputunitid(::google::protobuf::int32 value);

  // optional int32 outputMode = 34;
  inline bool has_outputmode() const;
  inline void clear_outputmode();
  static const int kOutputModeFieldNumber = 34;
  inline ::google::protobuf::int32 outputmode() const;
  inline void set_outputmode(::google::protobuf::int32 value);

  // optional int32 outputSensorID = 35;
  inline bool has_outputsensorid() const;
  inline void clear_outputsensorid();
  static const int kOutputSensorIDFieldNumber = 35;
  inline ::google::protobuf::int32 outputsensorid() const;
  inline void set_outputsensorid(::google::protobuf::int32 value);

  // optional bool acquire = 36;
  inline bool has_acquire() const;
  inline void clear_acquire();
  static const int kAcquireFieldNumber = 36;
  inline bool acquire() const;
  inline void set_acquire(bool value);

  // optional bool calculated = 37;
  inline bool has_calculated() const;
  inline void clear_calculated();
  static const int kCalculatedFieldNumber = 37;
  inline bool calculated() const;
  inline void set_calculated(bool value);

  // optional int32 normalState = 38;
  inline bool has_normalstate() const;
  inline void clear_normalstate();
  static const int kNormalStateFieldNumber = 38;
  inline ::google::protobuf::int32 normalstate() const;
  inline void set_normalstate(::google::protobuf::int32 value);

  // optional int32 decimalPlaces = 39;
  inline bool has_decimalplaces() const;
  inline void clear_decimalplaces();
  static const int kDecimalPlacesFieldNumber = 39;
  inline ::google::protobuf::int32 decimalplaces() const;
  inline void set_decimalplaces(::google::protobuf::int32 value);

  // optional double aperture = 40;
  inline bool has_aperture() const;
  inline void clear_aperture();
  static const int kApertureFieldNumber = 40;
  inline double aperture() const;
  inline void set_aperture(double value);

  // optional int32 inOutType = 41;
  inline bool has_inouttype() const;
  inline void clear_inouttype();
  static const int kInOutTypeFieldNumber = 41;
  inline ::google::protobuf::int32 inouttype() const;
  inline void set_inouttype(::google::protobuf::int32 value);

  // optional string equipmentID = 42;
  inline bool has_equipmentid() const;
  inline void clear_equipmentid();
  static const int kEquipmentIDFieldNumber = 42;
  inline const ::std::string& equipmentid() const;
  inline void set_equipmentid(const ::std::string& value);
  inline void set_equipmentid(const char* value);
  inline void set_equipmentid(const char* value, size_t size);
  inline ::std::string* mutable_equipmentid();
  inline ::std::string* release_equipmentid();
  inline void set_allocated_equipmentid(::std::string* equipmentid);

  // optional double filteringTime = 43;
  inline bool has_filteringtime() const;
  inline void clear_filteringtime();
  static const int kFilteringTimeFieldNumber = 43;
  inline double filteringtime() const;
  inline void set_filteringtime(double value);

  // optional double spreadTolerance = 44;
  inline bool has_spreadtolerance() const;
  inline void clear_spreadtolerance();
  static const int kSpreadToleranceFieldNumber = 44;
  inline double spreadtolerance() const;
  inline void set_spreadtolerance(double value);

  // optional int32 byteOrder = 45;
  inline bool has_byteorder() const;
  inline void clear_byteorder();
  static const int kByteOrderFieldNumber = 45;
  inline ::google::protobuf::int32 byteorder() const;
  inline void set_byteorder(::google::protobuf::int32 value);

  // optional bool enableTuning = 46;
  inline bool has_enabletuning() const;
  inline void clear_enabletuning();
  static const int kEnableTuningFieldNumber = 46;
  inline bool enabletuning() const;
  inline void set_enabletuning(bool value);

  // optional float tuningDefaultValue = 47;
  inline bool has_tuningdefaultvalue() const;
  inline void clear_tuningdefaultvalue();
  static const int kTuningDefaultValueFieldNumber = 47;
  inline float tuningdefaultvalue() const;
  inline void set_tuningdefaultvalue(float value);

  // optional float tuningLowBound = 48;
  inline bool has_tuninglowbound() const;
  inline void clear_tuninglowbound();
  static const int kTuningLowBoundFieldNumber = 48;
  inline float tuninglowbound() const;
  inline void set_tuninglowbound(float value);

  // optional float tuningHighBound = 49;
  inline bool has_tuninghighbound() const;
  inline void clear_tuninghighbound();
  static const int kTuningHighBoundFieldNumber = 49;
  inline float tuninghighbound() const;
  inline void set_tuninghighbound(float value);

  // optional uint64 hash = 50;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 50;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // optional string busTypeID = 51;
  inline bool has_bustypeid() const;
  inline void clear_bustypeid();
  static const int kBusTypeIDFieldNumber = 51;
  inline const ::std::string& bustypeid() const;
  inline void set_bustypeid(const ::std::string& value);
  inline void set_bustypeid(const char* value);
  inline void set_bustypeid(const char* value, size_t size);
  inline ::std::string* mutable_bustypeid();
  inline ::std::string* release_bustypeid();
  inline void set_allocated_bustypeid(::std::string* bustypeid);

  // optional bool adaptiveAperture = 52;
  inline bool has_adaptiveaperture() const;
  inline void clear_adaptiveaperture();
  static const int kAdaptiveApertureFieldNumber = 52;
  inline bool adaptiveaperture() const;
  inline void set_adaptiveaperture(bool value);

  // optional int32 regValueAddrOffset = 200;
  inline bool has_regvalueaddroffset() const;
  inline void clear_regvalueaddroffset();
  static const int kRegValueAddrOffsetFieldNumber = 200;
  inline ::google::protobuf::int32 regvalueaddroffset() const;
  inline void set_regvalueaddroffset(::google::protobuf::int32 value);

  // optional int32 regValueAddrBit = 201;
  inline bool has_regvalueaddrbit() const;
  inline void clear_regvalueaddrbit();
  static const int kRegValueAddrBitFieldNumber = 201;
  inline ::google::protobuf::int32 regvalueaddrbit() const;
  inline void set_regvalueaddrbit(::google::protobuf::int32 value);

  // optional int32 regValidityAddrOffset = 202;
  inline bool has_regvalidityaddroffset() const;
  inline void clear_regvalidityaddroffset();
  static const int kRegValidityAddrOffsetFieldNumber = 202;
  inline ::google::protobuf::int32 regvalidityaddroffset() const;
  inline void set_regvalidityaddroffset(::google::protobuf::int32 value);

  // optional int32 regValidityAddrBit = 203;
  inline bool has_regvalidityaddrbit() const;
  inline void clear_regvalidityaddrbit();
  static const int kRegValidityAddrBitFieldNumber = 203;
  inline ::google::protobuf::int32 regvalidityaddrbit() const;
  inline void set_regvalidityaddrbit(::google::protobuf::int32 value);

  // optional int32 ioBufferAddrOffset = 204;
  inline bool has_iobufferaddroffset() const;
  inline void clear_iobufferaddroffset();
  static const int kIoBufferAddrOffsetFieldNumber = 204;
  inline ::google::protobuf::int32 iobufferaddroffset() const;
  inline void set_iobufferaddroffset(::google::protobuf::int32 value);

  // optional int32 ioBufferAddrBit = 205;
  inline bool has_iobufferaddrbit() const;
  inline void clear_iobufferaddrbit();
  static const int kIoBufferAddrBitFieldNumber = 205;
  inline ::google::protobuf::int32 iobufferaddrbit() const;
  inline void set_iobufferaddrbit(::google::protobuf::int32 value);

  // optional int32 ramAddrOffset = 206;
  inline bool has_ramaddroffset() const;
  inline void clear_ramaddroffset();
  static const int kRamAddrOffsetFieldNumber = 206;
  inline ::google::protobuf::int32 ramaddroffset() const;
  inline void set_ramaddroffset(::google::protobuf::int32 value);

  // optional int32 ramAddrBit = 207;
  inline bool has_ramaddrbit() const;
  inline void clear_ramaddrbit();
  static const int kRamAddrBitFieldNumber = 207;
  inline ::google::protobuf::int32 ramaddrbit() const;
  inline void set_ramaddrbit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.AppSignal)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_signalgroupid();
  inline void clear_has_signalgroupid();
  inline void set_has_signalinstanceid();
  inline void clear_has_signalinstanceid();
  inline void set_has_changesetid();
  inline void clear_has_changesetid();
  inline void set_has_checkedout();
  inline void clear_has_checkedout();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_subsystemchannel();
  inline void clear_has_subsystemchannel();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_created();
  inline void clear_has_created();
  inline void set_has_deleted();
  inline void clear_has_deleted();
  inline void set_has_instancecreated();
  inline void clear_has_instancecreated();
  inline void set_has_instanceaction();
  inline void clear_has_instanceaction();
  inline void set_has_appsignalid();
  inline void clear_has_appsignalid();
  inline void set_has_customappsignalid();
  inline void clear_has_customappsignalid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_dataformat();
  inline void clear_has_dataformat();
  inline void set_has_datasize();
  inline void clear_has_datasize();
  inline void set_has_lowadc();
  inline void clear_has_lowadc();
  inline void set_has_highadc();
  inline void clear_has_highadc();
  inline void set_has_lowengeneeringunits();
  inline void clear_has_lowengeneeringunits();
  inline void set_has_highengeneeringunits();
  inline void clear_has_highengeneeringunits();
  inline void set_has_unitid();
  inline void clear_has_unitid();
  inline void set_has_adjustment();
  inline void clear_has_adjustment();
  inline void set_has_lowvalidrange();
  inline void clear_has_lowvalidrange();
  inline void set_has_highvalidrange();
  inline void clear_has_highvalidrange();
  inline void set_has_unbalancelimit();
  inline void clear_has_unbalancelimit();
  inline void set_has_inputlowlimit();
  inline void clear_has_inputlowlimit();
  inline void set_has_inputhighlimit();
  inline void clear_has_inputhighlimit();
  inline void set_has_inputunitid();
  inline void clear_has_inputunitid();
  inline void set_has_inputsensorid();
  inline void clear_has_inputsensorid();
  inline void set_has_outputlowlimit();
  inline void clear_has_outputlowlimit();
  inline void set_has_outputhighlimit();
  inline void clear_has_outputhighlimit();
  inline void set_has_outputunitid();
  inline void clear_has_outputunitid();
  inline void set_has_outputmode();
  inline void clear_has_outputmode();
  inline void set_has_outputsensorid();
  inline void clear_has_outputsensorid();
  inline void set_has_acquire();
  inline void clear_has_acquire();
  inline void set_has_calculated();
  inline void clear_has_calculated();
  inline void set_has_normalstate();
  inline void clear_has_normalstate();
  inline void set_has_decimalplaces();
  inline void clear_has_decimalplaces();
  inline void set_has_aperture();
  inline void clear_has_aperture();
  inline void set_has_inouttype();
  inline void clear_has_inouttype();
  inline void set_has_equipmentid();
  inline void clear_has_equipmentid();
  inline void set_has_filteringtime();
  inline void clear_has_filteringtime();
  inline void set_has_spreadtolerance();
  inline void clear_has_spreadtolerance();
  inline void set_has_byteorder();
  inline void clear_has_byteorder();
  inline void set_has_enabletuning();
  inline void clear_has_enabletuning();
  inline void set_has_tuningdefaultvalue();
  inline void clear_has_tuningdefaultvalue();
  inline void set_has_tuninglowbound();
  inline void clear_has_tuninglowbound();
  inline void set_has_tuninghighbound();
  inline void clear_has_tuninghighbound();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_bustypeid();
  inline void clear_has_bustypeid();
  inline void set_has_adaptiveaperture();
  inline void clear_has_adaptiveaperture();
  inline void set_has_regvalueaddroffset();
  inline void clear_has_regvalueaddroffset();
  inline void set_has_regvalueaddrbit();
  inline void clear_has_regvalueaddrbit();
  inline void set_has_regvalidityaddroffset();
  inline void clear_has_regvalidityaddroffset();
  inline void set_has_regvalidityaddrbit();
  inline void clear_has_regvalidityaddrbit();
  inline void set_has_iobufferaddroffset();
  inline void clear_has_iobufferaddroffset();
  inline void set_has_iobufferaddrbit();
  inline void clear_has_iobufferaddrbit();
  inline void set_has_ramaddroffset();
  inline void clear_has_ramaddroffset();
  inline void set_has_ramaddrbit();
  inline void clear_has_ramaddrbit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 signalgroupid_;
  ::google::protobuf::int32 signalinstanceid_;
  ::google::protobuf::int32 changesetid_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 subsystemchannel_;
  ::google::protobuf::int64 created_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 instanceaction_;
  ::google::protobuf::int64 instancecreated_;
  ::std::string* appsignalid_;
  ::std::string* customappsignalid_;
  ::std::string* caption_;
  ::google::protobuf::int32 dataformat_;
  ::google::protobuf::int32 datasize_;
  ::google::protobuf::int32 lowadc_;
  ::google::protobuf::int32 highadc_;
  double lowengeneeringunits_;
  double highengeneeringunits_;
  bool checkedout_;
  bool deleted_;
  bool acquire_;
  bool calculated_;
  ::google::protobuf::int32 unitid_;
  double adjustment_;
  double lowvalidrange_;
  double highvalidrange_;
  double unbalancelimit_;
  double inputlowlimit_;
  double inputhighlimit_;
  ::google::protobuf::int32 inputunitid_;
  ::google::protobuf::int32 inputsensorid_;
  double outputlowlimit_;
  double outputhighlimit_;
  ::google::protobuf::int32 outputunitid_;
  ::google::protobuf::int32 outputmode_;
  ::google::protobuf::int32 outputsensorid_;
  ::google::protobuf::int32 normalstate_;
  double aperture_;
  ::google::protobuf::int32 decimalplaces_;
  ::google::protobuf::int32 inouttype_;
  ::std::string* equipmentid_;
  double filteringtime_;
  double spreadtolerance_;
  ::google::protobuf::int32 byteorder_;
  float tuningdefaultvalue_;
  float tuninglowbound_;
  float tuninghighbound_;
  ::google::protobuf::uint64 hash_;
  bool enabletuning_;
  bool adaptiveaperture_;
  ::google::protobuf::int32 regvalueaddroffset_;
  ::std::string* bustypeid_;
  ::google::protobuf::int32 regvalueaddrbit_;
  ::google::protobuf::int32 regvalidityaddroffset_;
  ::google::protobuf::int32 regvalidityaddrbit_;
  ::google::protobuf::int32 iobufferaddroffset_;
  ::google::protobuf::int32 iobufferaddrbit_;
  ::google::protobuf::int32 ramaddroffset_;
  ::google::protobuf::int32 ramaddrbit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(60 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AppSignal* default_instance_;
};
// -------------------------------------------------------------------

class AppSignalState : public ::google::protobuf::Message {
 public:
  AppSignalState();
  virtual ~AppSignalState();

  AppSignalState(const AppSignalState& from);

  inline AppSignalState& operator=(const AppSignalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppSignalState& default_instance();

  void Swap(AppSignalState* other);

  // implements Message ----------------------------------------------

  AppSignalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppSignalState& from);
  void MergeFrom(const AppSignalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 hash = 1 [default = 0];
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // optional double value = 2 [default = 0];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // optional uint32 flags = 3 [default = 0];
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional sint64 systemTime = 4 [default = 0];
  inline bool has_systemtime() const;
  inline void clear_systemtime();
  static const int kSystemTimeFieldNumber = 4;
  inline ::google::protobuf::int64 systemtime() const;
  inline void set_systemtime(::google::protobuf::int64 value);

  // optional sint64 localTime = 5 [default = 0];
  inline bool has_localtime() const;
  inline void clear_localtime();
  static const int kLocalTimeFieldNumber = 5;
  inline ::google::protobuf::int64 localtime() const;
  inline void set_localtime(::google::protobuf::int64 value);

  // optional sint64 plantTime = 6 [default = 0];
  inline bool has_planttime() const;
  inline void clear_planttime();
  static const int kPlantTimeFieldNumber = 6;
  inline ::google::protobuf::int64 planttime() const;
  inline void set_planttime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Proto.AppSignalState)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_systemtime();
  inline void clear_has_systemtime();
  inline void set_has_localtime();
  inline void clear_has_localtime();
  inline void set_has_planttime();
  inline void clear_has_planttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 hash_;
  double value_;
  ::google::protobuf::int64 systemtime_;
  ::google::protobuf::int64 localtime_;
  ::google::protobuf::int64 planttime_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AppSignalState* default_instance_;
};
// -------------------------------------------------------------------

class AppSignalParam : public ::google::protobuf::Message {
 public:
  AppSignalParam();
  virtual ~AppSignalParam();

  AppSignalParam(const AppSignalParam& from);

  inline AppSignalParam& operator=(const AppSignalParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppSignalParam& default_instance();

  void Swap(AppSignalParam* other);

  // implements Message ----------------------------------------------

  AppSignalParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppSignalParam& from);
  void MergeFrom(const AppSignalParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 hash = 2 [default = 0];
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // optional string appSignalId = 3 [default = ""];
  inline bool has_appsignalid() const;
  inline void clear_appsignalid();
  static const int kAppSignalIdFieldNumber = 3;
  inline const ::std::string& appsignalid() const;
  inline void set_appsignalid(const ::std::string& value);
  inline void set_appsignalid(const char* value);
  inline void set_appsignalid(const char* value, size_t size);
  inline ::std::string* mutable_appsignalid();
  inline ::std::string* release_appsignalid();
  inline void set_allocated_appsignalid(::std::string* appsignalid);

  // optional string customSignalId = 4 [default = ""];
  inline bool has_customsignalid() const;
  inline void clear_customsignalid();
  static const int kCustomSignalIdFieldNumber = 4;
  inline const ::std::string& customsignalid() const;
  inline void set_customsignalid(const ::std::string& value);
  inline void set_customsignalid(const char* value);
  inline void set_customsignalid(const char* value, size_t size);
  inline ::std::string* mutable_customsignalid();
  inline ::std::string* release_customsignalid();
  inline void set_allocated_customsignalid(::std::string* customsignalid);

  // optional string caption = 5 [default = ""];
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 5;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional string equipmentId = 6 [default = ""];
  inline bool has_equipmentid() const;
  inline void clear_equipmentid();
  static const int kEquipmentIdFieldNumber = 6;
  inline const ::std::string& equipmentid() const;
  inline void set_equipmentid(const ::std::string& value);
  inline void set_equipmentid(const char* value);
  inline void set_equipmentid(const char* value, size_t size);
  inline ::std::string* mutable_equipmentid();
  inline ::std::string* release_equipmentid();
  inline void set_allocated_equipmentid(::std::string* equipmentid);

  // optional int32 channel = 10 [default = 0];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 10;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 inOutType = 11 [default = 2];
  inline bool has_inouttype() const;
  inline void clear_inouttype();
  static const int kInOutTypeFieldNumber = 11;
  inline ::google::protobuf::int32 inouttype() const;
  inline void set_inouttype(::google::protobuf::int32 value);

  // optional int32 signalType = 12 [default = 0];
  inline bool has_signaltype() const;
  inline void clear_signaltype();
  static const int kSignalTypeFieldNumber = 12;
  inline ::google::protobuf::int32 signaltype() const;
  inline void set_signaltype(::google::protobuf::int32 value);

  // optional int32 analogSignalFormat = 13 [default = 2];
  inline bool has_analogsignalformat() const;
  inline void clear_analogsignalformat();
  static const int kAnalogSignalFormatFieldNumber = 13;
  inline ::google::protobuf::int32 analogsignalformat() const;
  inline void set_analogsignalformat(::google::protobuf::int32 value);

  // optional int32 byteOrder = 14 [default = 2];
  inline bool has_byteorder() const;
  inline void clear_byteorder();
  static const int kByteOrderFieldNumber = 14;
  inline ::google::protobuf::int32 byteorder() const;
  inline void set_byteorder(::google::protobuf::int32 value);

  // optional int32 unitId = 15 [default = 1];
  inline bool has_unitid() const;
  inline void clear_unitid();
  static const int kUnitIdFieldNumber = 15;
  inline ::google::protobuf::int32 unitid() const;
  inline void set_unitid(::google::protobuf::int32 value);

  // optional string unit = 16 [default = ""];
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 16;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  inline void set_allocated_unit(::std::string* unit);

  // optional double lowValidRange = 20 [default = 0];
  inline bool has_lowvalidrange() const;
  inline void clear_lowvalidrange();
  static const int kLowValidRangeFieldNumber = 20;
  inline double lowvalidrange() const;
  inline void set_lowvalidrange(double value);

  // optional double highValidRange = 21 [default = 0];
  inline bool has_highvalidrange() const;
  inline void clear_highvalidrange();
  static const int kHighValidRangeFieldNumber = 21;
  inline double highvalidrange() const;
  inline void set_highvalidrange(double value);

  // optional double lowEngeneeringUnits = 22 [default = 0];
  inline bool has_lowengeneeringunits() const;
  inline void clear_lowengeneeringunits();
  static const int kLowEngeneeringUnitsFieldNumber = 22;
  inline double lowengeneeringunits() const;
  inline void set_lowengeneeringunits(double value);

  // optional double highEngeneeringUnits = 23 [default = 0];
  inline bool has_highengeneeringunits() const;
  inline void clear_highengeneeringunits();
  static const int kHighEngeneeringUnitsFieldNumber = 23;
  inline double highengeneeringunits() const;
  inline void set_highengeneeringunits(double value);

  // optional double inputLowLimit = 30 [default = 0];
  inline bool has_inputlowlimit() const;
  inline void clear_inputlowlimit();
  static const int kInputLowLimitFieldNumber = 30;
  inline double inputlowlimit() const;
  inline void set_inputlowlimit(double value);

  // optional double inputHighLimit = 31 [default = 0];
  inline bool has_inputhighlimit() const;
  inline void clear_inputhighlimit();
  static const int kInputHighLimitFieldNumber = 31;
  inline double inputhighlimit() const;
  inline void set_inputhighlimit(double value);

  // optional int32 inputUnitId = 32 [default = 1];
  inline bool has_inputunitid() const;
  inline void clear_inputunitid();
  static const int kInputUnitIdFieldNumber = 32;
  inline ::google::protobuf::int32 inputunitid() const;
  inline void set_inputunitid(::google::protobuf::int32 value);

  // optional int32 inputSensorType = 33 [default = 0];
  inline bool has_inputsensortype() const;
  inline void clear_inputsensortype();
  static const int kInputSensorTypeFieldNumber = 33;
  inline ::google::protobuf::int32 inputsensortype() const;
  inline void set_inputsensortype(::google::protobuf::int32 value);

  // optional double outputLowLimit = 40 [default = 0];
  inline bool has_outputlowlimit() const;
  inline void clear_outputlowlimit();
  static const int kOutputLowLimitFieldNumber = 40;
  inline double outputlowlimit() const;
  inline void set_outputlowlimit(double value);

  // optional double outputHighLimit = 41 [default = 0];
  inline bool has_outputhighlimit() const;
  inline void clear_outputhighlimit();
  static const int kOutputHighLimitFieldNumber = 41;
  inline double outputhighlimit() const;
  inline void set_outputhighlimit(double value);

  // optional int32 outputUnitId = 42 [default = 1];
  inline bool has_outputunitid() const;
  inline void clear_outputunitid();
  static const int kOutputUnitIdFieldNumber = 42;
  inline ::google::protobuf::int32 outputunitid() const;
  inline void set_outputunitid(::google::protobuf::int32 value);

  // optional int32 outputMode = 43 [default = 0];
  inline bool has_outputmode() const;
  inline void clear_outputmode();
  static const int kOutputModeFieldNumber = 43;
  inline ::google::protobuf::int32 outputmode() const;
  inline void set_outputmode(::google::protobuf::int32 value);

  // optional int32 outputSensorType = 44 [default = 0];
  inline bool has_outputsensortype() const;
  inline void clear_outputsensortype();
  static const int kOutputSensorTypeFieldNumber = 44;
  inline ::google::protobuf::int32 outputsensortype() const;
  inline void set_outputsensortype(::google::protobuf::int32 value);

  // optional int32 precision = 50 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 50;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional double aperture = 51 [default = 1];
  inline bool has_aperture() const;
  inline void clear_aperture();
  static const int kApertureFieldNumber = 51;
  inline double aperture() const;
  inline void set_aperture(double value);

  // optional double filteringTime = 52 [default = 0.005];
  inline bool has_filteringtime() const;
  inline void clear_filteringtime();
  static const int kFilteringTimeFieldNumber = 52;
  inline double filteringtime() const;
  inline void set_filteringtime(double value);

  // optional double spreadTolerance = 53 [default = 2];
  inline bool has_spreadtolerance() const;
  inline void clear_spreadtolerance();
  static const int kSpreadToleranceFieldNumber = 53;
  inline double spreadtolerance() const;
  inline void set_spreadtolerance(double value);

  // optional bool enableTuning = 54 [default = false];
  inline bool has_enabletuning() const;
  inline void clear_enabletuning();
  static const int kEnableTuningFieldNumber = 54;
  inline bool enabletuning() const;
  inline void set_enabletuning(bool value);

  // optional double tuningDefaultValue = 55 [default = 0];
  inline bool has_tuningdefaultvalue() const;
  inline void clear_tuningdefaultvalue();
  static const int kTuningDefaultValueFieldNumber = 55;
  inline double tuningdefaultvalue() const;
  inline void set_tuningdefaultvalue(double value);

  // @@protoc_insertion_point(class_scope:Proto.AppSignalParam)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_appsignalid();
  inline void clear_has_appsignalid();
  inline void set_has_customsignalid();
  inline void clear_has_customsignalid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_equipmentid();
  inline void clear_has_equipmentid();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_inouttype();
  inline void clear_has_inouttype();
  inline void set_has_signaltype();
  inline void clear_has_signaltype();
  inline void set_has_analogsignalformat();
  inline void clear_has_analogsignalformat();
  inline void set_has_byteorder();
  inline void clear_has_byteorder();
  inline void set_has_unitid();
  inline void clear_has_unitid();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_lowvalidrange();
  inline void clear_has_lowvalidrange();
  inline void set_has_highvalidrange();
  inline void clear_has_highvalidrange();
  inline void set_has_lowengeneeringunits();
  inline void clear_has_lowengeneeringunits();
  inline void set_has_highengeneeringunits();
  inline void clear_has_highengeneeringunits();
  inline void set_has_inputlowlimit();
  inline void clear_has_inputlowlimit();
  inline void set_has_inputhighlimit();
  inline void clear_has_inputhighlimit();
  inline void set_has_inputunitid();
  inline void clear_has_inputunitid();
  inline void set_has_inputsensortype();
  inline void clear_has_inputsensortype();
  inline void set_has_outputlowlimit();
  inline void clear_has_outputlowlimit();
  inline void set_has_outputhighlimit();
  inline void clear_has_outputhighlimit();
  inline void set_has_outputunitid();
  inline void clear_has_outputunitid();
  inline void set_has_outputmode();
  inline void clear_has_outputmode();
  inline void set_has_outputsensortype();
  inline void clear_has_outputsensortype();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_aperture();
  inline void clear_has_aperture();
  inline void set_has_filteringtime();
  inline void clear_has_filteringtime();
  inline void set_has_spreadtolerance();
  inline void clear_has_spreadtolerance();
  inline void set_has_enabletuning();
  inline void clear_has_enabletuning();
  inline void set_has_tuningdefaultvalue();
  inline void clear_has_tuningdefaultvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 hash_;
  ::std::string* appsignalid_;
  ::std::string* customsignalid_;
  ::std::string* caption_;
  ::std::string* equipmentid_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 inouttype_;
  ::google::protobuf::int32 signaltype_;
  ::google::protobuf::int32 analogsignalformat_;
  ::google::protobuf::int32 byteorder_;
  ::google::protobuf::int32 unitid_;
  ::std::string* unit_;
  double lowvalidrange_;
  double highvalidrange_;
  double lowengeneeringunits_;
  double highengeneeringunits_;
  double inputlowlimit_;
  double inputhighlimit_;
  ::google::protobuf::int32 inputunitid_;
  ::google::protobuf::int32 inputsensortype_;
  double outputlowlimit_;
  double outputhighlimit_;
  ::google::protobuf::int32 outputunitid_;
  ::google::protobuf::int32 outputmode_;
  ::google::protobuf::int32 outputsensortype_;
  ::google::protobuf::int32 precision_;
  double aperture_;
  double filteringtime_;
  double spreadtolerance_;
  double tuningdefaultvalue_;
  bool enabletuning_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AppSignalParam* default_instance_;
};
// -------------------------------------------------------------------

class AppSignalParamSet : public ::google::protobuf::Message {
 public:
  AppSignalParamSet();
  virtual ~AppSignalParamSet();

  AppSignalParamSet(const AppSignalParamSet& from);

  inline AppSignalParamSet& operator=(const AppSignalParamSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppSignalParamSet& default_instance();

  void Swap(AppSignalParamSet* other);

  // implements Message ----------------------------------------------

  AppSignalParamSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppSignalParamSet& from);
  void MergeFrom(const AppSignalParamSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.AppSignalParam items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Proto::AppSignalParam& items(int index) const;
  inline ::Proto::AppSignalParam* mutable_items(int index);
  inline ::Proto::AppSignalParam* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AppSignalParam >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AppSignalParam >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Proto.AppSignalParamSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::AppSignalParam > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AppSignalParamSet* default_instance_;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  void Swap(Connection* other);

  // implements Message ----------------------------------------------

  Connection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ConnectionID = 2 [default = ""];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 2;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // optional string Port1EquipmentID = 3 [default = ""];
  inline bool has_port1equipmentid() const;
  inline void clear_port1equipmentid();
  static const int kPort1EquipmentIDFieldNumber = 3;
  inline const ::std::string& port1equipmentid() const;
  inline void set_port1equipmentid(const ::std::string& value);
  inline void set_port1equipmentid(const char* value);
  inline void set_port1equipmentid(const char* value, size_t size);
  inline ::std::string* mutable_port1equipmentid();
  inline ::std::string* release_port1equipmentid();
  inline void set_allocated_port1equipmentid(::std::string* port1equipmentid);

  // optional string Port2EquipmentID = 4 [default = ""];
  inline bool has_port2equipmentid() const;
  inline void clear_port2equipmentid();
  static const int kPort2EquipmentIDFieldNumber = 4;
  inline const ::std::string& port2equipmentid() const;
  inline void set_port2equipmentid(const ::std::string& value);
  inline void set_port2equipmentid(const char* value);
  inline void set_port2equipmentid(const char* value, size_t size);
  inline ::std::string* mutable_port2equipmentid();
  inline ::std::string* release_port2equipmentid();
  inline void set_allocated_port2equipmentid(::std::string* port2equipmentid);

  // optional string Port1RawDataDescription = 5 [default = ""];
  inline bool has_port1rawdatadescription() const;
  inline void clear_port1rawdatadescription();
  static const int kPort1RawDataDescriptionFieldNumber = 5;
  inline const ::std::string& port1rawdatadescription() const;
  inline void set_port1rawdatadescription(const ::std::string& value);
  inline void set_port1rawdatadescription(const char* value);
  inline void set_port1rawdatadescription(const char* value, size_t size);
  inline ::std::string* mutable_port1rawdatadescription();
  inline ::std::string* release_port1rawdatadescription();
  inline void set_allocated_port1rawdatadescription(::std::string* port1rawdatadescription);

  // optional string Port2RawDataDescription = 6 [default = ""];
  inline bool has_port2rawdatadescription() const;
  inline void clear_port2rawdatadescription();
  static const int kPort2RawDataDescriptionFieldNumber = 6;
  inline const ::std::string& port2rawdatadescription() const;
  inline void set_port2rawdatadescription(const ::std::string& value);
  inline void set_port2rawdatadescription(const char* value);
  inline void set_port2rawdatadescription(const char* value, size_t size);
  inline ::std::string* mutable_port2rawdatadescription();
  inline ::std::string* release_port2rawdatadescription();
  inline void set_allocated_port2rawdatadescription(::std::string* port2rawdatadescription);

  // optional bool ManualSettings = 11 [default = false];
  inline bool has_manualsettings() const;
  inline void clear_manualsettings();
  static const int kManualSettingsFieldNumber = 11;
  inline bool manualsettings() const;
  inline void set_manualsettings(bool value);

  // optional bool DisableDataID = 12 [default = false];
  inline bool has_disabledataid() const;
  inline void clear_disabledataid();
  static const int kDisableDataIDFieldNumber = 12;
  inline bool disabledataid() const;
  inline void set_disabledataid(bool value);

  // optional bool GenerateVHDFile = 13 [default = false];
  inline bool has_generatevhdfile() const;
  inline void clear_generatevhdfile();
  static const int kGenerateVHDFileFieldNumber = 13;
  inline bool generatevhdfile() const;
  inline void set_generatevhdfile(bool value);

  // optional int32 Port1TxStartAddress = 14 [default = 0];
  inline bool has_port1txstartaddress() const;
  inline void clear_port1txstartaddress();
  static const int kPort1TxStartAddressFieldNumber = 14;
  inline ::google::protobuf::int32 port1txstartaddress() const;
  inline void set_port1txstartaddress(::google::protobuf::int32 value);

  // optional int32 Port1TxWordsQuantity = 15 [default = 479];
  inline bool has_port1txwordsquantity() const;
  inline void clear_port1txwordsquantity();
  static const int kPort1TxWordsQuantityFieldNumber = 15;
  inline ::google::protobuf::int32 port1txwordsquantity() const;
  inline void set_port1txwordsquantity(::google::protobuf::int32 value);

  // optional int32 Port1RxWordsQuantity = 16 [default = 479];
  inline bool has_port1rxwordsquantity() const;
  inline void clear_port1rxwordsquantity();
  static const int kPort1RxWordsQuantityFieldNumber = 16;
  inline ::google::protobuf::int32 port1rxwordsquantity() const;
  inline void set_port1rxwordsquantity(::google::protobuf::int32 value);

  // optional int32 Port2TxStartAddress = 17 [default = 0];
  inline bool has_port2txstartaddress() const;
  inline void clear_port2txstartaddress();
  static const int kPort2TxStartAddressFieldNumber = 17;
  inline ::google::protobuf::int32 port2txstartaddress() const;
  inline void set_port2txstartaddress(::google::protobuf::int32 value);

  // optional int32 Port2TxWordsQuantity = 18 [default = 479];
  inline bool has_port2txwordsquantity() const;
  inline void clear_port2txwordsquantity();
  static const int kPort2TxWordsQuantityFieldNumber = 18;
  inline ::google::protobuf::int32 port2txwordsquantity() const;
  inline void set_port2txwordsquantity(::google::protobuf::int32 value);

  // optional int32 Port2RxWordsQuantity = 19 [default = 479];
  inline bool has_port2rxwordsquantity() const;
  inline void clear_port2rxwordsquantity();
  static const int kPort2RxWordsQuantityFieldNumber = 19;
  inline ::google::protobuf::int32 port2rxwordsquantity() const;
  inline void set_port2rxwordsquantity(::google::protobuf::int32 value);

  // optional .Proto.Uuid uuid = 20;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 20;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // optional bool Port1EnableSerial = 21 [default = false];
  inline bool has_port1enableserial() const;
  inline void clear_port1enableserial();
  static const int kPort1EnableSerialFieldNumber = 21;
  inline bool port1enableserial() const;
  inline void set_port1enableserial(bool value);

  // optional int32 Port1SerialMode = 22 [default = 0];
  inline bool has_port1serialmode() const;
  inline void clear_port1serialmode();
  static const int kPort1SerialModeFieldNumber = 22;
  inline ::google::protobuf::int32 port1serialmode() const;
  inline void set_port1serialmode(::google::protobuf::int32 value);

  // optional bool Port1EnableDuplex = 23 [default = false];
  inline bool has_port1enableduplex() const;
  inline void clear_port1enableduplex();
  static const int kPort1EnableDuplexFieldNumber = 23;
  inline bool port1enableduplex() const;
  inline void set_port1enableduplex(bool value);

  // optional bool Port2EnableSerial = 24 [default = false];
  inline bool has_port2enableserial() const;
  inline void clear_port2enableserial();
  static const int kPort2EnableSerialFieldNumber = 24;
  inline bool port2enableserial() const;
  inline void set_port2enableserial(bool value);

  // optional int32 Port2SerialMode = 25 [default = 0];
  inline bool has_port2serialmode() const;
  inline void clear_port2serialmode();
  static const int kPort2SerialModeFieldNumber = 25;
  inline ::google::protobuf::int32 port2serialmode() const;
  inline void set_port2serialmode(::google::protobuf::int32 value);

  // optional bool Port2EnableDuplex = 26 [default = false];
  inline bool has_port2enableduplex() const;
  inline void clear_port2enableduplex();
  static const int kPort2EnableDuplexFieldNumber = 26;
  inline bool port2enableduplex() const;
  inline void set_port2enableduplex(bool value);

  // optional int32 Type = 27 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 27;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 ObsoleteMode = 8 [default = 0];
  inline bool has_obsoletemode() const;
  inline void clear_obsoletemode();
  static const int kObsoleteModeFieldNumber = 8;
  inline ::google::protobuf::int32 obsoletemode() const;
  inline void set_obsoletemode(::google::protobuf::int32 value);

  // optional int32 ObsoleteSerialMode = 7 [default = 0];
  inline bool has_obsoleteserialmode() const;
  inline void clear_obsoleteserialmode();
  static const int kObsoleteSerialModeFieldNumber = 7;
  inline ::google::protobuf::int32 obsoleteserialmode() const;
  inline void set_obsoleteserialmode(::google::protobuf::int32 value);

  // optional bool ObsoleteEnableDuplex = 10 [default = false];
  inline bool has_obsoleteenableduplex() const;
  inline void clear_obsoleteenableduplex();
  static const int kObsoleteEnableDuplexFieldNumber = 10;
  inline bool obsoleteenableduplex() const;
  inline void set_obsoleteenableduplex(bool value);

  // @@protoc_insertion_point(class_scope:Proto.Connection)
 private:
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_port1equipmentid();
  inline void clear_has_port1equipmentid();
  inline void set_has_port2equipmentid();
  inline void clear_has_port2equipmentid();
  inline void set_has_port1rawdatadescription();
  inline void clear_has_port1rawdatadescription();
  inline void set_has_port2rawdatadescription();
  inline void clear_has_port2rawdatadescription();
  inline void set_has_manualsettings();
  inline void clear_has_manualsettings();
  inline void set_has_disabledataid();
  inline void clear_has_disabledataid();
  inline void set_has_generatevhdfile();
  inline void clear_has_generatevhdfile();
  inline void set_has_port1txstartaddress();
  inline void clear_has_port1txstartaddress();
  inline void set_has_port1txwordsquantity();
  inline void clear_has_port1txwordsquantity();
  inline void set_has_port1rxwordsquantity();
  inline void clear_has_port1rxwordsquantity();
  inline void set_has_port2txstartaddress();
  inline void clear_has_port2txstartaddress();
  inline void set_has_port2txwordsquantity();
  inline void clear_has_port2txwordsquantity();
  inline void set_has_port2rxwordsquantity();
  inline void clear_has_port2rxwordsquantity();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_port1enableserial();
  inline void clear_has_port1enableserial();
  inline void set_has_port1serialmode();
  inline void clear_has_port1serialmode();
  inline void set_has_port1enableduplex();
  inline void clear_has_port1enableduplex();
  inline void set_has_port2enableserial();
  inline void clear_has_port2enableserial();
  inline void set_has_port2serialmode();
  inline void clear_has_port2serialmode();
  inline void set_has_port2enableduplex();
  inline void clear_has_port2enableduplex();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_obsoletemode();
  inline void clear_has_obsoletemode();
  inline void set_has_obsoleteserialmode();
  inline void clear_has_obsoleteserialmode();
  inline void set_has_obsoleteenableduplex();
  inline void clear_has_obsoleteenableduplex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* connectionid_;
  ::std::string* port1equipmentid_;
  ::std::string* port2equipmentid_;
  ::std::string* port1rawdatadescription_;
  ::std::string* port2rawdatadescription_;
  ::google::protobuf::int32 port1txstartaddress_;
  bool manualsettings_;
  bool disabledataid_;
  bool generatevhdfile_;
  bool port1enableserial_;
  ::google::protobuf::int32 port1txwordsquantity_;
  ::google::protobuf::int32 port1rxwordsquantity_;
  ::google::protobuf::int32 port2txstartaddress_;
  ::google::protobuf::int32 port2txwordsquantity_;
  ::Proto::Uuid* uuid_;
  ::google::protobuf::int32 port2rxwordsquantity_;
  ::google::protobuf::int32 port1serialmode_;
  ::google::protobuf::int32 port2serialmode_;
  bool port1enableduplex_;
  bool port2enableserial_;
  bool port2enableduplex_;
  bool obsoleteenableduplex_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 obsoletemode_;
  ::google::protobuf::int32 obsoleteserialmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Connection* default_instance_;
};
// -------------------------------------------------------------------

class SchemaDetailsSet : public ::google::protobuf::Message {
 public:
  SchemaDetailsSet();
  virtual ~SchemaDetailsSet();

  SchemaDetailsSet(const SchemaDetailsSet& from);

  inline SchemaDetailsSet& operator=(const SchemaDetailsSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaDetailsSet& default_instance();

  void Swap(SchemaDetailsSet* other);

  // implements Message ----------------------------------------------

  SchemaDetailsSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaDetailsSet& from);
  void MergeFrom(const SchemaDetailsSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.SchemaDetails schemasDetails = 2;
  inline int schemasdetails_size() const;
  inline void clear_schemasdetails();
  static const int kSchemasDetailsFieldNumber = 2;
  inline const ::Proto::SchemaDetails& schemasdetails(int index) const;
  inline ::Proto::SchemaDetails* mutable_schemasdetails(int index);
  inline ::Proto::SchemaDetails* add_schemasdetails();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaDetails >&
      schemasdetails() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaDetails >*
      mutable_schemasdetails();

  // @@protoc_insertion_point(class_scope:Proto.SchemaDetailsSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::SchemaDetails > schemasdetails_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaDetailsSet* default_instance_;
};
// -------------------------------------------------------------------

class SchemaDetails : public ::google::protobuf::Message {
 public:
  SchemaDetails();
  virtual ~SchemaDetails();

  SchemaDetails(const SchemaDetails& from);

  inline SchemaDetails& operator=(const SchemaDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaDetails& default_instance();

  void Swap(SchemaDetails* other);

  // implements Message ----------------------------------------------

  SchemaDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaDetails& from);
  void MergeFrom(const SchemaDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string schemaId = 4;
  inline bool has_schemaid() const;
  inline void clear_schemaid();
  static const int kSchemaIdFieldNumber = 4;
  inline const ::std::string& schemaid() const;
  inline void set_schemaid(const ::std::string& value);
  inline void set_schemaid(const char* value);
  inline void set_schemaid(const char* value, size_t size);
  inline ::std::string* mutable_schemaid();
  inline ::std::string* release_schemaid();
  inline void set_allocated_schemaid(::std::string* schemaid);

  // optional string caption = 5;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 5;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional bool excludedfromBuild = 6;
  inline bool has_excludedfrombuild() const;
  inline void clear_excludedfrombuild();
  static const int kExcludedfromBuildFieldNumber = 6;
  inline bool excludedfrombuild() const;
  inline void set_excludedfrombuild(bool value);

  // optional string equipmentId = 7;
  inline bool has_equipmentid() const;
  inline void clear_equipmentid();
  static const int kEquipmentIdFieldNumber = 7;
  inline const ::std::string& equipmentid() const;
  inline void set_equipmentid(const ::std::string& value);
  inline void set_equipmentid(const char* value);
  inline void set_equipmentid(const char* value, size_t size);
  inline ::std::string* mutable_equipmentid();
  inline ::std::string* release_equipmentid();
  inline void set_allocated_equipmentid(::std::string* equipmentid);

  // optional string lmDescriptionFile = 8;
  inline bool has_lmdescriptionfile() const;
  inline void clear_lmdescriptionfile();
  static const int kLmDescriptionFileFieldNumber = 8;
  inline const ::std::string& lmdescriptionfile() const;
  inline void set_lmdescriptionfile(const ::std::string& value);
  inline void set_lmdescriptionfile(const char* value);
  inline void set_lmdescriptionfile(const char* value, size_t size);
  inline ::std::string* mutable_lmdescriptionfile();
  inline ::std::string* release_lmdescriptionfile();
  inline void set_allocated_lmdescriptionfile(::std::string* lmdescriptionfile);

  // repeated string signalIds = 20;
  inline int signalids_size() const;
  inline void clear_signalids();
  static const int kSignalIdsFieldNumber = 20;
  inline const ::std::string& signalids(int index) const;
  inline ::std::string* mutable_signalids(int index);
  inline void set_signalids(int index, const ::std::string& value);
  inline void set_signalids(int index, const char* value);
  inline void set_signalids(int index, const char* value, size_t size);
  inline ::std::string* add_signalids();
  inline void add_signalids(const ::std::string& value);
  inline void add_signalids(const char* value);
  inline void add_signalids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& signalids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signalids();

  // repeated string labels = 21;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 21;
  inline const ::std::string& labels(int index) const;
  inline ::std::string* mutable_labels(int index);
  inline void set_labels(int index, const ::std::string& value);
  inline void set_labels(int index, const char* value);
  inline void set_labels(int index, const char* value, size_t size);
  inline ::std::string* add_labels();
  inline void add_labels(const ::std::string& value);
  inline void add_labels(const char* value);
  inline void add_labels(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // repeated string connections = 22;
  inline int connections_size() const;
  inline void clear_connections();
  static const int kConnectionsFieldNumber = 22;
  inline const ::std::string& connections(int index) const;
  inline ::std::string* mutable_connections(int index);
  inline void set_connections(int index, const ::std::string& value);
  inline void set_connections(int index, const char* value);
  inline void set_connections(int index, const char* value, size_t size);
  inline ::std::string* add_connections();
  inline void add_connections(const ::std::string& value);
  inline void add_connections(const char* value);
  inline void add_connections(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& connections() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_connections();

  // repeated .Proto.Uuid guids = 23;
  inline int guids_size() const;
  inline void clear_guids();
  static const int kGuidsFieldNumber = 23;
  inline const ::Proto::Uuid& guids(int index) const;
  inline ::Proto::Uuid* mutable_guids(int index);
  inline ::Proto::Uuid* add_guids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
      guids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
      mutable_guids();

  // @@protoc_insertion_point(class_scope:Proto.SchemaDetails)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_schemaid();
  inline void clear_has_schemaid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_excludedfrombuild();
  inline void clear_has_excludedfrombuild();
  inline void set_has_equipmentid();
  inline void clear_has_equipmentid();
  inline void set_has_lmdescriptionfile();
  inline void clear_has_lmdescriptionfile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* schemaid_;
  ::google::protobuf::int32 version_;
  bool excludedfrombuild_;
  ::std::string* caption_;
  ::std::string* equipmentid_;
  ::std::string* lmdescriptionfile_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signalids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  ::google::protobuf::RepeatedPtrField< ::std::string> connections_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Uuid > guids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaDetails* default_instance_;
};
// ===================================================================


// ===================================================================

// Uuid

// required bytes uuid = 1;
inline bool Uuid::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uuid::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uuid::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uuid::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Uuid::uuid() const {
  return *uuid_;
}
inline void Uuid::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Uuid::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Uuid::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Uuid::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Uuid::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Uuid::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// qvariant

// required int32 type = 1;
inline bool qvariant::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void qvariant::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void qvariant::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void qvariant::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 qvariant::type() const {
  return type_;
}
inline void qvariant::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 intValue = 2 [default = 0];
inline bool qvariant::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qvariant::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void qvariant::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void qvariant::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 qvariant::intvalue() const {
  return intvalue_;
}
inline void qvariant::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional uint32 uintValue = 3 [default = 0];
inline bool qvariant::has_uintvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qvariant::set_has_uintvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void qvariant::clear_has_uintvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void qvariant::clear_uintvalue() {
  uintvalue_ = 0u;
  clear_has_uintvalue();
}
inline ::google::protobuf::uint32 qvariant::uintvalue() const {
  return uintvalue_;
}
inline void qvariant::set_uintvalue(::google::protobuf::uint32 value) {
  set_has_uintvalue();
  uintvalue_ = value;
}

// optional double doubleValue = 4 [default = 0];
inline bool qvariant::has_doublevalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qvariant::set_has_doublevalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void qvariant::clear_has_doublevalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void qvariant::clear_doublevalue() {
  doublevalue_ = 0;
  clear_has_doublevalue();
}
inline double qvariant::doublevalue() const {
  return doublevalue_;
}
inline void qvariant::set_doublevalue(double value) {
  set_has_doublevalue();
  doublevalue_ = value;
}

// optional bool boolValue = 5 [default = false];
inline bool qvariant::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void qvariant::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void qvariant::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void qvariant::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool qvariant::boolvalue() const {
  return boolvalue_;
}
inline void qvariant::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// -------------------------------------------------------------------

// wstring

// required bytes text = 1;
inline bool wstring::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wstring::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wstring::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wstring::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& wstring::text() const {
  return *text_;
}
inline void wstring::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void wstring::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void wstring::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wstring::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* wstring::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void wstring::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FontParam

// required .Proto.wstring name_obsolete = 1;
inline bool FontParam::has_name_obsolete() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FontParam::set_has_name_obsolete() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FontParam::clear_has_name_obsolete() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FontParam::clear_name_obsolete() {
  if (name_obsolete_ != NULL) name_obsolete_->::Proto::wstring::Clear();
  clear_has_name_obsolete();
}
inline const ::Proto::wstring& FontParam::name_obsolete() const {
  return name_obsolete_ != NULL ? *name_obsolete_ : *default_instance_->name_obsolete_;
}
inline ::Proto::wstring* FontParam::mutable_name_obsolete() {
  set_has_name_obsolete();
  if (name_obsolete_ == NULL) name_obsolete_ = new ::Proto::wstring;
  return name_obsolete_;
}
inline ::Proto::wstring* FontParam::release_name_obsolete() {
  clear_has_name_obsolete();
  ::Proto::wstring* temp = name_obsolete_;
  name_obsolete_ = NULL;
  return temp;
}
inline void FontParam::set_allocated_name_obsolete(::Proto::wstring* name_obsolete) {
  delete name_obsolete_;
  name_obsolete_ = name_obsolete;
  if (name_obsolete) {
    set_has_name_obsolete();
  } else {
    clear_has_name_obsolete();
  }
}

// required double size = 2;
inline bool FontParam::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FontParam::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FontParam::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FontParam::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double FontParam::size() const {
  return size_;
}
inline void FontParam::set_size(double value) {
  set_has_size();
  size_ = value;
}

// required bool bold = 3;
inline bool FontParam::has_bold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FontParam::set_has_bold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FontParam::clear_has_bold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FontParam::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool FontParam::bold() const {
  return bold_;
}
inline void FontParam::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
}

// required bool italic = 4;
inline bool FontParam::has_italic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FontParam::set_has_italic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FontParam::clear_has_italic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FontParam::clear_italic() {
  italic_ = false;
  clear_has_italic();
}
inline bool FontParam::italic() const {
  return italic_;
}
inline void FontParam::set_italic(bool value) {
  set_has_italic();
  italic_ = value;
}

// optional string name = 5;
inline bool FontParam::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FontParam::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FontParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FontParam::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FontParam::name() const {
  return *name_;
}
inline void FontParam::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FontParam::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FontParam::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FontParam::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FontParam::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FontParam::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SchemaPoint

// required double x = 1;
inline bool SchemaPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SchemaPoint::x() const {
  return x_;
}
inline void SchemaPoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool SchemaPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SchemaPoint::y() const {
  return y_;
}
inline void SchemaPoint::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Envelope

// required uint32 classnamehash = 1;
inline bool Envelope::has_classnamehash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_classnamehash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_classnamehash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_classnamehash() {
  classnamehash_ = 0u;
  clear_has_classnamehash();
}
inline ::google::protobuf::uint32 Envelope::classnamehash() const {
  return classnamehash_;
}
inline void Envelope::set_classnamehash(::google::protobuf::uint32 value) {
  set_has_classnamehash();
  classnamehash_ = value;
}

// optional bytes compressedObject = 2;
inline bool Envelope::has_compressedobject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_compressedobject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_compressedobject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_compressedobject() {
  if (compressedobject_ != &::google::protobuf::internal::kEmptyString) {
    compressedobject_->clear();
  }
  clear_has_compressedobject();
}
inline const ::std::string& Envelope::compressedobject() const {
  return *compressedobject_;
}
inline void Envelope::set_compressedobject(const ::std::string& value) {
  set_has_compressedobject();
  if (compressedobject_ == &::google::protobuf::internal::kEmptyString) {
    compressedobject_ = new ::std::string;
  }
  compressedobject_->assign(value);
}
inline void Envelope::set_compressedobject(const char* value) {
  set_has_compressedobject();
  if (compressedobject_ == &::google::protobuf::internal::kEmptyString) {
    compressedobject_ = new ::std::string;
  }
  compressedobject_->assign(value);
}
inline void Envelope::set_compressedobject(const void* value, size_t size) {
  set_has_compressedobject();
  if (compressedobject_ == &::google::protobuf::internal::kEmptyString) {
    compressedobject_ = new ::std::string;
  }
  compressedobject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Envelope::mutable_compressedobject() {
  set_has_compressedobject();
  if (compressedobject_ == &::google::protobuf::internal::kEmptyString) {
    compressedobject_ = new ::std::string;
  }
  return compressedobject_;
}
inline ::std::string* Envelope::release_compressedobject() {
  clear_has_compressedobject();
  if (compressedobject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compressedobject_;
    compressedobject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Envelope::set_allocated_compressedobject(::std::string* compressedobject) {
  if (compressedobject_ != &::google::protobuf::internal::kEmptyString) {
    delete compressedobject_;
  }
  if (compressedobject) {
    set_has_compressedobject();
    compressedobject_ = compressedobject;
  } else {
    clear_has_compressedobject();
    compressedobject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Proto.SchemaItem schemaitem = 6;
inline bool Envelope::has_schemaitem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_schemaitem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_schemaitem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_schemaitem() {
  if (schemaitem_ != NULL) schemaitem_->::Proto::SchemaItem::Clear();
  clear_has_schemaitem();
}
inline const ::Proto::SchemaItem& Envelope::schemaitem() const {
  return schemaitem_ != NULL ? *schemaitem_ : *default_instance_->schemaitem_;
}
inline ::Proto::SchemaItem* Envelope::mutable_schemaitem() {
  set_has_schemaitem();
  if (schemaitem_ == NULL) schemaitem_ = new ::Proto::SchemaItem;
  return schemaitem_;
}
inline ::Proto::SchemaItem* Envelope::release_schemaitem() {
  clear_has_schemaitem();
  ::Proto::SchemaItem* temp = schemaitem_;
  schemaitem_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemaitem(::Proto::SchemaItem* schemaitem) {
  delete schemaitem_;
  schemaitem_ = schemaitem;
  if (schemaitem) {
    set_has_schemaitem();
  } else {
    clear_has_schemaitem();
  }
}

// optional .Proto.DeviceObject deviceobject = 7;
inline bool Envelope::has_deviceobject() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_deviceobject() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_deviceobject() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_deviceobject() {
  if (deviceobject_ != NULL) deviceobject_->::Proto::DeviceObject::Clear();
  clear_has_deviceobject();
}
inline const ::Proto::DeviceObject& Envelope::deviceobject() const {
  return deviceobject_ != NULL ? *deviceobject_ : *default_instance_->deviceobject_;
}
inline ::Proto::DeviceObject* Envelope::mutable_deviceobject() {
  set_has_deviceobject();
  if (deviceobject_ == NULL) deviceobject_ = new ::Proto::DeviceObject;
  return deviceobject_;
}
inline ::Proto::DeviceObject* Envelope::release_deviceobject() {
  clear_has_deviceobject();
  ::Proto::DeviceObject* temp = deviceobject_;
  deviceobject_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_deviceobject(::Proto::DeviceObject* deviceobject) {
  delete deviceobject_;
  deviceobject_ = deviceobject;
  if (deviceobject) {
    set_has_deviceobject();
  } else {
    clear_has_deviceobject();
  }
}

// optional .Proto.Schema schema = 100;
inline bool Envelope::has_schema() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Envelope::set_has_schema() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Envelope::clear_has_schema() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Envelope::clear_schema() {
  if (schema_ != NULL) schema_->::Proto::Schema::Clear();
  clear_has_schema();
}
inline const ::Proto::Schema& Envelope::schema() const {
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::Proto::Schema* Envelope::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::Proto::Schema;
  return schema_;
}
inline ::Proto::Schema* Envelope::release_schema() {
  clear_has_schema();
  ::Proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schema(::Proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
}

// optional .Proto.SchemaLayer schemalayer = 101;
inline bool Envelope::has_schemalayer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Envelope::set_has_schemalayer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Envelope::clear_has_schemalayer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Envelope::clear_schemalayer() {
  if (schemalayer_ != NULL) schemalayer_->::Proto::SchemaLayer::Clear();
  clear_has_schemalayer();
}
inline const ::Proto::SchemaLayer& Envelope::schemalayer() const {
  return schemalayer_ != NULL ? *schemalayer_ : *default_instance_->schemalayer_;
}
inline ::Proto::SchemaLayer* Envelope::mutable_schemalayer() {
  set_has_schemalayer();
  if (schemalayer_ == NULL) schemalayer_ = new ::Proto::SchemaLayer;
  return schemalayer_;
}
inline ::Proto::SchemaLayer* Envelope::release_schemalayer() {
  clear_has_schemalayer();
  ::Proto::SchemaLayer* temp = schemalayer_;
  schemalayer_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemalayer(::Proto::SchemaLayer* schemalayer) {
  delete schemalayer_;
  schemalayer_ = schemalayer;
  if (schemalayer) {
    set_has_schemalayer();
  } else {
    clear_has_schemalayer();
  }
}

// optional .Proto.FblElement fblelement = 102;
inline bool Envelope::has_fblelement() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Envelope::set_has_fblelement() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Envelope::clear_has_fblelement() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Envelope::clear_fblelement() {
  if (fblelement_ != NULL) fblelement_->::Proto::FblElement::Clear();
  clear_has_fblelement();
}
inline const ::Proto::FblElement& Envelope::fblelement() const {
  return fblelement_ != NULL ? *fblelement_ : *default_instance_->fblelement_;
}
inline ::Proto::FblElement* Envelope::mutable_fblelement() {
  set_has_fblelement();
  if (fblelement_ == NULL) fblelement_ = new ::Proto::FblElement;
  return fblelement_;
}
inline ::Proto::FblElement* Envelope::release_fblelement() {
  clear_has_fblelement();
  ::Proto::FblElement* temp = fblelement_;
  fblelement_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_fblelement(::Proto::FblElement* fblelement) {
  delete fblelement_;
  fblelement_ = fblelement;
  if (fblelement) {
    set_has_fblelement();
  } else {
    clear_has_fblelement();
  }
}

// optional .Proto.Configuration configuration = 103;
inline bool Envelope::has_configuration() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Envelope::set_has_configuration() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Envelope::clear_has_configuration() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Envelope::clear_configuration() {
  if (configuration_ != NULL) configuration_->::Proto::Configuration::Clear();
  clear_has_configuration();
}
inline const ::Proto::Configuration& Envelope::configuration() const {
  return configuration_ != NULL ? *configuration_ : *default_instance_->configuration_;
}
inline ::Proto::Configuration* Envelope::mutable_configuration() {
  set_has_configuration();
  if (configuration_ == NULL) configuration_ = new ::Proto::Configuration;
  return configuration_;
}
inline ::Proto::Configuration* Envelope::release_configuration() {
  clear_has_configuration();
  ::Proto::Configuration* temp = configuration_;
  configuration_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_configuration(::Proto::Configuration* configuration) {
  delete configuration_;
  configuration_ = configuration;
  if (configuration) {
    set_has_configuration();
  } else {
    clear_has_configuration();
  }
}

// optional .Proto.Connection connection = 104;
inline bool Envelope::has_connection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Envelope::set_has_connection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Envelope::clear_has_connection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Envelope::clear_connection() {
  if (connection_ != NULL) connection_->::Proto::Connection::Clear();
  clear_has_connection();
}
inline const ::Proto::Connection& Envelope::connection() const {
  return connection_ != NULL ? *connection_ : *default_instance_->connection_;
}
inline ::Proto::Connection* Envelope::mutable_connection() {
  set_has_connection();
  if (connection_ == NULL) connection_ = new ::Proto::Connection;
  return connection_;
}
inline ::Proto::Connection* Envelope::release_connection() {
  clear_has_connection();
  ::Proto::Connection* temp = connection_;
  connection_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_connection(::Proto::Connection* connection) {
  delete connection_;
  connection_ = connection;
  if (connection) {
    set_has_connection();
  } else {
    clear_has_connection();
  }
}

// optional .Proto.SchemaDetailsSet schemaDetailsSet = 105;
inline bool Envelope::has_schemadetailsset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Envelope::set_has_schemadetailsset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Envelope::clear_has_schemadetailsset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Envelope::clear_schemadetailsset() {
  if (schemadetailsset_ != NULL) schemadetailsset_->::Proto::SchemaDetailsSet::Clear();
  clear_has_schemadetailsset();
}
inline const ::Proto::SchemaDetailsSet& Envelope::schemadetailsset() const {
  return schemadetailsset_ != NULL ? *schemadetailsset_ : *default_instance_->schemadetailsset_;
}
inline ::Proto::SchemaDetailsSet* Envelope::mutable_schemadetailsset() {
  set_has_schemadetailsset();
  if (schemadetailsset_ == NULL) schemadetailsset_ = new ::Proto::SchemaDetailsSet;
  return schemadetailsset_;
}
inline ::Proto::SchemaDetailsSet* Envelope::release_schemadetailsset() {
  clear_has_schemadetailsset();
  ::Proto::SchemaDetailsSet* temp = schemadetailsset_;
  schemadetailsset_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemadetailsset(::Proto::SchemaDetailsSet* schemadetailsset) {
  delete schemadetailsset_;
  schemadetailsset_ = schemadetailsset;
  if (schemadetailsset) {
    set_has_schemadetailsset();
  } else {
    clear_has_schemadetailsset();
  }
}

// -------------------------------------------------------------------

// EnvelopeSet

// repeated .Proto.Envelope items = 1;
inline int EnvelopeSet::items_size() const {
  return items_.size();
}
inline void EnvelopeSet::clear_items() {
  items_.Clear();
}
inline const ::Proto::Envelope& EnvelopeSet::items(int index) const {
  return items_.Get(index);
}
inline ::Proto::Envelope* EnvelopeSet::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Proto::Envelope* EnvelopeSet::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
EnvelopeSet::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
EnvelopeSet::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// EnvelopeSetShortDescription

// optional uint32 projectdbversion = 1;
inline bool EnvelopeSetShortDescription::has_projectdbversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnvelopeSetShortDescription::set_has_projectdbversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnvelopeSetShortDescription::clear_has_projectdbversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnvelopeSetShortDescription::clear_projectdbversion() {
  projectdbversion_ = 0u;
  clear_has_projectdbversion();
}
inline ::google::protobuf::uint32 EnvelopeSetShortDescription::projectdbversion() const {
  return projectdbversion_;
}
inline void EnvelopeSetShortDescription::set_projectdbversion(::google::protobuf::uint32 value) {
  set_has_projectdbversion();
  projectdbversion_ = value;
}

// repeated uint32 classnamehash = 2;
inline int EnvelopeSetShortDescription::classnamehash_size() const {
  return classnamehash_.size();
}
inline void EnvelopeSetShortDescription::clear_classnamehash() {
  classnamehash_.Clear();
}
inline ::google::protobuf::uint32 EnvelopeSetShortDescription::classnamehash(int index) const {
  return classnamehash_.Get(index);
}
inline void EnvelopeSetShortDescription::set_classnamehash(int index, ::google::protobuf::uint32 value) {
  classnamehash_.Set(index, value);
}
inline void EnvelopeSetShortDescription::add_classnamehash(::google::protobuf::uint32 value) {
  classnamehash_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EnvelopeSetShortDescription::classnamehash() const {
  return classnamehash_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EnvelopeSetShortDescription::mutable_classnamehash() {
  return &classnamehash_;
}

// optional bool equipmentEditor = 3;
inline bool EnvelopeSetShortDescription::has_equipmenteditor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnvelopeSetShortDescription::set_has_equipmenteditor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnvelopeSetShortDescription::clear_has_equipmenteditor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnvelopeSetShortDescription::clear_equipmenteditor() {
  equipmenteditor_ = false;
  clear_has_equipmenteditor();
}
inline bool EnvelopeSetShortDescription::equipmenteditor() const {
  return equipmenteditor_;
}
inline void EnvelopeSetShortDescription::set_equipmenteditor(bool value) {
  set_has_equipmenteditor();
  equipmenteditor_ = value;
}

// optional bool presetEditor = 4;
inline bool EnvelopeSetShortDescription::has_preseteditor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnvelopeSetShortDescription::set_has_preseteditor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnvelopeSetShortDescription::clear_has_preseteditor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnvelopeSetShortDescription::clear_preseteditor() {
  preseteditor_ = false;
  clear_has_preseteditor();
}
inline bool EnvelopeSetShortDescription::preseteditor() const {
  return preseteditor_;
}
inline void EnvelopeSetShortDescription::set_preseteditor(bool value) {
  set_has_preseteditor();
  preseteditor_ = value;
}

// -------------------------------------------------------------------

// Configuration

// required .Proto.Uuid uuid = 1;
inline bool Configuration::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Configuration::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Configuration::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Configuration::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring strID = 2;
inline bool Configuration::has_strid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_strid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_strid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& Configuration::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* Configuration::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* Configuration::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool Configuration::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& Configuration::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* Configuration::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* Configuration::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.wstring variables = 4;
inline bool Configuration::has_variables() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_variables() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_variables() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_variables() {
  if (variables_ != NULL) variables_->::Proto::wstring::Clear();
  clear_has_variables();
}
inline const ::Proto::wstring& Configuration::variables() const {
  return variables_ != NULL ? *variables_ : *default_instance_->variables_;
}
inline ::Proto::wstring* Configuration::mutable_variables() {
  set_has_variables();
  if (variables_ == NULL) variables_ = new ::Proto::wstring;
  return variables_;
}
inline ::Proto::wstring* Configuration::release_variables() {
  clear_has_variables();
  ::Proto::wstring* temp = variables_;
  variables_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_variables(::Proto::wstring* variables) {
  delete variables_;
  variables_ = variables;
  if (variables) {
    set_has_variables();
  } else {
    clear_has_variables();
  }
}

// required .Proto.wstring globals = 5;
inline bool Configuration::has_globals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_globals() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_globals() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_globals() {
  if (globals_ != NULL) globals_->::Proto::wstring::Clear();
  clear_has_globals();
}
inline const ::Proto::wstring& Configuration::globals() const {
  return globals_ != NULL ? *globals_ : *default_instance_->globals_;
}
inline ::Proto::wstring* Configuration::mutable_globals() {
  set_has_globals();
  if (globals_ == NULL) globals_ = new ::Proto::wstring;
  return globals_;
}
inline ::Proto::wstring* Configuration::release_globals() {
  clear_has_globals();
  ::Proto::wstring* temp = globals_;
  globals_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_globals(::Proto::wstring* globals) {
  delete globals_;
  globals_ = globals;
  if (globals) {
    set_has_globals();
  } else {
    clear_has_globals();
  }
}

// repeated .Proto.Uuid schemasIDs = 100;
inline int Configuration::schemasids_size() const {
  return schemasids_.size();
}
inline void Configuration::clear_schemasids() {
  schemasids_.Clear();
}
inline const ::Proto::Uuid& Configuration::schemasids(int index) const {
  return schemasids_.Get(index);
}
inline ::Proto::Uuid* Configuration::mutable_schemasids(int index) {
  return schemasids_.Mutable(index);
}
inline ::Proto::Uuid* Configuration::add_schemasids() {
  return schemasids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
Configuration::schemasids() const {
  return schemasids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
Configuration::mutable_schemasids() {
  return &schemasids_;
}

// repeated .Proto.Envelope schemas = 101;
inline int Configuration::schemas_size() const {
  return schemas_.size();
}
inline void Configuration::clear_schemas() {
  schemas_.Clear();
}
inline const ::Proto::Envelope& Configuration::schemas(int index) const {
  return schemas_.Get(index);
}
inline ::Proto::Envelope* Configuration::mutable_schemas(int index) {
  return schemas_.Mutable(index);
}
inline ::Proto::Envelope* Configuration::add_schemas() {
  return schemas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
Configuration::schemas() const {
  return schemas_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
Configuration::mutable_schemas() {
  return &schemas_;
}

// -------------------------------------------------------------------

// AfbElementCollection

// repeated .Proto.AfbElementXml elements = 1;
inline int AfbElementCollection::elements_size() const {
  return elements_.size();
}
inline void AfbElementCollection::clear_elements() {
  elements_.Clear();
}
inline const ::Proto::AfbElementXml& AfbElementCollection::elements(int index) const {
  return elements_.Get(index);
}
inline ::Proto::AfbElementXml* AfbElementCollection::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::Proto::AfbElementXml* AfbElementCollection::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >&
AfbElementCollection::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >*
AfbElementCollection::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// AfbElementXml

// required bytes data = 1;
inline bool AfbElementXml::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbElementXml::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbElementXml::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbElementXml::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AfbElementXml::data() const {
  return *data_;
}
inline void AfbElementXml::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AfbElementXml::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AfbElementXml::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AfbElementXml::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AfbElementXml::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AfbElementXml::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FblElement

// required .Proto.wstring strID = 2;
inline bool FblElement::has_strid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblElement::set_has_strid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblElement::clear_has_strid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblElement::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& FblElement::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* FblElement::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* FblElement::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool FblElement::has_caption() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblElement::set_has_caption() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblElement::clear_has_caption() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblElement::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& FblElement::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* FblElement::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* FblElement::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required uint32 opcode = 4;
inline bool FblElement::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblElement::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblElement::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblElement::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 FblElement::opcode() const {
  return opcode_;
}
inline void FblElement::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
}

// optional bool hasRam = 5 [default = false];
inline bool FblElement::has_hasram() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblElement::set_has_hasram() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblElement::clear_has_hasram() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblElement::clear_hasram() {
  hasram_ = false;
  clear_has_hasram();
}
inline bool FblElement::hasram() const {
  return hasram_;
}
inline void FblElement::set_hasram(bool value) {
  set_has_hasram();
  hasram_ = value;
}

// optional bool requiredStart = 6 [default = true];
inline bool FblElement::has_requiredstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblElement::set_has_requiredstart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblElement::clear_has_requiredstart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblElement::clear_requiredstart() {
  requiredstart_ = true;
  clear_has_requiredstart();
}
inline bool FblElement::requiredstart() const {
  return requiredstart_;
}
inline void FblElement::set_requiredstart(bool value) {
  set_has_requiredstart();
  requiredstart_ = value;
}

// repeated .Proto.AfbSignal inputs = 11;
inline int FblElement::inputs_size() const {
  return inputs_.size();
}
inline void FblElement::clear_inputs() {
  inputs_.Clear();
}
inline const ::Proto::AfbSignal& FblElement::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::Proto::AfbSignal* FblElement::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::Proto::AfbSignal* FblElement::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
FblElement::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
FblElement::mutable_inputs() {
  return &inputs_;
}

// repeated .Proto.AfbSignal outputs = 12;
inline int FblElement::outputs_size() const {
  return outputs_.size();
}
inline void FblElement::clear_outputs() {
  outputs_.Clear();
}
inline const ::Proto::AfbSignal& FblElement::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::Proto::AfbSignal* FblElement::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::Proto::AfbSignal* FblElement::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
FblElement::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
FblElement::mutable_outputs() {
  return &outputs_;
}

// repeated .Proto.AfbParam params = 13;
inline int FblElement::params_size() const {
  return params_.size();
}
inline void FblElement::clear_params() {
  params_.Clear();
}
inline const ::Proto::AfbParam& FblElement::params(int index) const {
  return params_.Get(index);
}
inline ::Proto::AfbParam* FblElement::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Proto::AfbParam* FblElement::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
FblElement::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
FblElement::mutable_params() {
  return &params_;
}

// optional .Proto.wstring description = 14;
inline bool FblElement::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FblElement::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FblElement::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FblElement::clear_description() {
  if (description_ != NULL) description_->::Proto::wstring::Clear();
  clear_has_description();
}
inline const ::Proto::wstring& FblElement::description() const {
  return description_ != NULL ? *description_ : *default_instance_->description_;
}
inline ::Proto::wstring* FblElement::mutable_description() {
  set_has_description();
  if (description_ == NULL) description_ = new ::Proto::wstring;
  return description_;
}
inline ::Proto::wstring* FblElement::release_description() {
  clear_has_description();
  ::Proto::wstring* temp = description_;
  description_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_description(::Proto::wstring* description) {
  delete description_;
  description_ = description;
  if (description) {
    set_has_description();
  } else {
    clear_has_description();
  }
}

// -------------------------------------------------------------------

// AfbSignal

// required .Proto.wstring caption = 1;
inline bool AfbSignal::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbSignal::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbSignal::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbSignal::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& AfbSignal::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* AfbSignal::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* AfbSignal::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void AfbSignal::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.FblSignalType type = 2;
inline bool AfbSignal::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AfbSignal::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AfbSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AfbSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto::FblSignalType AfbSignal::type() const {
  return static_cast< ::Proto::FblSignalType >(type_);
}
inline void AfbSignal::set_type(::Proto::FblSignalType value) {
  assert(::Proto::FblSignalType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 operandIndex = 3 [default = 0];
inline bool AfbSignal::has_operandindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AfbSignal::set_has_operandindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AfbSignal::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AfbSignal::clear_operandindex() {
  operandindex_ = 0;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 AfbSignal::operandindex() const {
  return operandindex_;
}
inline void AfbSignal::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional int32 size = 4 [default = 0];
inline bool AfbSignal::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AfbSignal::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AfbSignal::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AfbSignal::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 AfbSignal::size() const {
  return size_;
}
inline void AfbSignal::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional .Proto.wstring opName = 5;
inline bool AfbSignal::has_opname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AfbSignal::set_has_opname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AfbSignal::clear_has_opname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AfbSignal::clear_opname() {
  if (opname_ != NULL) opname_->::Proto::wstring::Clear();
  clear_has_opname();
}
inline const ::Proto::wstring& AfbSignal::opname() const {
  return opname_ != NULL ? *opname_ : *default_instance_->opname_;
}
inline ::Proto::wstring* AfbSignal::mutable_opname() {
  set_has_opname();
  if (opname_ == NULL) opname_ = new ::Proto::wstring;
  return opname_;
}
inline ::Proto::wstring* AfbSignal::release_opname() {
  clear_has_opname();
  ::Proto::wstring* temp = opname_;
  opname_ = NULL;
  return temp;
}
inline void AfbSignal::set_allocated_opname(::Proto::wstring* opname) {
  delete opname_;
  opname_ = opname;
  if (opname) {
    set_has_opname();
  } else {
    clear_has_opname();
  }
}

// optional .Proto.FblDataFormat dataFormat = 6;
inline bool AfbSignal::has_dataformat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AfbSignal::set_has_dataformat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AfbSignal::clear_has_dataformat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AfbSignal::clear_dataformat() {
  dataformat_ = 0;
  clear_has_dataformat();
}
inline ::Proto::FblDataFormat AfbSignal::dataformat() const {
  return static_cast< ::Proto::FblDataFormat >(dataformat_);
}
inline void AfbSignal::set_dataformat(::Proto::FblDataFormat value) {
  assert(::Proto::FblDataFormat_IsValid(value));
  set_has_dataformat();
  dataformat_ = value;
}

// -------------------------------------------------------------------

// AfbParam

// required .Proto.wstring caption = 1;
inline bool AfbParam::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbParam::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbParam::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbParam::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& AfbParam::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* AfbParam::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* AfbParam::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required bool visible = 7;
inline bool AfbParam::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AfbParam::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AfbParam::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AfbParam::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool AfbParam::visible() const {
  return visible_;
}
inline void AfbParam::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional int32 operandIndex = 8 [default = 0];
inline bool AfbParam::has_operandindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AfbParam::set_has_operandindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AfbParam::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AfbParam::clear_operandindex() {
  operandindex_ = 0;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 AfbParam::operandindex() const {
  return operandindex_;
}
inline void AfbParam::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional int32 size = 9 [default = 0];
inline bool AfbParam::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AfbParam::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AfbParam::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AfbParam::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 AfbParam::size() const {
  return size_;
}
inline void AfbParam::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional bool instantiator = 10 [default = false];
inline bool AfbParam::has_instantiator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AfbParam::set_has_instantiator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AfbParam::clear_has_instantiator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AfbParam::clear_instantiator() {
  instantiator_ = false;
  clear_has_instantiator();
}
inline bool AfbParam::instantiator() const {
  return instantiator_;
}
inline void AfbParam::set_instantiator(bool value) {
  set_has_instantiator();
  instantiator_ = value;
}

// optional bool user = 11 [default = false];
inline bool AfbParam::has_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AfbParam::set_has_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AfbParam::clear_has_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AfbParam::clear_user() {
  user_ = false;
  clear_has_user();
}
inline bool AfbParam::user() const {
  return user_;
}
inline void AfbParam::set_user(bool value) {
  set_has_user();
  user_ = value;
}

// optional .Proto.wstring changedScript = 12;
inline bool AfbParam::has_changedscript() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AfbParam::set_has_changedscript() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AfbParam::clear_has_changedscript() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AfbParam::clear_changedscript() {
  if (changedscript_ != NULL) changedscript_->::Proto::wstring::Clear();
  clear_has_changedscript();
}
inline const ::Proto::wstring& AfbParam::changedscript() const {
  return changedscript_ != NULL ? *changedscript_ : *default_instance_->changedscript_;
}
inline ::Proto::wstring* AfbParam::mutable_changedscript() {
  set_has_changedscript();
  if (changedscript_ == NULL) changedscript_ = new ::Proto::wstring;
  return changedscript_;
}
inline ::Proto::wstring* AfbParam::release_changedscript() {
  clear_has_changedscript();
  ::Proto::wstring* temp = changedscript_;
  changedscript_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_changedscript(::Proto::wstring* changedscript) {
  delete changedscript_;
  changedscript_ = changedscript;
  if (changedscript) {
    set_has_changedscript();
  } else {
    clear_has_changedscript();
  }
}

// optional .Proto.qvariant value = 13;
inline bool AfbParam::has_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AfbParam::set_has_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AfbParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AfbParam::clear_value() {
  if (value_ != NULL) value_->::Proto::qvariant::Clear();
  clear_has_value();
}
inline const ::Proto::qvariant& AfbParam::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Proto::qvariant* AfbParam::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Proto::qvariant;
  return value_;
}
inline ::Proto::qvariant* AfbParam::release_value() {
  clear_has_value();
  ::Proto::qvariant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_value(::Proto::qvariant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional .Proto.qvariant defaultvalue = 14;
inline bool AfbParam::has_defaultvalue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AfbParam::set_has_defaultvalue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AfbParam::clear_has_defaultvalue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AfbParam::clear_defaultvalue() {
  if (defaultvalue_ != NULL) defaultvalue_->::Proto::qvariant::Clear();
  clear_has_defaultvalue();
}
inline const ::Proto::qvariant& AfbParam::defaultvalue() const {
  return defaultvalue_ != NULL ? *defaultvalue_ : *default_instance_->defaultvalue_;
}
inline ::Proto::qvariant* AfbParam::mutable_defaultvalue() {
  set_has_defaultvalue();
  if (defaultvalue_ == NULL) defaultvalue_ = new ::Proto::qvariant;
  return defaultvalue_;
}
inline ::Proto::qvariant* AfbParam::release_defaultvalue() {
  clear_has_defaultvalue();
  ::Proto::qvariant* temp = defaultvalue_;
  defaultvalue_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_defaultvalue(::Proto::qvariant* defaultvalue) {
  delete defaultvalue_;
  defaultvalue_ = defaultvalue;
  if (defaultvalue) {
    set_has_defaultvalue();
  } else {
    clear_has_defaultvalue();
  }
}

// optional .Proto.qvariant lowlimit = 15;
inline bool AfbParam::has_lowlimit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AfbParam::set_has_lowlimit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AfbParam::clear_has_lowlimit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AfbParam::clear_lowlimit() {
  if (lowlimit_ != NULL) lowlimit_->::Proto::qvariant::Clear();
  clear_has_lowlimit();
}
inline const ::Proto::qvariant& AfbParam::lowlimit() const {
  return lowlimit_ != NULL ? *lowlimit_ : *default_instance_->lowlimit_;
}
inline ::Proto::qvariant* AfbParam::mutable_lowlimit() {
  set_has_lowlimit();
  if (lowlimit_ == NULL) lowlimit_ = new ::Proto::qvariant;
  return lowlimit_;
}
inline ::Proto::qvariant* AfbParam::release_lowlimit() {
  clear_has_lowlimit();
  ::Proto::qvariant* temp = lowlimit_;
  lowlimit_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_lowlimit(::Proto::qvariant* lowlimit) {
  delete lowlimit_;
  lowlimit_ = lowlimit;
  if (lowlimit) {
    set_has_lowlimit();
  } else {
    clear_has_lowlimit();
  }
}

// optional .Proto.qvariant highlimit = 16;
inline bool AfbParam::has_highlimit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AfbParam::set_has_highlimit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AfbParam::clear_has_highlimit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AfbParam::clear_highlimit() {
  if (highlimit_ != NULL) highlimit_->::Proto::qvariant::Clear();
  clear_has_highlimit();
}
inline const ::Proto::qvariant& AfbParam::highlimit() const {
  return highlimit_ != NULL ? *highlimit_ : *default_instance_->highlimit_;
}
inline ::Proto::qvariant* AfbParam::mutable_highlimit() {
  set_has_highlimit();
  if (highlimit_ == NULL) highlimit_ = new ::Proto::qvariant;
  return highlimit_;
}
inline ::Proto::qvariant* AfbParam::release_highlimit() {
  clear_has_highlimit();
  ::Proto::qvariant* temp = highlimit_;
  highlimit_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_highlimit(::Proto::qvariant* highlimit) {
  delete highlimit_;
  highlimit_ = highlimit;
  if (highlimit) {
    set_has_highlimit();
  } else {
    clear_has_highlimit();
  }
}

// optional .Proto.wstring opName = 17;
inline bool AfbParam::has_opname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AfbParam::set_has_opname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AfbParam::clear_has_opname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AfbParam::clear_opname() {
  if (opname_ != NULL) opname_->::Proto::wstring::Clear();
  clear_has_opname();
}
inline const ::Proto::wstring& AfbParam::opname() const {
  return opname_ != NULL ? *opname_ : *default_instance_->opname_;
}
inline ::Proto::wstring* AfbParam::mutable_opname() {
  set_has_opname();
  if (opname_ == NULL) opname_ = new ::Proto::wstring;
  return opname_;
}
inline ::Proto::wstring* AfbParam::release_opname() {
  clear_has_opname();
  ::Proto::wstring* temp = opname_;
  opname_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_opname(::Proto::wstring* opname) {
  delete opname_;
  opname_ = opname;
  if (opname) {
    set_has_opname();
  } else {
    clear_has_opname();
  }
}

// optional .Proto.FblSignalType type = 18;
inline bool AfbParam::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AfbParam::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AfbParam::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AfbParam::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto::FblSignalType AfbParam::type() const {
  return static_cast< ::Proto::FblSignalType >(type_);
}
inline void AfbParam::set_type(::Proto::FblSignalType value) {
  assert(::Proto::FblSignalType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Proto.FblDataFormat dataFormat = 19;
inline bool AfbParam::has_dataformat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AfbParam::set_has_dataformat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AfbParam::clear_has_dataformat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AfbParam::clear_dataformat() {
  dataformat_ = 0;
  clear_has_dataformat();
}
inline ::Proto::FblDataFormat AfbParam::dataformat() const {
  return static_cast< ::Proto::FblDataFormat >(dataformat_);
}
inline void AfbParam::set_dataformat(::Proto::FblDataFormat value) {
  assert(::Proto::FblDataFormat_IsValid(value));
  set_has_dataformat();
  dataformat_ = value;
}

// -------------------------------------------------------------------

// Schema

// required .Proto.Uuid uuid = 1;
inline bool Schema::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Schema::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Schema::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Schema::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Schema::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Schema::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Schema::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Schema::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring schemaID = 2;
inline bool Schema::has_schemaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Schema::set_has_schemaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Schema::clear_has_schemaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Schema::clear_schemaid() {
  if (schemaid_ != NULL) schemaid_->::Proto::wstring::Clear();
  clear_has_schemaid();
}
inline const ::Proto::wstring& Schema::schemaid() const {
  return schemaid_ != NULL ? *schemaid_ : *default_instance_->schemaid_;
}
inline ::Proto::wstring* Schema::mutable_schemaid() {
  set_has_schemaid();
  if (schemaid_ == NULL) schemaid_ = new ::Proto::wstring;
  return schemaid_;
}
inline ::Proto::wstring* Schema::release_schemaid() {
  clear_has_schemaid();
  ::Proto::wstring* temp = schemaid_;
  schemaid_ = NULL;
  return temp;
}
inline void Schema::set_allocated_schemaid(::Proto::wstring* schemaid) {
  delete schemaid_;
  schemaid_ = schemaid;
  if (schemaid) {
    set_has_schemaid();
  } else {
    clear_has_schemaid();
  }
}

// required .Proto.wstring caption = 3;
inline bool Schema::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Schema::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Schema::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Schema::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& Schema::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* Schema::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* Schema::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void Schema::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required double width = 4;
inline bool Schema::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Schema::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Schema::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Schema::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double Schema::width() const {
  return width_;
}
inline void Schema::set_width(double value) {
  set_has_width();
  width_ = value;
}

// required double height = 5;
inline bool Schema::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Schema::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Schema::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Schema::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double Schema::height() const {
  return height_;
}
inline void Schema::set_height(double value) {
  set_has_height();
  height_ = value;
}

// required .Proto.SchemaUnit unit = 6;
inline bool Schema::has_unit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Schema::set_has_unit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Schema::clear_has_unit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Schema::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::Proto::SchemaUnit Schema::unit() const {
  return static_cast< ::Proto::SchemaUnit >(unit_);
}
inline void Schema::set_unit(::Proto::SchemaUnit value) {
  assert(::Proto::SchemaUnit_IsValid(value));
  set_has_unit();
  unit_ = value;
}

// optional bool excludeFromBuild = 7 [default = false];
inline bool Schema::has_excludefrombuild() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Schema::set_has_excludefrombuild() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Schema::clear_has_excludefrombuild() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Schema::clear_excludefrombuild() {
  excludefrombuild_ = false;
  clear_has_excludefrombuild();
}
inline bool Schema::excludefrombuild() const {
  return excludefrombuild_;
}
inline void Schema::set_excludefrombuild(bool value) {
  set_has_excludefrombuild();
  excludefrombuild_ = value;
}

// optional uint32 backgroundColor = 8;
inline bool Schema::has_backgroundcolor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Schema::set_has_backgroundcolor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Schema::clear_has_backgroundcolor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Schema::clear_backgroundcolor() {
  backgroundcolor_ = 0u;
  clear_has_backgroundcolor();
}
inline ::google::protobuf::uint32 Schema::backgroundcolor() const {
  return backgroundcolor_;
}
inline void Schema::set_backgroundcolor(::google::protobuf::uint32 value) {
  set_has_backgroundcolor();
  backgroundcolor_ = value;
}

// repeated .Proto.Envelope layers = 100;
inline int Schema::layers_size() const {
  return layers_.size();
}
inline void Schema::clear_layers() {
  layers_.Clear();
}
inline const ::Proto::Envelope& Schema::layers(int index) const {
  return layers_.Get(index);
}
inline ::Proto::Envelope* Schema::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::Proto::Envelope* Schema::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
Schema::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
Schema::mutable_layers() {
  return &layers_;
}

// required .Proto.AfbElementCollection afbs = 101;
inline bool Schema::has_afbs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Schema::set_has_afbs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Schema::clear_has_afbs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Schema::clear_afbs() {
  if (afbs_ != NULL) afbs_->::Proto::AfbElementCollection::Clear();
  clear_has_afbs();
}
inline const ::Proto::AfbElementCollection& Schema::afbs() const {
  return afbs_ != NULL ? *afbs_ : *default_instance_->afbs_;
}
inline ::Proto::AfbElementCollection* Schema::mutable_afbs() {
  set_has_afbs();
  if (afbs_ == NULL) afbs_ = new ::Proto::AfbElementCollection;
  return afbs_;
}
inline ::Proto::AfbElementCollection* Schema::release_afbs() {
  clear_has_afbs();
  ::Proto::AfbElementCollection* temp = afbs_;
  afbs_ = NULL;
  return temp;
}
inline void Schema::set_allocated_afbs(::Proto::AfbElementCollection* afbs) {
  delete afbs_;
  afbs_ = afbs;
  if (afbs) {
    set_has_afbs();
  } else {
    clear_has_afbs();
  }
}

// optional .Proto.LogicSchema logic_schema = 200;
inline bool Schema::has_logic_schema() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Schema::set_has_logic_schema() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Schema::clear_has_logic_schema() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Schema::clear_logic_schema() {
  if (logic_schema_ != NULL) logic_schema_->::Proto::LogicSchema::Clear();
  clear_has_logic_schema();
}
inline const ::Proto::LogicSchema& Schema::logic_schema() const {
  return logic_schema_ != NULL ? *logic_schema_ : *default_instance_->logic_schema_;
}
inline ::Proto::LogicSchema* Schema::mutable_logic_schema() {
  set_has_logic_schema();
  if (logic_schema_ == NULL) logic_schema_ = new ::Proto::LogicSchema;
  return logic_schema_;
}
inline ::Proto::LogicSchema* Schema::release_logic_schema() {
  clear_has_logic_schema();
  ::Proto::LogicSchema* temp = logic_schema_;
  logic_schema_ = NULL;
  return temp;
}
inline void Schema::set_allocated_logic_schema(::Proto::LogicSchema* logic_schema) {
  delete logic_schema_;
  logic_schema_ = logic_schema;
  if (logic_schema) {
    set_has_logic_schema();
  } else {
    clear_has_logic_schema();
  }
}

// optional .Proto.UfbSchema ufb_schema = 201;
inline bool Schema::has_ufb_schema() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Schema::set_has_ufb_schema() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Schema::clear_has_ufb_schema() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Schema::clear_ufb_schema() {
  if (ufb_schema_ != NULL) ufb_schema_->::Proto::UfbSchema::Clear();
  clear_has_ufb_schema();
}
inline const ::Proto::UfbSchema& Schema::ufb_schema() const {
  return ufb_schema_ != NULL ? *ufb_schema_ : *default_instance_->ufb_schema_;
}
inline ::Proto::UfbSchema* Schema::mutable_ufb_schema() {
  set_has_ufb_schema();
  if (ufb_schema_ == NULL) ufb_schema_ = new ::Proto::UfbSchema;
  return ufb_schema_;
}
inline ::Proto::UfbSchema* Schema::release_ufb_schema() {
  clear_has_ufb_schema();
  ::Proto::UfbSchema* temp = ufb_schema_;
  ufb_schema_ = NULL;
  return temp;
}
inline void Schema::set_allocated_ufb_schema(::Proto::UfbSchema* ufb_schema) {
  delete ufb_schema_;
  ufb_schema_ = ufb_schema;
  if (ufb_schema) {
    set_has_ufb_schema();
  } else {
    clear_has_ufb_schema();
  }
}

// -------------------------------------------------------------------

// LogicSchema

// repeated .Proto.wstring equipmentids = 1;
inline int LogicSchema::equipmentids_size() const {
  return equipmentids_.size();
}
inline void LogicSchema::clear_equipmentids() {
  equipmentids_.Clear();
}
inline const ::Proto::wstring& LogicSchema::equipmentids(int index) const {
  return equipmentids_.Get(index);
}
inline ::Proto::wstring* LogicSchema::mutable_equipmentids(int index) {
  return equipmentids_.Mutable(index);
}
inline ::Proto::wstring* LogicSchema::add_equipmentids() {
  return equipmentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
LogicSchema::equipmentids() const {
  return equipmentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
LogicSchema::mutable_equipmentids() {
  return &equipmentids_;
}

// optional int32 counter = 2 [default = 0];
inline bool LogicSchema::has_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicSchema::set_has_counter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicSchema::clear_has_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicSchema::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 LogicSchema::counter() const {
  return counter_;
}
inline void LogicSchema::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
}

// optional string lmDescriptionFile = 3 [default = "LogicModule0000.xml"];
inline bool LogicSchema::has_lmdescriptionfile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicSchema::set_has_lmdescriptionfile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicSchema::clear_has_lmdescriptionfile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicSchema::clear_lmdescriptionfile() {
  if (lmdescriptionfile_ != _default_lmdescriptionfile_) {
    lmdescriptionfile_->assign(*_default_lmdescriptionfile_);
  }
  clear_has_lmdescriptionfile();
}
inline const ::std::string& LogicSchema::lmdescriptionfile() const {
  return *lmdescriptionfile_;
}
inline void LogicSchema::set_lmdescriptionfile(const ::std::string& value) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(value);
}
inline void LogicSchema::set_lmdescriptionfile(const char* value) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(value);
}
inline void LogicSchema::set_lmdescriptionfile(const char* value, size_t size) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicSchema::mutable_lmdescriptionfile() {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string(*_default_lmdescriptionfile_);
  }
  return lmdescriptionfile_;
}
inline ::std::string* LogicSchema::release_lmdescriptionfile() {
  clear_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    return NULL;
  } else {
    ::std::string* temp = lmdescriptionfile_;
    lmdescriptionfile_ = const_cast< ::std::string*>(_default_lmdescriptionfile_);
    return temp;
  }
}
inline void LogicSchema::set_allocated_lmdescriptionfile(::std::string* lmdescriptionfile) {
  if (lmdescriptionfile_ != _default_lmdescriptionfile_) {
    delete lmdescriptionfile_;
  }
  if (lmdescriptionfile) {
    set_has_lmdescriptionfile();
    lmdescriptionfile_ = lmdescriptionfile;
  } else {
    clear_has_lmdescriptionfile();
    lmdescriptionfile_ = const_cast< ::std::string*>(_default_lmdescriptionfile_);
  }
}

// -------------------------------------------------------------------

// UfbSchema

// optional string description = 1;
inline bool UfbSchema::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UfbSchema::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UfbSchema::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UfbSchema::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& UfbSchema::description() const {
  return *description_;
}
inline void UfbSchema::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void UfbSchema::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void UfbSchema::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UfbSchema::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* UfbSchema::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UfbSchema::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 version = 2 [default = 1];
inline bool UfbSchema::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UfbSchema::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UfbSchema::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UfbSchema::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 UfbSchema::version() const {
  return version_;
}
inline void UfbSchema::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string lmDescriptionFile = 3 [default = "LogicModule0000.xml"];
inline bool UfbSchema::has_lmdescriptionfile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UfbSchema::set_has_lmdescriptionfile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UfbSchema::clear_has_lmdescriptionfile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UfbSchema::clear_lmdescriptionfile() {
  if (lmdescriptionfile_ != _default_lmdescriptionfile_) {
    lmdescriptionfile_->assign(*_default_lmdescriptionfile_);
  }
  clear_has_lmdescriptionfile();
}
inline const ::std::string& UfbSchema::lmdescriptionfile() const {
  return *lmdescriptionfile_;
}
inline void UfbSchema::set_lmdescriptionfile(const ::std::string& value) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(value);
}
inline void UfbSchema::set_lmdescriptionfile(const char* value) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(value);
}
inline void UfbSchema::set_lmdescriptionfile(const char* value, size_t size) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UfbSchema::mutable_lmdescriptionfile() {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    lmdescriptionfile_ = new ::std::string(*_default_lmdescriptionfile_);
  }
  return lmdescriptionfile_;
}
inline ::std::string* UfbSchema::release_lmdescriptionfile() {
  clear_has_lmdescriptionfile();
  if (lmdescriptionfile_ == _default_lmdescriptionfile_) {
    return NULL;
  } else {
    ::std::string* temp = lmdescriptionfile_;
    lmdescriptionfile_ = const_cast< ::std::string*>(_default_lmdescriptionfile_);
    return temp;
  }
}
inline void UfbSchema::set_allocated_lmdescriptionfile(::std::string* lmdescriptionfile) {
  if (lmdescriptionfile_ != _default_lmdescriptionfile_) {
    delete lmdescriptionfile_;
  }
  if (lmdescriptionfile) {
    set_has_lmdescriptionfile();
    lmdescriptionfile_ = lmdescriptionfile;
  } else {
    clear_has_lmdescriptionfile();
    lmdescriptionfile_ = const_cast< ::std::string*>(_default_lmdescriptionfile_);
  }
}

// -------------------------------------------------------------------

// SchemaLayer

// required .Proto.Uuid uuid = 1;
inline bool SchemaLayer::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaLayer::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaLayer::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaLayer::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& SchemaLayer::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* SchemaLayer::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* SchemaLayer::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void SchemaLayer::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring name = 2;
inline bool SchemaLayer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaLayer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaLayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaLayer::clear_name() {
  if (name_ != NULL) name_->::Proto::wstring::Clear();
  clear_has_name();
}
inline const ::Proto::wstring& SchemaLayer::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::Proto::wstring* SchemaLayer::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::Proto::wstring;
  return name_;
}
inline ::Proto::wstring* SchemaLayer::release_name() {
  clear_has_name();
  ::Proto::wstring* temp = name_;
  name_ = NULL;
  return temp;
}
inline void SchemaLayer::set_allocated_name(::Proto::wstring* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// required bool compile = 3;
inline bool SchemaLayer::has_compile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaLayer::set_has_compile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaLayer::clear_has_compile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaLayer::clear_compile() {
  compile_ = false;
  clear_has_compile();
}
inline bool SchemaLayer::compile() const {
  return compile_;
}
inline void SchemaLayer::set_compile(bool value) {
  set_has_compile();
  compile_ = value;
}

// required bool show = 4;
inline bool SchemaLayer::has_show() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaLayer::set_has_show() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaLayer::clear_has_show() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaLayer::clear_show() {
  show_ = false;
  clear_has_show();
}
inline bool SchemaLayer::show() const {
  return show_;
}
inline void SchemaLayer::set_show(bool value) {
  set_has_show();
  show_ = value;
}

// required bool print = 5;
inline bool SchemaLayer::has_print() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaLayer::set_has_print() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaLayer::clear_has_print() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaLayer::clear_print() {
  print_ = false;
  clear_has_print();
}
inline bool SchemaLayer::print() const {
  return print_;
}
inline void SchemaLayer::set_print(bool value) {
  set_has_print();
  print_ = value;
}

// repeated .Proto.Envelope items = 15;
inline int SchemaLayer::items_size() const {
  return items_.size();
}
inline void SchemaLayer::clear_items() {
  items_.Clear();
}
inline const ::Proto::Envelope& SchemaLayer::items(int index) const {
  return items_.Get(index);
}
inline ::Proto::Envelope* SchemaLayer::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Proto::Envelope* SchemaLayer::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
SchemaLayer::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
SchemaLayer::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// SchemaItem

// required .Proto.Uuid uuid = 1;
inline bool SchemaItem::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItem::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItem::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItem::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& SchemaItem::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* SchemaItem::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* SchemaItem::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required bool isStatic = 2;
inline bool SchemaItem::has_isstatic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItem::set_has_isstatic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItem::clear_has_isstatic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItem::clear_isstatic() {
  isstatic_ = false;
  clear_has_isstatic();
}
inline bool SchemaItem::isstatic() const {
  return isstatic_;
}
inline void SchemaItem::set_isstatic(bool value) {
  set_has_isstatic();
  isstatic_ = value;
}

// required bool isLocked = 3;
inline bool SchemaItem::has_islocked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItem::set_has_islocked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItem::clear_has_islocked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItem::clear_islocked() {
  islocked_ = false;
  clear_has_islocked();
}
inline bool SchemaItem::islocked() const {
  return islocked_;
}
inline void SchemaItem::set_islocked(bool value) {
  set_has_islocked();
  islocked_ = value;
}

// required .Proto.SchemaUnit itemUnit = 4;
inline bool SchemaItem::has_itemunit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItem::set_has_itemunit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItem::clear_has_itemunit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItem::clear_itemunit() {
  itemunit_ = 0;
  clear_has_itemunit();
}
inline ::Proto::SchemaUnit SchemaItem::itemunit() const {
  return static_cast< ::Proto::SchemaUnit >(itemunit_);
}
inline void SchemaItem::set_itemunit(::Proto::SchemaUnit value) {
  assert(::Proto::SchemaUnit_IsValid(value));
  set_has_itemunit();
  itemunit_ = value;
}

// optional bool acceptClick = 5 [default = false];
inline bool SchemaItem::has_acceptclick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItem::set_has_acceptclick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItem::clear_has_acceptclick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItem::clear_acceptclick() {
  acceptclick_ = false;
  clear_has_acceptclick();
}
inline bool SchemaItem::acceptclick() const {
  return acceptclick_;
}
inline void SchemaItem::set_acceptclick(bool value) {
  set_has_acceptclick();
  acceptclick_ = value;
}

// optional string clickScript = 7;
inline bool SchemaItem::has_clickscript() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItem::set_has_clickscript() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItem::clear_has_clickscript() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItem::clear_clickscript() {
  if (clickscript_ != &::google::protobuf::internal::kEmptyString) {
    clickscript_->clear();
  }
  clear_has_clickscript();
}
inline const ::std::string& SchemaItem::clickscript() const {
  return *clickscript_;
}
inline void SchemaItem::set_clickscript(const ::std::string& value) {
  set_has_clickscript();
  if (clickscript_ == &::google::protobuf::internal::kEmptyString) {
    clickscript_ = new ::std::string;
  }
  clickscript_->assign(value);
}
inline void SchemaItem::set_clickscript(const char* value) {
  set_has_clickscript();
  if (clickscript_ == &::google::protobuf::internal::kEmptyString) {
    clickscript_ = new ::std::string;
  }
  clickscript_->assign(value);
}
inline void SchemaItem::set_clickscript(const char* value, size_t size) {
  set_has_clickscript();
  if (clickscript_ == &::google::protobuf::internal::kEmptyString) {
    clickscript_ = new ::std::string;
  }
  clickscript_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItem::mutable_clickscript() {
  set_has_clickscript();
  if (clickscript_ == &::google::protobuf::internal::kEmptyString) {
    clickscript_ = new ::std::string;
  }
  return clickscript_;
}
inline ::std::string* SchemaItem::release_clickscript() {
  clear_has_clickscript();
  if (clickscript_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clickscript_;
    clickscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItem::set_allocated_clickscript(::std::string* clickscript) {
  if (clickscript_ != &::google::protobuf::internal::kEmptyString) {
    delete clickscript_;
  }
  if (clickscript) {
    set_has_clickscript();
    clickscript_ = clickscript;
  } else {
    clear_has_clickscript();
    clickscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isCommented = 8 [default = false];
inline bool SchemaItem::has_iscommented() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItem::set_has_iscommented() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItem::clear_has_iscommented() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItem::clear_iscommented() {
  iscommented_ = false;
  clear_has_iscommented();
}
inline bool SchemaItem::iscommented() const {
  return iscommented_;
}
inline void SchemaItem::set_iscommented(bool value) {
  set_has_iscommented();
  iscommented_ = value;
}

// optional string objectName = 9;
inline bool SchemaItem::has_objectname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItem::set_has_objectname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItem::clear_has_objectname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItem::clear_objectname() {
  if (objectname_ != &::google::protobuf::internal::kEmptyString) {
    objectname_->clear();
  }
  clear_has_objectname();
}
inline const ::std::string& SchemaItem::objectname() const {
  return *objectname_;
}
inline void SchemaItem::set_objectname(const ::std::string& value) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(value);
}
inline void SchemaItem::set_objectname(const char* value) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(value);
}
inline void SchemaItem::set_objectname(const char* value, size_t size) {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  objectname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItem::mutable_objectname() {
  set_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    objectname_ = new ::std::string;
  }
  return objectname_;
}
inline ::std::string* SchemaItem::release_objectname() {
  clear_has_objectname();
  if (objectname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objectname_;
    objectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItem::set_allocated_objectname(::std::string* objectname) {
  if (objectname_ != &::google::protobuf::internal::kEmptyString) {
    delete objectname_;
  }
  if (objectname) {
    set_has_objectname();
    objectname_ = objectname;
  } else {
    clear_has_objectname();
    objectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string preDrawScript = 30;
inline bool SchemaItem::has_predrawscript() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItem::set_has_predrawscript() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItem::clear_has_predrawscript() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItem::clear_predrawscript() {
  if (predrawscript_ != &::google::protobuf::internal::kEmptyString) {
    predrawscript_->clear();
  }
  clear_has_predrawscript();
}
inline const ::std::string& SchemaItem::predrawscript() const {
  return *predrawscript_;
}
inline void SchemaItem::set_predrawscript(const ::std::string& value) {
  set_has_predrawscript();
  if (predrawscript_ == &::google::protobuf::internal::kEmptyString) {
    predrawscript_ = new ::std::string;
  }
  predrawscript_->assign(value);
}
inline void SchemaItem::set_predrawscript(const char* value) {
  set_has_predrawscript();
  if (predrawscript_ == &::google::protobuf::internal::kEmptyString) {
    predrawscript_ = new ::std::string;
  }
  predrawscript_->assign(value);
}
inline void SchemaItem::set_predrawscript(const char* value, size_t size) {
  set_has_predrawscript();
  if (predrawscript_ == &::google::protobuf::internal::kEmptyString) {
    predrawscript_ = new ::std::string;
  }
  predrawscript_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItem::mutable_predrawscript() {
  set_has_predrawscript();
  if (predrawscript_ == &::google::protobuf::internal::kEmptyString) {
    predrawscript_ = new ::std::string;
  }
  return predrawscript_;
}
inline ::std::string* SchemaItem::release_predrawscript() {
  clear_has_predrawscript();
  if (predrawscript_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = predrawscript_;
    predrawscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItem::set_allocated_predrawscript(::std::string* predrawscript) {
  if (predrawscript_ != &::google::protobuf::internal::kEmptyString) {
    delete predrawscript_;
  }
  if (predrawscript) {
    set_has_predrawscript();
    predrawscript_ = predrawscript;
  } else {
    clear_has_predrawscript();
    predrawscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Proto.PosRectImpl PosRectImpl = 10;
inline bool SchemaItem::has_posrectimpl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItem::set_has_posrectimpl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItem::clear_has_posrectimpl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItem::clear_posrectimpl() {
  if (posrectimpl_ != NULL) posrectimpl_->::Proto::PosRectImpl::Clear();
  clear_has_posrectimpl();
}
inline const ::Proto::PosRectImpl& SchemaItem::posrectimpl() const {
  return posrectimpl_ != NULL ? *posrectimpl_ : *default_instance_->posrectimpl_;
}
inline ::Proto::PosRectImpl* SchemaItem::mutable_posrectimpl() {
  set_has_posrectimpl();
  if (posrectimpl_ == NULL) posrectimpl_ = new ::Proto::PosRectImpl;
  return posrectimpl_;
}
inline ::Proto::PosRectImpl* SchemaItem::release_posrectimpl() {
  clear_has_posrectimpl();
  ::Proto::PosRectImpl* temp = posrectimpl_;
  posrectimpl_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_posrectimpl(::Proto::PosRectImpl* posrectimpl) {
  delete posrectimpl_;
  posrectimpl_ = posrectimpl;
  if (posrectimpl) {
    set_has_posrectimpl();
  } else {
    clear_has_posrectimpl();
  }
}

// optional .Proto.PosLineImpl PosLineImpl = 11;
inline bool SchemaItem::has_poslineimpl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SchemaItem::set_has_poslineimpl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SchemaItem::clear_has_poslineimpl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SchemaItem::clear_poslineimpl() {
  if (poslineimpl_ != NULL) poslineimpl_->::Proto::PosLineImpl::Clear();
  clear_has_poslineimpl();
}
inline const ::Proto::PosLineImpl& SchemaItem::poslineimpl() const {
  return poslineimpl_ != NULL ? *poslineimpl_ : *default_instance_->poslineimpl_;
}
inline ::Proto::PosLineImpl* SchemaItem::mutable_poslineimpl() {
  set_has_poslineimpl();
  if (poslineimpl_ == NULL) poslineimpl_ = new ::Proto::PosLineImpl;
  return poslineimpl_;
}
inline ::Proto::PosLineImpl* SchemaItem::release_poslineimpl() {
  clear_has_poslineimpl();
  ::Proto::PosLineImpl* temp = poslineimpl_;
  poslineimpl_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_poslineimpl(::Proto::PosLineImpl* poslineimpl) {
  delete poslineimpl_;
  poslineimpl_ = poslineimpl;
  if (poslineimpl) {
    set_has_poslineimpl();
  } else {
    clear_has_poslineimpl();
  }
}

// optional .Proto.PosConnectionImpl PosConnectionImpl = 12;
inline bool SchemaItem::has_posconnectionimpl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SchemaItem::set_has_posconnectionimpl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SchemaItem::clear_has_posconnectionimpl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SchemaItem::clear_posconnectionimpl() {
  if (posconnectionimpl_ != NULL) posconnectionimpl_->::Proto::PosConnectionImpl::Clear();
  clear_has_posconnectionimpl();
}
inline const ::Proto::PosConnectionImpl& SchemaItem::posconnectionimpl() const {
  return posconnectionimpl_ != NULL ? *posconnectionimpl_ : *default_instance_->posconnectionimpl_;
}
inline ::Proto::PosConnectionImpl* SchemaItem::mutable_posconnectionimpl() {
  set_has_posconnectionimpl();
  if (posconnectionimpl_ == NULL) posconnectionimpl_ = new ::Proto::PosConnectionImpl;
  return posconnectionimpl_;
}
inline ::Proto::PosConnectionImpl* SchemaItem::release_posconnectionimpl() {
  clear_has_posconnectionimpl();
  ::Proto::PosConnectionImpl* temp = posconnectionimpl_;
  posconnectionimpl_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_posconnectionimpl(::Proto::PosConnectionImpl* posconnectionimpl) {
  delete posconnectionimpl_;
  posconnectionimpl_ = posconnectionimpl;
  if (posconnectionimpl) {
    set_has_posconnectionimpl();
  } else {
    clear_has_posconnectionimpl();
  }
}

// optional .Proto.FblItem FblItem = 106;
inline bool SchemaItem::has_fblitem() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SchemaItem::set_has_fblitem() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SchemaItem::clear_has_fblitem() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SchemaItem::clear_fblitem() {
  if (fblitem_ != NULL) fblitem_->::Proto::FblItem::Clear();
  clear_has_fblitem();
}
inline const ::Proto::FblItem& SchemaItem::fblitem() const {
  return fblitem_ != NULL ? *fblitem_ : *default_instance_->fblitem_;
}
inline ::Proto::FblItem* SchemaItem::mutable_fblitem() {
  set_has_fblitem();
  if (fblitem_ == NULL) fblitem_ = new ::Proto::FblItem;
  return fblitem_;
}
inline ::Proto::FblItem* SchemaItem::release_fblitem() {
  clear_has_fblitem();
  ::Proto::FblItem* temp = fblitem_;
  fblitem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_fblitem(::Proto::FblItem* fblitem) {
  delete fblitem_;
  fblitem_ = fblitem;
  if (fblitem) {
    set_has_fblitem();
  } else {
    clear_has_fblitem();
  }
}

// optional .Proto.FblItemRect FblItemRect = 107;
inline bool SchemaItem::has_fblitemrect() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SchemaItem::set_has_fblitemrect() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SchemaItem::clear_has_fblitemrect() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SchemaItem::clear_fblitemrect() {
  if (fblitemrect_ != NULL) fblitemrect_->::Proto::FblItemRect::Clear();
  clear_has_fblitemrect();
}
inline const ::Proto::FblItemRect& SchemaItem::fblitemrect() const {
  return fblitemrect_ != NULL ? *fblitemrect_ : *default_instance_->fblitemrect_;
}
inline ::Proto::FblItemRect* SchemaItem::mutable_fblitemrect() {
  set_has_fblitemrect();
  if (fblitemrect_ == NULL) fblitemrect_ = new ::Proto::FblItemRect;
  return fblitemrect_;
}
inline ::Proto::FblItemRect* SchemaItem::release_fblitemrect() {
  clear_has_fblitemrect();
  ::Proto::FblItemRect* temp = fblitemrect_;
  fblitemrect_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_fblitemrect(::Proto::FblItemRect* fblitemrect) {
  delete fblitemrect_;
  fblitemrect_ = fblitemrect;
  if (fblitemrect) {
    set_has_fblitemrect();
  } else {
    clear_has_fblitemrect();
  }
}

// optional .Proto.FblItemLine FblItemLine = 108;
inline bool SchemaItem::has_fblitemline() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SchemaItem::set_has_fblitemline() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SchemaItem::clear_has_fblitemline() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SchemaItem::clear_fblitemline() {
  if (fblitemline_ != NULL) fblitemline_->::Proto::FblItemLine::Clear();
  clear_has_fblitemline();
}
inline const ::Proto::FblItemLine& SchemaItem::fblitemline() const {
  return fblitemline_ != NULL ? *fblitemline_ : *default_instance_->fblitemline_;
}
inline ::Proto::FblItemLine* SchemaItem::mutable_fblitemline() {
  set_has_fblitemline();
  if (fblitemline_ == NULL) fblitemline_ = new ::Proto::FblItemLine;
  return fblitemline_;
}
inline ::Proto::FblItemLine* SchemaItem::release_fblitemline() {
  clear_has_fblitemline();
  ::Proto::FblItemLine* temp = fblitemline_;
  fblitemline_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_fblitemline(::Proto::FblItemLine* fblitemline) {
  delete fblitemline_;
  fblitemline_ = fblitemline;
  if (fblitemline) {
    set_has_fblitemline();
  } else {
    clear_has_fblitemline();
  }
}

// optional .Proto.SchemaItemRect Rect = 116;
inline bool SchemaItem::has_rect() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SchemaItem::set_has_rect() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SchemaItem::clear_has_rect() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SchemaItem::clear_rect() {
  if (rect_ != NULL) rect_->::Proto::SchemaItemRect::Clear();
  clear_has_rect();
}
inline const ::Proto::SchemaItemRect& SchemaItem::rect() const {
  return rect_ != NULL ? *rect_ : *default_instance_->rect_;
}
inline ::Proto::SchemaItemRect* SchemaItem::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) rect_ = new ::Proto::SchemaItemRect;
  return rect_;
}
inline ::Proto::SchemaItemRect* SchemaItem::release_rect() {
  clear_has_rect();
  ::Proto::SchemaItemRect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_rect(::Proto::SchemaItemRect* rect) {
  delete rect_;
  rect_ = rect;
  if (rect) {
    set_has_rect();
  } else {
    clear_has_rect();
  }
}

// optional .Proto.SchemaItemLine Line = 117;
inline bool SchemaItem::has_line() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SchemaItem::set_has_line() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SchemaItem::clear_has_line() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SchemaItem::clear_line() {
  if (line_ != NULL) line_->::Proto::SchemaItemLine::Clear();
  clear_has_line();
}
inline const ::Proto::SchemaItemLine& SchemaItem::line() const {
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::Proto::SchemaItemLine* SchemaItem::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::Proto::SchemaItemLine;
  return line_;
}
inline ::Proto::SchemaItemLine* SchemaItem::release_line() {
  clear_has_line();
  ::Proto::SchemaItemLine* temp = line_;
  line_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_line(::Proto::SchemaItemLine* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
}

// optional .Proto.SchemaItemPath Path = 118;
inline bool SchemaItem::has_path() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SchemaItem::set_has_path() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SchemaItem::clear_has_path() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SchemaItem::clear_path() {
  if (path_ != NULL) path_->::Proto::SchemaItemPath::Clear();
  clear_has_path();
}
inline const ::Proto::SchemaItemPath& SchemaItem::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::Proto::SchemaItemPath* SchemaItem::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::Proto::SchemaItemPath;
  return path_;
}
inline ::Proto::SchemaItemPath* SchemaItem::release_path() {
  clear_has_path();
  ::Proto::SchemaItemPath* temp = path_;
  path_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_path(::Proto::SchemaItemPath* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
}

// optional .Proto.SchemaItemSignal Signal = 124;
inline bool SchemaItem::has_signal() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SchemaItem::set_has_signal() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SchemaItem::clear_has_signal() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SchemaItem::clear_signal() {
  if (signal_ != NULL) signal_->::Proto::SchemaItemSignal::Clear();
  clear_has_signal();
}
inline const ::Proto::SchemaItemSignal& SchemaItem::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Proto::SchemaItemSignal* SchemaItem::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Proto::SchemaItemSignal;
  return signal_;
}
inline ::Proto::SchemaItemSignal* SchemaItem::release_signal() {
  clear_has_signal();
  ::Proto::SchemaItemSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_signal(::Proto::SchemaItemSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Proto.SchemaItemInput InputSignal = 125;
inline bool SchemaItem::has_inputsignal() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SchemaItem::set_has_inputsignal() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SchemaItem::clear_has_inputsignal() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SchemaItem::clear_inputsignal() {
  if (inputsignal_ != NULL) inputsignal_->::Proto::SchemaItemInput::Clear();
  clear_has_inputsignal();
}
inline const ::Proto::SchemaItemInput& SchemaItem::inputsignal() const {
  return inputsignal_ != NULL ? *inputsignal_ : *default_instance_->inputsignal_;
}
inline ::Proto::SchemaItemInput* SchemaItem::mutable_inputsignal() {
  set_has_inputsignal();
  if (inputsignal_ == NULL) inputsignal_ = new ::Proto::SchemaItemInput;
  return inputsignal_;
}
inline ::Proto::SchemaItemInput* SchemaItem::release_inputsignal() {
  clear_has_inputsignal();
  ::Proto::SchemaItemInput* temp = inputsignal_;
  inputsignal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_inputsignal(::Proto::SchemaItemInput* inputsignal) {
  delete inputsignal_;
  inputsignal_ = inputsignal;
  if (inputsignal) {
    set_has_inputsignal();
  } else {
    clear_has_inputsignal();
  }
}

// optional .Proto.SchemaItemOutput OutputSignal = 126;
inline bool SchemaItem::has_outputsignal() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SchemaItem::set_has_outputsignal() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SchemaItem::clear_has_outputsignal() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SchemaItem::clear_outputsignal() {
  if (outputsignal_ != NULL) outputsignal_->::Proto::SchemaItemOutput::Clear();
  clear_has_outputsignal();
}
inline const ::Proto::SchemaItemOutput& SchemaItem::outputsignal() const {
  return outputsignal_ != NULL ? *outputsignal_ : *default_instance_->outputsignal_;
}
inline ::Proto::SchemaItemOutput* SchemaItem::mutable_outputsignal() {
  set_has_outputsignal();
  if (outputsignal_ == NULL) outputsignal_ = new ::Proto::SchemaItemOutput;
  return outputsignal_;
}
inline ::Proto::SchemaItemOutput* SchemaItem::release_outputsignal() {
  clear_has_outputsignal();
  ::Proto::SchemaItemOutput* temp = outputsignal_;
  outputsignal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_outputsignal(::Proto::SchemaItemOutput* outputsignal) {
  delete outputsignal_;
  outputsignal_ = outputsignal;
  if (outputsignal) {
    set_has_outputsignal();
  } else {
    clear_has_outputsignal();
  }
}

// optional .Proto.SchemaItemLink Link = 127;
inline bool SchemaItem::has_link() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SchemaItem::set_has_link() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SchemaItem::clear_has_link() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SchemaItem::clear_link() {
  if (link_ != NULL) link_->::Proto::SchemaItemLink::Clear();
  clear_has_link();
}
inline const ::Proto::SchemaItemLink& SchemaItem::link() const {
  return link_ != NULL ? *link_ : *default_instance_->link_;
}
inline ::Proto::SchemaItemLink* SchemaItem::mutable_link() {
  set_has_link();
  if (link_ == NULL) link_ = new ::Proto::SchemaItemLink;
  return link_;
}
inline ::Proto::SchemaItemLink* SchemaItem::release_link() {
  clear_has_link();
  ::Proto::SchemaItemLink* temp = link_;
  link_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_link(::Proto::SchemaItemLink* link) {
  delete link_;
  link_ = link;
  if (link) {
    set_has_link();
  } else {
    clear_has_link();
  }
}

// optional .Proto.SchemaItemAfb Afb = 128;
inline bool SchemaItem::has_afb() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SchemaItem::set_has_afb() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SchemaItem::clear_has_afb() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SchemaItem::clear_afb() {
  if (afb_ != NULL) afb_->::Proto::SchemaItemAfb::Clear();
  clear_has_afb();
}
inline const ::Proto::SchemaItemAfb& SchemaItem::afb() const {
  return afb_ != NULL ? *afb_ : *default_instance_->afb_;
}
inline ::Proto::SchemaItemAfb* SchemaItem::mutable_afb() {
  set_has_afb();
  if (afb_ == NULL) afb_ = new ::Proto::SchemaItemAfb;
  return afb_;
}
inline ::Proto::SchemaItemAfb* SchemaItem::release_afb() {
  clear_has_afb();
  ::Proto::SchemaItemAfb* temp = afb_;
  afb_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_afb(::Proto::SchemaItemAfb* afb) {
  delete afb_;
  afb_ = afb;
  if (afb) {
    set_has_afb();
  } else {
    clear_has_afb();
  }
}

// optional .Proto.SchemaItemConst ConstItem = 129;
inline bool SchemaItem::has_constitem() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SchemaItem::set_has_constitem() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SchemaItem::clear_has_constitem() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SchemaItem::clear_constitem() {
  if (constitem_ != NULL) constitem_->::Proto::SchemaItemConst::Clear();
  clear_has_constitem();
}
inline const ::Proto::SchemaItemConst& SchemaItem::constitem() const {
  return constitem_ != NULL ? *constitem_ : *default_instance_->constitem_;
}
inline ::Proto::SchemaItemConst* SchemaItem::mutable_constitem() {
  set_has_constitem();
  if (constitem_ == NULL) constitem_ = new ::Proto::SchemaItemConst;
  return constitem_;
}
inline ::Proto::SchemaItemConst* SchemaItem::release_constitem() {
  clear_has_constitem();
  ::Proto::SchemaItemConst* temp = constitem_;
  constitem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_constitem(::Proto::SchemaItemConst* constitem) {
  delete constitem_;
  constitem_ = constitem;
  if (constitem) {
    set_has_constitem();
  } else {
    clear_has_constitem();
  }
}

// optional .Proto.SchemaItemConnection ConnectionItem = 130;
inline bool SchemaItem::has_connectionitem() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SchemaItem::set_has_connectionitem() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SchemaItem::clear_has_connectionitem() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SchemaItem::clear_connectionitem() {
  if (connectionitem_ != NULL) connectionitem_->::Proto::SchemaItemConnection::Clear();
  clear_has_connectionitem();
}
inline const ::Proto::SchemaItemConnection& SchemaItem::connectionitem() const {
  return connectionitem_ != NULL ? *connectionitem_ : *default_instance_->connectionitem_;
}
inline ::Proto::SchemaItemConnection* SchemaItem::mutable_connectionitem() {
  set_has_connectionitem();
  if (connectionitem_ == NULL) connectionitem_ = new ::Proto::SchemaItemConnection;
  return connectionitem_;
}
inline ::Proto::SchemaItemConnection* SchemaItem::release_connectionitem() {
  clear_has_connectionitem();
  ::Proto::SchemaItemConnection* temp = connectionitem_;
  connectionitem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_connectionitem(::Proto::SchemaItemConnection* connectionitem) {
  delete connectionitem_;
  connectionitem_ = connectionitem;
  if (connectionitem) {
    set_has_connectionitem();
  } else {
    clear_has_connectionitem();
  }
}

// optional .Proto.SchemaItemTransmitter TransmitterItem = 131;
inline bool SchemaItem::has_transmitteritem() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SchemaItem::set_has_transmitteritem() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SchemaItem::clear_has_transmitteritem() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SchemaItem::clear_transmitteritem() {
  if (transmitteritem_ != NULL) transmitteritem_->::Proto::SchemaItemTransmitter::Clear();
  clear_has_transmitteritem();
}
inline const ::Proto::SchemaItemTransmitter& SchemaItem::transmitteritem() const {
  return transmitteritem_ != NULL ? *transmitteritem_ : *default_instance_->transmitteritem_;
}
inline ::Proto::SchemaItemTransmitter* SchemaItem::mutable_transmitteritem() {
  set_has_transmitteritem();
  if (transmitteritem_ == NULL) transmitteritem_ = new ::Proto::SchemaItemTransmitter;
  return transmitteritem_;
}
inline ::Proto::SchemaItemTransmitter* SchemaItem::release_transmitteritem() {
  clear_has_transmitteritem();
  ::Proto::SchemaItemTransmitter* temp = transmitteritem_;
  transmitteritem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_transmitteritem(::Proto::SchemaItemTransmitter* transmitteritem) {
  delete transmitteritem_;
  transmitteritem_ = transmitteritem;
  if (transmitteritem) {
    set_has_transmitteritem();
  } else {
    clear_has_transmitteritem();
  }
}

// optional .Proto.SchemaItemReceiver ReceiverItem = 132;
inline bool SchemaItem::has_receiveritem() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SchemaItem::set_has_receiveritem() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SchemaItem::clear_has_receiveritem() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SchemaItem::clear_receiveritem() {
  if (receiveritem_ != NULL) receiveritem_->::Proto::SchemaItemReceiver::Clear();
  clear_has_receiveritem();
}
inline const ::Proto::SchemaItemReceiver& SchemaItem::receiveritem() const {
  return receiveritem_ != NULL ? *receiveritem_ : *default_instance_->receiveritem_;
}
inline ::Proto::SchemaItemReceiver* SchemaItem::mutable_receiveritem() {
  set_has_receiveritem();
  if (receiveritem_ == NULL) receiveritem_ = new ::Proto::SchemaItemReceiver;
  return receiveritem_;
}
inline ::Proto::SchemaItemReceiver* SchemaItem::release_receiveritem() {
  clear_has_receiveritem();
  ::Proto::SchemaItemReceiver* temp = receiveritem_;
  receiveritem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_receiveritem(::Proto::SchemaItemReceiver* receiveritem) {
  delete receiveritem_;
  receiveritem_ = receiveritem;
  if (receiveritem) {
    set_has_receiveritem();
  } else {
    clear_has_receiveritem();
  }
}

// optional .Proto.SchemaItemInOut InOutSignal = 133;
inline bool SchemaItem::has_inoutsignal() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SchemaItem::set_has_inoutsignal() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SchemaItem::clear_has_inoutsignal() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SchemaItem::clear_inoutsignal() {
  if (inoutsignal_ != NULL) inoutsignal_->::Proto::SchemaItemInOut::Clear();
  clear_has_inoutsignal();
}
inline const ::Proto::SchemaItemInOut& SchemaItem::inoutsignal() const {
  return inoutsignal_ != NULL ? *inoutsignal_ : *default_instance_->inoutsignal_;
}
inline ::Proto::SchemaItemInOut* SchemaItem::mutable_inoutsignal() {
  set_has_inoutsignal();
  if (inoutsignal_ == NULL) inoutsignal_ = new ::Proto::SchemaItemInOut;
  return inoutsignal_;
}
inline ::Proto::SchemaItemInOut* SchemaItem::release_inoutsignal() {
  clear_has_inoutsignal();
  ::Proto::SchemaItemInOut* temp = inoutsignal_;
  inoutsignal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_inoutsignal(::Proto::SchemaItemInOut* inoutsignal) {
  delete inoutsignal_;
  inoutsignal_ = inoutsignal;
  if (inoutsignal) {
    set_has_inoutsignal();
  } else {
    clear_has_inoutsignal();
  }
}

// optional .Proto.SchemaItemUfb ufb = 134;
inline bool SchemaItem::has_ufb() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SchemaItem::set_has_ufb() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SchemaItem::clear_has_ufb() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SchemaItem::clear_ufb() {
  if (ufb_ != NULL) ufb_->::Proto::SchemaItemUfb::Clear();
  clear_has_ufb();
}
inline const ::Proto::SchemaItemUfb& SchemaItem::ufb() const {
  return ufb_ != NULL ? *ufb_ : *default_instance_->ufb_;
}
inline ::Proto::SchemaItemUfb* SchemaItem::mutable_ufb() {
  set_has_ufb();
  if (ufb_ == NULL) ufb_ = new ::Proto::SchemaItemUfb;
  return ufb_;
}
inline ::Proto::SchemaItemUfb* SchemaItem::release_ufb() {
  clear_has_ufb();
  ::Proto::SchemaItemUfb* temp = ufb_;
  ufb_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_ufb(::Proto::SchemaItemUfb* ufb) {
  delete ufb_;
  ufb_ = ufb;
  if (ufb) {
    set_has_ufb();
  } else {
    clear_has_ufb();
  }
}

// optional .Proto.SchemaItemTerminator terminator = 135;
inline bool SchemaItem::has_terminator() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SchemaItem::set_has_terminator() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SchemaItem::clear_has_terminator() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SchemaItem::clear_terminator() {
  if (terminator_ != NULL) terminator_->::Proto::SchemaItemTerminator::Clear();
  clear_has_terminator();
}
inline const ::Proto::SchemaItemTerminator& SchemaItem::terminator() const {
  return terminator_ != NULL ? *terminator_ : *default_instance_->terminator_;
}
inline ::Proto::SchemaItemTerminator* SchemaItem::mutable_terminator() {
  set_has_terminator();
  if (terminator_ == NULL) terminator_ = new ::Proto::SchemaItemTerminator;
  return terminator_;
}
inline ::Proto::SchemaItemTerminator* SchemaItem::release_terminator() {
  clear_has_terminator();
  ::Proto::SchemaItemTerminator* temp = terminator_;
  terminator_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_terminator(::Proto::SchemaItemTerminator* terminator) {
  delete terminator_;
  terminator_ = terminator;
  if (terminator) {
    set_has_terminator();
  } else {
    clear_has_terminator();
  }
}

// optional .Proto.SchemaItemValue Value = 136;
inline bool SchemaItem::has_value() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SchemaItem::set_has_value() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SchemaItem::clear_has_value() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SchemaItem::clear_value() {
  if (value_ != NULL) value_->::Proto::SchemaItemValue::Clear();
  clear_has_value();
}
inline const ::Proto::SchemaItemValue& SchemaItem::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Proto::SchemaItemValue* SchemaItem::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Proto::SchemaItemValue;
  return value_;
}
inline ::Proto::SchemaItemValue* SchemaItem::release_value() {
  clear_has_value();
  ::Proto::SchemaItemValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_value(::Proto::SchemaItemValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional .Proto.SchemaItemBus BusItem = 150;
inline bool SchemaItem::has_busitem() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SchemaItem::set_has_busitem() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SchemaItem::clear_has_busitem() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SchemaItem::clear_busitem() {
  if (busitem_ != NULL) busitem_->::Proto::SchemaItemBus::Clear();
  clear_has_busitem();
}
inline const ::Proto::SchemaItemBus& SchemaItem::busitem() const {
  return busitem_ != NULL ? *busitem_ : *default_instance_->busitem_;
}
inline ::Proto::SchemaItemBus* SchemaItem::mutable_busitem() {
  set_has_busitem();
  if (busitem_ == NULL) busitem_ = new ::Proto::SchemaItemBus;
  return busitem_;
}
inline ::Proto::SchemaItemBus* SchemaItem::release_busitem() {
  clear_has_busitem();
  ::Proto::SchemaItemBus* temp = busitem_;
  busitem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_busitem(::Proto::SchemaItemBus* busitem) {
  delete busitem_;
  busitem_ = busitem;
  if (busitem) {
    set_has_busitem();
  } else {
    clear_has_busitem();
  }
}

// optional .Proto.SchemaItemBusComposer BusComposer = 151;
inline bool SchemaItem::has_buscomposer() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void SchemaItem::set_has_buscomposer() {
  _has_bits_[1] |= 0x00000001u;
}
inline void SchemaItem::clear_has_buscomposer() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void SchemaItem::clear_buscomposer() {
  if (buscomposer_ != NULL) buscomposer_->::Proto::SchemaItemBusComposer::Clear();
  clear_has_buscomposer();
}
inline const ::Proto::SchemaItemBusComposer& SchemaItem::buscomposer() const {
  return buscomposer_ != NULL ? *buscomposer_ : *default_instance_->buscomposer_;
}
inline ::Proto::SchemaItemBusComposer* SchemaItem::mutable_buscomposer() {
  set_has_buscomposer();
  if (buscomposer_ == NULL) buscomposer_ = new ::Proto::SchemaItemBusComposer;
  return buscomposer_;
}
inline ::Proto::SchemaItemBusComposer* SchemaItem::release_buscomposer() {
  clear_has_buscomposer();
  ::Proto::SchemaItemBusComposer* temp = buscomposer_;
  buscomposer_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_buscomposer(::Proto::SchemaItemBusComposer* buscomposer) {
  delete buscomposer_;
  buscomposer_ = buscomposer;
  if (buscomposer) {
    set_has_buscomposer();
  } else {
    clear_has_buscomposer();
  }
}

// optional .Proto.SchemaItemBusExtractor BusExtractor = 152;
inline bool SchemaItem::has_busextractor() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void SchemaItem::set_has_busextractor() {
  _has_bits_[1] |= 0x00000002u;
}
inline void SchemaItem::clear_has_busextractor() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void SchemaItem::clear_busextractor() {
  if (busextractor_ != NULL) busextractor_->::Proto::SchemaItemBusExtractor::Clear();
  clear_has_busextractor();
}
inline const ::Proto::SchemaItemBusExtractor& SchemaItem::busextractor() const {
  return busextractor_ != NULL ? *busextractor_ : *default_instance_->busextractor_;
}
inline ::Proto::SchemaItemBusExtractor* SchemaItem::mutable_busextractor() {
  set_has_busextractor();
  if (busextractor_ == NULL) busextractor_ = new ::Proto::SchemaItemBusExtractor;
  return busextractor_;
}
inline ::Proto::SchemaItemBusExtractor* SchemaItem::release_busextractor() {
  clear_has_busextractor();
  ::Proto::SchemaItemBusExtractor* temp = busextractor_;
  busextractor_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_busextractor(::Proto::SchemaItemBusExtractor* busextractor) {
  delete busextractor_;
  busextractor_ = busextractor;
  if (busextractor) {
    set_has_busextractor();
  } else {
    clear_has_busextractor();
  }
}

// optional .Proto.SchemaItemControl control = 200;
inline bool SchemaItem::has_control() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void SchemaItem::set_has_control() {
  _has_bits_[1] |= 0x00000004u;
}
inline void SchemaItem::clear_has_control() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void SchemaItem::clear_control() {
  if (control_ != NULL) control_->::Proto::SchemaItemControl::Clear();
  clear_has_control();
}
inline const ::Proto::SchemaItemControl& SchemaItem::control() const {
  return control_ != NULL ? *control_ : *default_instance_->control_;
}
inline ::Proto::SchemaItemControl* SchemaItem::mutable_control() {
  set_has_control();
  if (control_ == NULL) control_ = new ::Proto::SchemaItemControl;
  return control_;
}
inline ::Proto::SchemaItemControl* SchemaItem::release_control() {
  clear_has_control();
  ::Proto::SchemaItemControl* temp = control_;
  control_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_control(::Proto::SchemaItemControl* control) {
  delete control_;
  control_ = control;
  if (control) {
    set_has_control();
  } else {
    clear_has_control();
  }
}

// optional .Proto.SchemaItemPushButton pushButton = 210;
inline bool SchemaItem::has_pushbutton() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void SchemaItem::set_has_pushbutton() {
  _has_bits_[1] |= 0x00000008u;
}
inline void SchemaItem::clear_has_pushbutton() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void SchemaItem::clear_pushbutton() {
  if (pushbutton_ != NULL) pushbutton_->::Proto::SchemaItemPushButton::Clear();
  clear_has_pushbutton();
}
inline const ::Proto::SchemaItemPushButton& SchemaItem::pushbutton() const {
  return pushbutton_ != NULL ? *pushbutton_ : *default_instance_->pushbutton_;
}
inline ::Proto::SchemaItemPushButton* SchemaItem::mutable_pushbutton() {
  set_has_pushbutton();
  if (pushbutton_ == NULL) pushbutton_ = new ::Proto::SchemaItemPushButton;
  return pushbutton_;
}
inline ::Proto::SchemaItemPushButton* SchemaItem::release_pushbutton() {
  clear_has_pushbutton();
  ::Proto::SchemaItemPushButton* temp = pushbutton_;
  pushbutton_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_pushbutton(::Proto::SchemaItemPushButton* pushbutton) {
  delete pushbutton_;
  pushbutton_ = pushbutton;
  if (pushbutton) {
    set_has_pushbutton();
  } else {
    clear_has_pushbutton();
  }
}

// optional .Proto.SchemaItemLineEdit lineEdit = 211;
inline bool SchemaItem::has_lineedit() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void SchemaItem::set_has_lineedit() {
  _has_bits_[1] |= 0x00000010u;
}
inline void SchemaItem::clear_has_lineedit() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void SchemaItem::clear_lineedit() {
  if (lineedit_ != NULL) lineedit_->::Proto::SchemaItemLineEdit::Clear();
  clear_has_lineedit();
}
inline const ::Proto::SchemaItemLineEdit& SchemaItem::lineedit() const {
  return lineedit_ != NULL ? *lineedit_ : *default_instance_->lineedit_;
}
inline ::Proto::SchemaItemLineEdit* SchemaItem::mutable_lineedit() {
  set_has_lineedit();
  if (lineedit_ == NULL) lineedit_ = new ::Proto::SchemaItemLineEdit;
  return lineedit_;
}
inline ::Proto::SchemaItemLineEdit* SchemaItem::release_lineedit() {
  clear_has_lineedit();
  ::Proto::SchemaItemLineEdit* temp = lineedit_;
  lineedit_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_lineedit(::Proto::SchemaItemLineEdit* lineedit) {
  delete lineedit_;
  lineedit_ = lineedit;
  if (lineedit) {
    set_has_lineedit();
  } else {
    clear_has_lineedit();
  }
}

// -------------------------------------------------------------------

// PosRectImpl

// required double leftDocPt = 1;
inline bool PosRectImpl::has_leftdocpt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosRectImpl::set_has_leftdocpt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosRectImpl::clear_has_leftdocpt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosRectImpl::clear_leftdocpt() {
  leftdocpt_ = 0;
  clear_has_leftdocpt();
}
inline double PosRectImpl::leftdocpt() const {
  return leftdocpt_;
}
inline void PosRectImpl::set_leftdocpt(double value) {
  set_has_leftdocpt();
  leftdocpt_ = value;
}

// required double topDocPt = 2;
inline bool PosRectImpl::has_topdocpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosRectImpl::set_has_topdocpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosRectImpl::clear_has_topdocpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosRectImpl::clear_topdocpt() {
  topdocpt_ = 0;
  clear_has_topdocpt();
}
inline double PosRectImpl::topdocpt() const {
  return topdocpt_;
}
inline void PosRectImpl::set_topdocpt(double value) {
  set_has_topdocpt();
  topdocpt_ = value;
}

// required double widthDocPt = 3;
inline bool PosRectImpl::has_widthdocpt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosRectImpl::set_has_widthdocpt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosRectImpl::clear_has_widthdocpt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosRectImpl::clear_widthdocpt() {
  widthdocpt_ = 0;
  clear_has_widthdocpt();
}
inline double PosRectImpl::widthdocpt() const {
  return widthdocpt_;
}
inline void PosRectImpl::set_widthdocpt(double value) {
  set_has_widthdocpt();
  widthdocpt_ = value;
}

// required double heightDocPt = 4;
inline bool PosRectImpl::has_heightdocpt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosRectImpl::set_has_heightdocpt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosRectImpl::clear_has_heightdocpt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosRectImpl::clear_heightdocpt() {
  heightdocpt_ = 0;
  clear_has_heightdocpt();
}
inline double PosRectImpl::heightdocpt() const {
  return heightdocpt_;
}
inline void PosRectImpl::set_heightdocpt(double value) {
  set_has_heightdocpt();
  heightdocpt_ = value;
}

// -------------------------------------------------------------------

// PosLineImpl

// required double startXDocPt = 1;
inline bool PosLineImpl::has_startxdocpt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosLineImpl::set_has_startxdocpt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosLineImpl::clear_has_startxdocpt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosLineImpl::clear_startxdocpt() {
  startxdocpt_ = 0;
  clear_has_startxdocpt();
}
inline double PosLineImpl::startxdocpt() const {
  return startxdocpt_;
}
inline void PosLineImpl::set_startxdocpt(double value) {
  set_has_startxdocpt();
  startxdocpt_ = value;
}

// required double startYDocPt = 2;
inline bool PosLineImpl::has_startydocpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosLineImpl::set_has_startydocpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosLineImpl::clear_has_startydocpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosLineImpl::clear_startydocpt() {
  startydocpt_ = 0;
  clear_has_startydocpt();
}
inline double PosLineImpl::startydocpt() const {
  return startydocpt_;
}
inline void PosLineImpl::set_startydocpt(double value) {
  set_has_startydocpt();
  startydocpt_ = value;
}

// required double endXDocPt = 3;
inline bool PosLineImpl::has_endxdocpt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosLineImpl::set_has_endxdocpt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosLineImpl::clear_has_endxdocpt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosLineImpl::clear_endxdocpt() {
  endxdocpt_ = 0;
  clear_has_endxdocpt();
}
inline double PosLineImpl::endxdocpt() const {
  return endxdocpt_;
}
inline void PosLineImpl::set_endxdocpt(double value) {
  set_has_endxdocpt();
  endxdocpt_ = value;
}

// required double endYDocPt = 4;
inline bool PosLineImpl::has_endydocpt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosLineImpl::set_has_endydocpt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosLineImpl::clear_has_endydocpt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosLineImpl::clear_endydocpt() {
  endydocpt_ = 0;
  clear_has_endydocpt();
}
inline double PosLineImpl::endydocpt() const {
  return endydocpt_;
}
inline void PosLineImpl::set_endydocpt(double value) {
  set_has_endydocpt();
  endydocpt_ = value;
}

// -------------------------------------------------------------------

// PosConnectionImpl

// repeated .Proto.SchemaPoint points = 1;
inline int PosConnectionImpl::points_size() const {
  return points_.size();
}
inline void PosConnectionImpl::clear_points() {
  points_.Clear();
}
inline const ::Proto::SchemaPoint& PosConnectionImpl::points(int index) const {
  return points_.Get(index);
}
inline ::Proto::SchemaPoint* PosConnectionImpl::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::Proto::SchemaPoint* PosConnectionImpl::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >&
PosConnectionImpl::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >*
PosConnectionImpl::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// SchemaItemRect

// required double weight = 1;
inline bool SchemaItemRect::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemRect::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemRect::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemRect::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemRect::weight() const {
  return weight_;
}
inline void SchemaItemRect::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemaItemRect::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemRect::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemRect::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemRect::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemRect::linecolor() const {
  return linecolor_;
}
inline void SchemaItemRect::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// required uint32 fillColor = 3;
inline bool SchemaItemRect::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemRect::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemRect::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemRect::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 SchemaItemRect::fillcolor() const {
  return fillcolor_;
}
inline void SchemaItemRect::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// required .Proto.wstring text = 4;
inline bool SchemaItemRect::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemRect::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemRect::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemRect::clear_text() {
  if (text_ != NULL) text_->::Proto::wstring::Clear();
  clear_has_text();
}
inline const ::Proto::wstring& SchemaItemRect::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::Proto::wstring* SchemaItemRect::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::Proto::wstring;
  return text_;
}
inline ::Proto::wstring* SchemaItemRect::release_text() {
  clear_has_text();
  ::Proto::wstring* temp = text_;
  text_ = NULL;
  return temp;
}
inline void SchemaItemRect::set_allocated_text(::Proto::wstring* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// required uint32 textColor = 5;
inline bool SchemaItemRect::has_textcolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemRect::set_has_textcolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemRect::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemRect::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 SchemaItemRect::textcolor() const {
  return textcolor_;
}
inline void SchemaItemRect::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// required .Proto.FontParam font = 6;
inline bool SchemaItemRect::has_font() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemRect::set_has_font() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemRect::clear_has_font() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemRect::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& SchemaItemRect::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* SchemaItemRect::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* SchemaItemRect::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void SchemaItemRect::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// required bool fill = 7;
inline bool SchemaItemRect::has_fill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItemRect::set_has_fill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItemRect::clear_has_fill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItemRect::clear_fill() {
  fill_ = false;
  clear_has_fill();
}
inline bool SchemaItemRect::fill() const {
  return fill_;
}
inline void SchemaItemRect::set_fill(bool value) {
  set_has_fill();
  fill_ = value;
}

// optional bool drawrect = 8 [default = true];
inline bool SchemaItemRect::has_drawrect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItemRect::set_has_drawrect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItemRect::clear_has_drawrect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItemRect::clear_drawrect() {
  drawrect_ = true;
  clear_has_drawrect();
}
inline bool SchemaItemRect::drawrect() const {
  return drawrect_;
}
inline void SchemaItemRect::set_drawrect(bool value) {
  set_has_drawrect();
  drawrect_ = value;
}

// optional int32 horzAlign = 9 [default = 4];
inline bool SchemaItemRect::has_horzalign() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItemRect::set_has_horzalign() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItemRect::clear_has_horzalign() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItemRect::clear_horzalign() {
  horzalign_ = 4;
  clear_has_horzalign();
}
inline ::google::protobuf::int32 SchemaItemRect::horzalign() const {
  return horzalign_;
}
inline void SchemaItemRect::set_horzalign(::google::protobuf::int32 value) {
  set_has_horzalign();
  horzalign_ = value;
}

// optional int32 vertAlign = 10 [default = 128];
inline bool SchemaItemRect::has_vertalign() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItemRect::set_has_vertalign() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItemRect::clear_has_vertalign() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItemRect::clear_vertalign() {
  vertalign_ = 128;
  clear_has_vertalign();
}
inline ::google::protobuf::int32 SchemaItemRect::vertalign() const {
  return vertalign_;
}
inline void SchemaItemRect::set_vertalign(::google::protobuf::int32 value) {
  set_has_vertalign();
  vertalign_ = value;
}

// -------------------------------------------------------------------

// SchemaItemLine

// required double weight = 1;
inline bool SchemaItemLine::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemLine::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemLine::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemLine::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemLine::weight() const {
  return weight_;
}
inline void SchemaItemLine::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemaItemLine::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemLine::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemLine::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemLine::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemLine::linecolor() const {
  return linecolor_;
}
inline void SchemaItemLine::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// SchemaItemPath

// required double weight = 1;
inline bool SchemaItemPath::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemPath::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemPath::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemPath::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemPath::weight() const {
  return weight_;
}
inline void SchemaItemPath::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemaItemPath::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemPath::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemPath::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemPath::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemPath::linecolor() const {
  return linecolor_;
}
inline void SchemaItemPath::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// FblConnectionPoint

// optional .Proto.SchemaPoint point = 1;
inline bool FblConnectionPoint::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblConnectionPoint::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblConnectionPoint::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblConnectionPoint::clear_point() {
  if (point_ != NULL) point_->::Proto::SchemaPoint::Clear();
  clear_has_point();
}
inline const ::Proto::SchemaPoint& FblConnectionPoint::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::Proto::SchemaPoint* FblConnectionPoint::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::Proto::SchemaPoint;
  return point_;
}
inline ::Proto::SchemaPoint* FblConnectionPoint::release_point() {
  clear_has_point();
  ::Proto::SchemaPoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void FblConnectionPoint::set_allocated_point(::Proto::SchemaPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// optional .Proto.ConnectionDirrection dirrection = 2;
inline bool FblConnectionPoint::has_dirrection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblConnectionPoint::set_has_dirrection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblConnectionPoint::clear_has_dirrection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblConnectionPoint::clear_dirrection() {
  dirrection_ = 0;
  clear_has_dirrection();
}
inline ::Proto::ConnectionDirrection FblConnectionPoint::dirrection() const {
  return static_cast< ::Proto::ConnectionDirrection >(dirrection_);
}
inline void FblConnectionPoint::set_dirrection(::Proto::ConnectionDirrection value) {
  assert(::Proto::ConnectionDirrection_IsValid(value));
  set_has_dirrection();
  dirrection_ = value;
}

// optional .Proto.Uuid uuid = 3;
inline bool FblConnectionPoint::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblConnectionPoint::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblConnectionPoint::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblConnectionPoint::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& FblConnectionPoint::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* FblConnectionPoint::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* FblConnectionPoint::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void FblConnectionPoint::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// optional int32 operandIndex = 4 [default = -1];
inline bool FblConnectionPoint::has_operandindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblConnectionPoint::set_has_operandindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblConnectionPoint::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblConnectionPoint::clear_operandindex() {
  operandindex_ = -1;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 FblConnectionPoint::operandindex() const {
  return operandindex_;
}
inline void FblConnectionPoint::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional string caption = 5 [default = ""];
inline bool FblConnectionPoint::has_caption() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblConnectionPoint::set_has_caption() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblConnectionPoint::clear_has_caption() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblConnectionPoint::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& FblConnectionPoint::caption() const {
  return *caption_;
}
inline void FblConnectionPoint::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void FblConnectionPoint::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void FblConnectionPoint::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FblConnectionPoint::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* FblConnectionPoint::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FblConnectionPoint::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.Uuid associatedIos = 6;
inline int FblConnectionPoint::associatedios_size() const {
  return associatedios_.size();
}
inline void FblConnectionPoint::clear_associatedios() {
  associatedios_.Clear();
}
inline const ::Proto::Uuid& FblConnectionPoint::associatedios(int index) const {
  return associatedios_.Get(index);
}
inline ::Proto::Uuid* FblConnectionPoint::mutable_associatedios(int index) {
  return associatedios_.Mutable(index);
}
inline ::Proto::Uuid* FblConnectionPoint::add_associatedios() {
  return associatedios_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
FblConnectionPoint::associatedios() const {
  return associatedios_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
FblConnectionPoint::mutable_associatedios() {
  return &associatedios_;
}

// -------------------------------------------------------------------

// FblItem

// repeated .Proto.FblConnectionPoint points = 1;
inline int FblItem::points_size() const {
  return points_.size();
}
inline void FblItem::clear_points() {
  points_.Clear();
}
inline const ::Proto::FblConnectionPoint& FblItem::points(int index) const {
  return points_.Get(index);
}
inline ::Proto::FblConnectionPoint* FblItem::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::Proto::FblConnectionPoint* FblItem::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >&
FblItem::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >*
FblItem::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// FblItemRect

// required double weight = 1;
inline bool FblItemRect::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblItemRect::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblItemRect::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblItemRect::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double FblItemRect::weight() const {
  return weight_;
}
inline void FblItemRect::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool FblItemRect::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblItemRect::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblItemRect::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblItemRect::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 FblItemRect::linecolor() const {
  return linecolor_;
}
inline void FblItemRect::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// required uint32 fillColor = 3;
inline bool FblItemRect::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblItemRect::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblItemRect::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblItemRect::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 FblItemRect::fillcolor() const {
  return fillcolor_;
}
inline void FblItemRect::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// required uint32 textColor = 4;
inline bool FblItemRect::has_textcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblItemRect::set_has_textcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblItemRect::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblItemRect::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 FblItemRect::textcolor() const {
  return textcolor_;
}
inline void FblItemRect::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// required .Proto.FontParam font = 5;
inline bool FblItemRect::has_font() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblItemRect::set_has_font() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblItemRect::clear_has_font() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblItemRect::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& FblItemRect::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* FblItemRect::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* FblItemRect::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void FblItemRect::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// optional string label = 6;
inline bool FblItemRect::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FblItemRect::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FblItemRect::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FblItemRect::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& FblItemRect::label() const {
  return *label_;
}
inline void FblItemRect::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void FblItemRect::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void FblItemRect::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FblItemRect::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* FblItemRect::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FblItemRect::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userText = 7;
inline bool FblItemRect::has_usertext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FblItemRect::set_has_usertext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FblItemRect::clear_has_usertext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FblItemRect::clear_usertext() {
  if (usertext_ != &::google::protobuf::internal::kEmptyString) {
    usertext_->clear();
  }
  clear_has_usertext();
}
inline const ::std::string& FblItemRect::usertext() const {
  return *usertext_;
}
inline void FblItemRect::set_usertext(const ::std::string& value) {
  set_has_usertext();
  if (usertext_ == &::google::protobuf::internal::kEmptyString) {
    usertext_ = new ::std::string;
  }
  usertext_->assign(value);
}
inline void FblItemRect::set_usertext(const char* value) {
  set_has_usertext();
  if (usertext_ == &::google::protobuf::internal::kEmptyString) {
    usertext_ = new ::std::string;
  }
  usertext_->assign(value);
}
inline void FblItemRect::set_usertext(const char* value, size_t size) {
  set_has_usertext();
  if (usertext_ == &::google::protobuf::internal::kEmptyString) {
    usertext_ = new ::std::string;
  }
  usertext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FblItemRect::mutable_usertext() {
  set_has_usertext();
  if (usertext_ == &::google::protobuf::internal::kEmptyString) {
    usertext_ = new ::std::string;
  }
  return usertext_;
}
inline ::std::string* FblItemRect::release_usertext() {
  clear_has_usertext();
  if (usertext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usertext_;
    usertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FblItemRect::set_allocated_usertext(::std::string* usertext) {
  if (usertext_ != &::google::protobuf::internal::kEmptyString) {
    delete usertext_;
  }
  if (usertext) {
    set_has_usertext();
    usertext_ = usertext;
  } else {
    clear_has_usertext();
    usertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 userTextPos = 8 [default = 1];
inline bool FblItemRect::has_usertextpos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FblItemRect::set_has_usertextpos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FblItemRect::clear_has_usertextpos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FblItemRect::clear_usertextpos() {
  usertextpos_ = 1;
  clear_has_usertextpos();
}
inline ::google::protobuf::int32 FblItemRect::usertextpos() const {
  return usertextpos_;
}
inline void FblItemRect::set_usertextpos(::google::protobuf::int32 value) {
  set_has_usertextpos();
  usertextpos_ = value;
}

// -------------------------------------------------------------------

// FblItemLine

// required double weight = 1;
inline bool FblItemLine::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblItemLine::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblItemLine::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblItemLine::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double FblItemLine::weight() const {
  return weight_;
}
inline void FblItemLine::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool FblItemLine::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblItemLine::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblItemLine::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblItemLine::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 FblItemLine::linecolor() const {
  return linecolor_;
}
inline void FblItemLine::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// SchemaItemSignalColumn

// optional double width = 1 [default = 20];
inline bool SchemaItemSignalColumn::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemSignalColumn::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemSignalColumn::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemSignalColumn::clear_width() {
  width_ = 20;
  clear_has_width();
}
inline double SchemaItemSignalColumn::width() const {
  return width_;
}
inline void SchemaItemSignalColumn::set_width(double value) {
  set_has_width();
  width_ = value;
}

// optional int32 data = 2 [default = 0];
inline bool SchemaItemSignalColumn::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemSignalColumn::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemSignalColumn::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemSignalColumn::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 SchemaItemSignalColumn::data() const {
  return data_;
}
inline void SchemaItemSignalColumn::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// optional int32 horzAlign = 3 [default = 1];
inline bool SchemaItemSignalColumn::has_horzalign() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemSignalColumn::set_has_horzalign() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemSignalColumn::clear_has_horzalign() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemSignalColumn::clear_horzalign() {
  horzalign_ = 1;
  clear_has_horzalign();
}
inline ::google::protobuf::int32 SchemaItemSignalColumn::horzalign() const {
  return horzalign_;
}
inline void SchemaItemSignalColumn::set_horzalign(::google::protobuf::int32 value) {
  set_has_horzalign();
  horzalign_ = value;
}

// -------------------------------------------------------------------

// SchemaItemSignal

// repeated .Proto.wstring appSignalIDs = 1;
inline int SchemaItemSignal::appsignalids_size() const {
  return appsignalids_.size();
}
inline void SchemaItemSignal::clear_appsignalids() {
  appsignalids_.Clear();
}
inline const ::Proto::wstring& SchemaItemSignal::appsignalids(int index) const {
  return appsignalids_.Get(index);
}
inline ::Proto::wstring* SchemaItemSignal::mutable_appsignalids(int index) {
  return appsignalids_.Mutable(index);
}
inline ::Proto::wstring* SchemaItemSignal::add_appsignalids() {
  return appsignalids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
SchemaItemSignal::appsignalids() const {
  return appsignalids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
SchemaItemSignal::mutable_appsignalids() {
  return &appsignalids_;
}

// optional int32 precision = 2 [default = 2];
inline bool SchemaItemSignal::has_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemSignal::set_has_precision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemSignal::clear_has_precision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemSignal::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemSignal::precision() const {
  return precision_;
}
inline void SchemaItemSignal::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional int32 analogFormat = 3 [default = 102];
inline bool SchemaItemSignal::has_analogformat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemSignal::set_has_analogformat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemSignal::clear_has_analogformat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemSignal::clear_analogformat() {
  analogformat_ = 102;
  clear_has_analogformat();
}
inline ::google::protobuf::int32 SchemaItemSignal::analogformat() const {
  return analogformat_;
}
inline void SchemaItemSignal::set_analogformat(::google::protobuf::int32 value) {
  set_has_analogformat();
  analogformat_ = value;
}

// repeated .Proto.SchemaItemSignalColumn columns = 4;
inline int SchemaItemSignal::columns_size() const {
  return columns_.size();
}
inline void SchemaItemSignal::clear_columns() {
  columns_.Clear();
}
inline const ::Proto::SchemaItemSignalColumn& SchemaItemSignal::columns(int index) const {
  return columns_.Get(index);
}
inline ::Proto::SchemaItemSignalColumn* SchemaItemSignal::mutable_columns(int index) {
  return columns_.Mutable(index);
}
inline ::Proto::SchemaItemSignalColumn* SchemaItemSignal::add_columns() {
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaItemSignalColumn >&
SchemaItemSignal::columns() const {
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaItemSignalColumn >*
SchemaItemSignal::mutable_columns() {
  return &columns_;
}

// -------------------------------------------------------------------

// SchemaItemInput

// -------------------------------------------------------------------

// SchemaItemOutput

// -------------------------------------------------------------------

// SchemaItemInOut

// -------------------------------------------------------------------

// SchemaItemLink

// -------------------------------------------------------------------

// SchemaItemAfb

// repeated .Proto.AfbParam params = 2;
inline int SchemaItemAfb::params_size() const {
  return params_.size();
}
inline void SchemaItemAfb::clear_params() {
  params_.Clear();
}
inline const ::Proto::AfbParam& SchemaItemAfb::params(int index) const {
  return params_.Get(index);
}
inline ::Proto::AfbParam* SchemaItemAfb::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Proto::AfbParam* SchemaItemAfb::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
SchemaItemAfb::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
SchemaItemAfb::mutable_params() {
  return &params_;
}

// optional .Proto.wstring afbStrid = 3;
inline bool SchemaItemAfb::has_afbstrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemAfb::set_has_afbstrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemAfb::clear_has_afbstrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemAfb::clear_afbstrid() {
  if (afbstrid_ != NULL) afbstrid_->::Proto::wstring::Clear();
  clear_has_afbstrid();
}
inline const ::Proto::wstring& SchemaItemAfb::afbstrid() const {
  return afbstrid_ != NULL ? *afbstrid_ : *default_instance_->afbstrid_;
}
inline ::Proto::wstring* SchemaItemAfb::mutable_afbstrid() {
  set_has_afbstrid();
  if (afbstrid_ == NULL) afbstrid_ = new ::Proto::wstring;
  return afbstrid_;
}
inline ::Proto::wstring* SchemaItemAfb::release_afbstrid() {
  clear_has_afbstrid();
  ::Proto::wstring* temp = afbstrid_;
  afbstrid_ = NULL;
  return temp;
}
inline void SchemaItemAfb::set_allocated_afbstrid(::Proto::wstring* afbstrid) {
  delete afbstrid_;
  afbstrid_ = afbstrid;
  if (afbstrid) {
    set_has_afbstrid();
  } else {
    clear_has_afbstrid();
  }
}

// optional int32 precision = 4 [default = 2];
inline bool SchemaItemAfb::has_precision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemAfb::set_has_precision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemAfb::clear_has_precision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemAfb::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemAfb::precision() const {
  return precision_;
}
inline void SchemaItemAfb::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional .Proto.AfbElementXml deprecated_afbelement = 5;
inline bool SchemaItemAfb::has_deprecated_afbelement() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemAfb::set_has_deprecated_afbelement() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemAfb::clear_has_deprecated_afbelement() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemAfb::clear_deprecated_afbelement() {
  if (deprecated_afbelement_ != NULL) deprecated_afbelement_->::Proto::AfbElementXml::Clear();
  clear_has_deprecated_afbelement();
}
inline const ::Proto::AfbElementXml& SchemaItemAfb::deprecated_afbelement() const {
  return deprecated_afbelement_ != NULL ? *deprecated_afbelement_ : *default_instance_->deprecated_afbelement_;
}
inline ::Proto::AfbElementXml* SchemaItemAfb::mutable_deprecated_afbelement() {
  set_has_deprecated_afbelement();
  if (deprecated_afbelement_ == NULL) deprecated_afbelement_ = new ::Proto::AfbElementXml;
  return deprecated_afbelement_;
}
inline ::Proto::AfbElementXml* SchemaItemAfb::release_deprecated_afbelement() {
  clear_has_deprecated_afbelement();
  ::Proto::AfbElementXml* temp = deprecated_afbelement_;
  deprecated_afbelement_ = NULL;
  return temp;
}
inline void SchemaItemAfb::set_allocated_deprecated_afbelement(::Proto::AfbElementXml* deprecated_afbelement) {
  delete deprecated_afbelement_;
  deprecated_afbelement_ = deprecated_afbelement;
  if (deprecated_afbelement) {
    set_has_deprecated_afbelement();
  } else {
    clear_has_deprecated_afbelement();
  }
}

// optional string deprecated_label = 6;
inline bool SchemaItemAfb::has_deprecated_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemAfb::set_has_deprecated_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemAfb::clear_has_deprecated_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemAfb::clear_deprecated_label() {
  if (deprecated_label_ != &::google::protobuf::internal::kEmptyString) {
    deprecated_label_->clear();
  }
  clear_has_deprecated_label();
}
inline const ::std::string& SchemaItemAfb::deprecated_label() const {
  return *deprecated_label_;
}
inline void SchemaItemAfb::set_deprecated_label(const ::std::string& value) {
  set_has_deprecated_label();
  if (deprecated_label_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_label_ = new ::std::string;
  }
  deprecated_label_->assign(value);
}
inline void SchemaItemAfb::set_deprecated_label(const char* value) {
  set_has_deprecated_label();
  if (deprecated_label_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_label_ = new ::std::string;
  }
  deprecated_label_->assign(value);
}
inline void SchemaItemAfb::set_deprecated_label(const char* value, size_t size) {
  set_has_deprecated_label();
  if (deprecated_label_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_label_ = new ::std::string;
  }
  deprecated_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemAfb::mutable_deprecated_label() {
  set_has_deprecated_label();
  if (deprecated_label_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_label_ = new ::std::string;
  }
  return deprecated_label_;
}
inline ::std::string* SchemaItemAfb::release_deprecated_label() {
  clear_has_deprecated_label();
  if (deprecated_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deprecated_label_;
    deprecated_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemAfb::set_allocated_deprecated_label(::std::string* deprecated_label) {
  if (deprecated_label_ != &::google::protobuf::internal::kEmptyString) {
    delete deprecated_label_;
  }
  if (deprecated_label) {
    set_has_deprecated_label();
    deprecated_label_ = deprecated_label;
  } else {
    clear_has_deprecated_label();
    deprecated_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Proto.AfbElementXml afbelement = 7;
inline bool SchemaItemAfb::has_afbelement() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemAfb::set_has_afbelement() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemAfb::clear_has_afbelement() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemAfb::clear_afbelement() {
  if (afbelement_ != NULL) afbelement_->::Proto::AfbElementXml::Clear();
  clear_has_afbelement();
}
inline const ::Proto::AfbElementXml& SchemaItemAfb::afbelement() const {
  return afbelement_ != NULL ? *afbelement_ : *default_instance_->afbelement_;
}
inline ::Proto::AfbElementXml* SchemaItemAfb::mutable_afbelement() {
  set_has_afbelement();
  if (afbelement_ == NULL) afbelement_ = new ::Proto::AfbElementXml;
  return afbelement_;
}
inline ::Proto::AfbElementXml* SchemaItemAfb::release_afbelement() {
  clear_has_afbelement();
  ::Proto::AfbElementXml* temp = afbelement_;
  afbelement_ = NULL;
  return temp;
}
inline void SchemaItemAfb::set_allocated_afbelement(::Proto::AfbElementXml* afbelement) {
  delete afbelement_;
  afbelement_ = afbelement;
  if (afbelement) {
    set_has_afbelement();
  } else {
    clear_has_afbelement();
  }
}

// -------------------------------------------------------------------

// SchemaItemConst

// optional int32 type = 1 [default = 0];
inline bool SchemaItemConst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemConst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemConst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemConst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SchemaItemConst::type() const {
  return type_;
}
inline void SchemaItemConst::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 intValue = 2 [default = 0];
inline bool SchemaItemConst::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemConst::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemConst::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemConst::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 SchemaItemConst::intvalue() const {
  return intvalue_;
}
inline void SchemaItemConst::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional double floatValue = 3 [default = 0];
inline bool SchemaItemConst::has_floatvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemConst::set_has_floatvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemConst::clear_has_floatvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemConst::clear_floatvalue() {
  floatvalue_ = 0;
  clear_has_floatvalue();
}
inline double SchemaItemConst::floatvalue() const {
  return floatvalue_;
}
inline void SchemaItemConst::set_floatvalue(double value) {
  set_has_floatvalue();
  floatvalue_ = value;
}

// optional int32 precision = 4 [default = 2];
inline bool SchemaItemConst::has_precision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemConst::set_has_precision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemConst::clear_has_precision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemConst::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemConst::precision() const {
  return precision_;
}
inline void SchemaItemConst::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional int32 horzAlign = 5 [default = 4];
inline bool SchemaItemConst::has_horzalign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemConst::set_has_horzalign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemConst::clear_has_horzalign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemConst::clear_horzalign() {
  horzalign_ = 4;
  clear_has_horzalign();
}
inline ::google::protobuf::int32 SchemaItemConst::horzalign() const {
  return horzalign_;
}
inline void SchemaItemConst::set_horzalign(::google::protobuf::int32 value) {
  set_has_horzalign();
  horzalign_ = value;
}

// optional int32 vertAlign = 6 [default = 128];
inline bool SchemaItemConst::has_vertalign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemConst::set_has_vertalign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemConst::clear_has_vertalign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemConst::clear_vertalign() {
  vertalign_ = 128;
  clear_has_vertalign();
}
inline ::google::protobuf::int32 SchemaItemConst::vertalign() const {
  return vertalign_;
}
inline void SchemaItemConst::set_vertalign(::google::protobuf::int32 value) {
  set_has_vertalign();
  vertalign_ = value;
}

// -------------------------------------------------------------------

// SchemaItemConnection

// optional string connectionid = 1;
inline bool SchemaItemConnection::has_connectionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemConnection::set_has_connectionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemConnection::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemConnection::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& SchemaItemConnection::connectionid() const {
  return *connectionid_;
}
inline void SchemaItemConnection::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void SchemaItemConnection::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void SchemaItemConnection::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemConnection::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* SchemaItemConnection::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemConnection::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SchemaItemTransmitter

// optional int32 pinCount = 1 [default = 1];
inline bool SchemaItemTransmitter::has_pincount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemTransmitter::set_has_pincount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemTransmitter::clear_has_pincount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemTransmitter::clear_pincount() {
  pincount_ = 1;
  clear_has_pincount();
}
inline ::google::protobuf::int32 SchemaItemTransmitter::pincount() const {
  return pincount_;
}
inline void SchemaItemTransmitter::set_pincount(::google::protobuf::int32 value) {
  set_has_pincount();
  pincount_ = value;
}

// -------------------------------------------------------------------

// SchemaItemReceiver

// optional bool showValidity = 1 [default = true];
inline bool SchemaItemReceiver::has_showvalidity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemReceiver::set_has_showvalidity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemReceiver::clear_has_showvalidity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemReceiver::clear_showvalidity() {
  showvalidity_ = true;
  clear_has_showvalidity();
}
inline bool SchemaItemReceiver::showvalidity() const {
  return showvalidity_;
}
inline void SchemaItemReceiver::set_showvalidity(bool value) {
  set_has_showvalidity();
  showvalidity_ = value;
}

// optional string appSignalId = 2;
inline bool SchemaItemReceiver::has_appsignalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemReceiver::set_has_appsignalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemReceiver::clear_has_appsignalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemReceiver::clear_appsignalid() {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    appsignalid_->clear();
  }
  clear_has_appsignalid();
}
inline const ::std::string& SchemaItemReceiver::appsignalid() const {
  return *appsignalid_;
}
inline void SchemaItemReceiver::set_appsignalid(const ::std::string& value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void SchemaItemReceiver::set_appsignalid(const char* value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void SchemaItemReceiver::set_appsignalid(const char* value, size_t size) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemReceiver::mutable_appsignalid() {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  return appsignalid_;
}
inline ::std::string* SchemaItemReceiver::release_appsignalid() {
  clear_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appsignalid_;
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemReceiver::set_allocated_appsignalid(::std::string* appsignalid) {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete appsignalid_;
  }
  if (appsignalid) {
    set_has_appsignalid();
    appsignalid_ = appsignalid;
  } else {
    clear_has_appsignalid();
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dataType = 3 [default = 0];
inline bool SchemaItemReceiver::has_datatype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemReceiver::set_has_datatype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemReceiver::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemReceiver::clear_datatype() {
  datatype_ = 0;
  clear_has_datatype();
}
inline ::google::protobuf::int32 SchemaItemReceiver::datatype() const {
  return datatype_;
}
inline void SchemaItemReceiver::set_datatype(::google::protobuf::int32 value) {
  set_has_datatype();
  datatype_ = value;
}

// optional int32 precision = 4 [default = 2];
inline bool SchemaItemReceiver::has_precision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemReceiver::set_has_precision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemReceiver::clear_has_precision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemReceiver::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemReceiver::precision() const {
  return precision_;
}
inline void SchemaItemReceiver::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional int32 analogFormat = 5 [default = 102];
inline bool SchemaItemReceiver::has_analogformat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemReceiver::set_has_analogformat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemReceiver::clear_has_analogformat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemReceiver::clear_analogformat() {
  analogformat_ = 102;
  clear_has_analogformat();
}
inline ::google::protobuf::int32 SchemaItemReceiver::analogformat() const {
  return analogformat_;
}
inline void SchemaItemReceiver::set_analogformat(::google::protobuf::int32 value) {
  set_has_analogformat();
  analogformat_ = value;
}

// -------------------------------------------------------------------

// SchemaItemUfb

// optional string ufbSchemaId = 1;
inline bool SchemaItemUfb::has_ufbschemaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemUfb::set_has_ufbschemaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemUfb::clear_has_ufbschemaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemUfb::clear_ufbschemaid() {
  if (ufbschemaid_ != &::google::protobuf::internal::kEmptyString) {
    ufbschemaid_->clear();
  }
  clear_has_ufbschemaid();
}
inline const ::std::string& SchemaItemUfb::ufbschemaid() const {
  return *ufbschemaid_;
}
inline void SchemaItemUfb::set_ufbschemaid(const ::std::string& value) {
  set_has_ufbschemaid();
  if (ufbschemaid_ == &::google::protobuf::internal::kEmptyString) {
    ufbschemaid_ = new ::std::string;
  }
  ufbschemaid_->assign(value);
}
inline void SchemaItemUfb::set_ufbschemaid(const char* value) {
  set_has_ufbschemaid();
  if (ufbschemaid_ == &::google::protobuf::internal::kEmptyString) {
    ufbschemaid_ = new ::std::string;
  }
  ufbschemaid_->assign(value);
}
inline void SchemaItemUfb::set_ufbschemaid(const char* value, size_t size) {
  set_has_ufbschemaid();
  if (ufbschemaid_ == &::google::protobuf::internal::kEmptyString) {
    ufbschemaid_ = new ::std::string;
  }
  ufbschemaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemUfb::mutable_ufbschemaid() {
  set_has_ufbschemaid();
  if (ufbschemaid_ == &::google::protobuf::internal::kEmptyString) {
    ufbschemaid_ = new ::std::string;
  }
  return ufbschemaid_;
}
inline ::std::string* SchemaItemUfb::release_ufbschemaid() {
  clear_has_ufbschemaid();
  if (ufbschemaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ufbschemaid_;
    ufbschemaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemUfb::set_allocated_ufbschemaid(::std::string* ufbschemaid) {
  if (ufbschemaid_ != &::google::protobuf::internal::kEmptyString) {
    delete ufbschemaid_;
  }
  if (ufbschemaid) {
    set_has_ufbschemaid();
    ufbschemaid_ = ufbschemaid;
  } else {
    clear_has_ufbschemaid();
    ufbschemaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ufbCaption = 2;
inline bool SchemaItemUfb::has_ufbcaption() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemUfb::set_has_ufbcaption() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemUfb::clear_has_ufbcaption() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemUfb::clear_ufbcaption() {
  if (ufbcaption_ != &::google::protobuf::internal::kEmptyString) {
    ufbcaption_->clear();
  }
  clear_has_ufbcaption();
}
inline const ::std::string& SchemaItemUfb::ufbcaption() const {
  return *ufbcaption_;
}
inline void SchemaItemUfb::set_ufbcaption(const ::std::string& value) {
  set_has_ufbcaption();
  if (ufbcaption_ == &::google::protobuf::internal::kEmptyString) {
    ufbcaption_ = new ::std::string;
  }
  ufbcaption_->assign(value);
}
inline void SchemaItemUfb::set_ufbcaption(const char* value) {
  set_has_ufbcaption();
  if (ufbcaption_ == &::google::protobuf::internal::kEmptyString) {
    ufbcaption_ = new ::std::string;
  }
  ufbcaption_->assign(value);
}
inline void SchemaItemUfb::set_ufbcaption(const char* value, size_t size) {
  set_has_ufbcaption();
  if (ufbcaption_ == &::google::protobuf::internal::kEmptyString) {
    ufbcaption_ = new ::std::string;
  }
  ufbcaption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemUfb::mutable_ufbcaption() {
  set_has_ufbcaption();
  if (ufbcaption_ == &::google::protobuf::internal::kEmptyString) {
    ufbcaption_ = new ::std::string;
  }
  return ufbcaption_;
}
inline ::std::string* SchemaItemUfb::release_ufbcaption() {
  clear_has_ufbcaption();
  if (ufbcaption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ufbcaption_;
    ufbcaption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemUfb::set_allocated_ufbcaption(::std::string* ufbcaption) {
  if (ufbcaption_ != &::google::protobuf::internal::kEmptyString) {
    delete ufbcaption_;
  }
  if (ufbcaption) {
    set_has_ufbcaption();
    ufbcaption_ = ufbcaption;
  } else {
    clear_has_ufbcaption();
    ufbcaption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ufbVersion = 3 [default = -1];
inline bool SchemaItemUfb::has_ufbversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemUfb::set_has_ufbversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemUfb::clear_has_ufbversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemUfb::clear_ufbversion() {
  ufbversion_ = -1;
  clear_has_ufbversion();
}
inline ::google::protobuf::int32 SchemaItemUfb::ufbversion() const {
  return ufbversion_;
}
inline void SchemaItemUfb::set_ufbversion(::google::protobuf::int32 value) {
  set_has_ufbversion();
  ufbversion_ = value;
}

// -------------------------------------------------------------------

// SchemaItemTerminator

// -------------------------------------------------------------------

// SchemaItemValue

// optional double weight = 1;
inline bool SchemaItemValue::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemValue::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemValue::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemValue::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemValue::weight() const {
  return weight_;
}
inline void SchemaItemValue::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// optional uint32 lineColor = 2;
inline bool SchemaItemValue::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemValue::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemValue::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemValue::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemValue::linecolor() const {
  return linecolor_;
}
inline void SchemaItemValue::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// optional uint32 fillColor = 3;
inline bool SchemaItemValue::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemValue::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemValue::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemValue::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolor() const {
  return fillcolor_;
}
inline void SchemaItemValue::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// optional string textAnalog = 4;
inline bool SchemaItemValue::has_textanalog() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemValue::set_has_textanalog() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemValue::clear_has_textanalog() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemValue::clear_textanalog() {
  if (textanalog_ != &::google::protobuf::internal::kEmptyString) {
    textanalog_->clear();
  }
  clear_has_textanalog();
}
inline const ::std::string& SchemaItemValue::textanalog() const {
  return *textanalog_;
}
inline void SchemaItemValue::set_textanalog(const ::std::string& value) {
  set_has_textanalog();
  if (textanalog_ == &::google::protobuf::internal::kEmptyString) {
    textanalog_ = new ::std::string;
  }
  textanalog_->assign(value);
}
inline void SchemaItemValue::set_textanalog(const char* value) {
  set_has_textanalog();
  if (textanalog_ == &::google::protobuf::internal::kEmptyString) {
    textanalog_ = new ::std::string;
  }
  textanalog_->assign(value);
}
inline void SchemaItemValue::set_textanalog(const char* value, size_t size) {
  set_has_textanalog();
  if (textanalog_ == &::google::protobuf::internal::kEmptyString) {
    textanalog_ = new ::std::string;
  }
  textanalog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemValue::mutable_textanalog() {
  set_has_textanalog();
  if (textanalog_ == &::google::protobuf::internal::kEmptyString) {
    textanalog_ = new ::std::string;
  }
  return textanalog_;
}
inline ::std::string* SchemaItemValue::release_textanalog() {
  clear_has_textanalog();
  if (textanalog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = textanalog_;
    textanalog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemValue::set_allocated_textanalog(::std::string* textanalog) {
  if (textanalog_ != &::google::protobuf::internal::kEmptyString) {
    delete textanalog_;
  }
  if (textanalog) {
    set_has_textanalog();
    textanalog_ = textanalog;
  } else {
    clear_has_textanalog();
    textanalog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 textColor = 5;
inline bool SchemaItemValue::has_textcolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemValue::set_has_textcolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemValue::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemValue::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolor() const {
  return textcolor_;
}
inline void SchemaItemValue::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// optional .Proto.FontParam font = 6;
inline bool SchemaItemValue::has_font() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemValue::set_has_font() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemValue::clear_has_font() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemValue::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& SchemaItemValue::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* SchemaItemValue::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* SchemaItemValue::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void SchemaItemValue::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// optional bool fill = 7;
inline bool SchemaItemValue::has_fill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItemValue::set_has_fill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItemValue::clear_has_fill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItemValue::clear_fill() {
  fill_ = false;
  clear_has_fill();
}
inline bool SchemaItemValue::fill() const {
  return fill_;
}
inline void SchemaItemValue::set_fill(bool value) {
  set_has_fill();
  fill_ = value;
}

// optional bool drawrect = 8 [default = true];
inline bool SchemaItemValue::has_drawrect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItemValue::set_has_drawrect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItemValue::clear_has_drawrect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItemValue::clear_drawrect() {
  drawrect_ = true;
  clear_has_drawrect();
}
inline bool SchemaItemValue::drawrect() const {
  return drawrect_;
}
inline void SchemaItemValue::set_drawrect(bool value) {
  set_has_drawrect();
  drawrect_ = value;
}

// optional int32 horzAlign = 9 [default = 4];
inline bool SchemaItemValue::has_horzalign() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItemValue::set_has_horzalign() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItemValue::clear_has_horzalign() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItemValue::clear_horzalign() {
  horzalign_ = 4;
  clear_has_horzalign();
}
inline ::google::protobuf::int32 SchemaItemValue::horzalign() const {
  return horzalign_;
}
inline void SchemaItemValue::set_horzalign(::google::protobuf::int32 value) {
  set_has_horzalign();
  horzalign_ = value;
}

// optional int32 vertAlign = 10 [default = 128];
inline bool SchemaItemValue::has_vertalign() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItemValue::set_has_vertalign() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItemValue::clear_has_vertalign() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItemValue::clear_vertalign() {
  vertalign_ = 128;
  clear_has_vertalign();
}
inline ::google::protobuf::int32 SchemaItemValue::vertalign() const {
  return vertalign_;
}
inline void SchemaItemValue::set_vertalign(::google::protobuf::int32 value) {
  set_has_vertalign();
  vertalign_ = value;
}

// optional string signalId = 11;
inline bool SchemaItemValue::has_signalid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SchemaItemValue::set_has_signalid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SchemaItemValue::clear_has_signalid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SchemaItemValue::clear_signalid() {
  if (signalid_ != &::google::protobuf::internal::kEmptyString) {
    signalid_->clear();
  }
  clear_has_signalid();
}
inline const ::std::string& SchemaItemValue::signalid() const {
  return *signalid_;
}
inline void SchemaItemValue::set_signalid(const ::std::string& value) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(value);
}
inline void SchemaItemValue::set_signalid(const char* value) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(value);
}
inline void SchemaItemValue::set_signalid(const char* value, size_t size) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemValue::mutable_signalid() {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  return signalid_;
}
inline ::std::string* SchemaItemValue::release_signalid() {
  clear_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalid_;
    signalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemValue::set_allocated_signalid(::std::string* signalid) {
  if (signalid_ != &::google::protobuf::internal::kEmptyString) {
    delete signalid_;
  }
  if (signalid) {
    set_has_signalid();
    signalid_ = signalid;
  } else {
    clear_has_signalid();
    signalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 signalSource = 12 [default = 0];
inline bool SchemaItemValue::has_signalsource() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SchemaItemValue::set_has_signalsource() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SchemaItemValue::clear_has_signalsource() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SchemaItemValue::clear_signalsource() {
  signalsource_ = 0;
  clear_has_signalsource();
}
inline ::google::protobuf::int32 SchemaItemValue::signalsource() const {
  return signalsource_;
}
inline void SchemaItemValue::set_signalsource(::google::protobuf::int32 value) {
  set_has_signalsource();
  signalsource_ = value;
}

// optional int32 precision = 13 [default = -1];
inline bool SchemaItemValue::has_precision() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SchemaItemValue::set_has_precision() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SchemaItemValue::clear_has_precision() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SchemaItemValue::clear_precision() {
  precision_ = -1;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemValue::precision() const {
  return precision_;
}
inline void SchemaItemValue::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional string textDiscrete0 = 14;
inline bool SchemaItemValue::has_textdiscrete0() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SchemaItemValue::set_has_textdiscrete0() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SchemaItemValue::clear_has_textdiscrete0() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SchemaItemValue::clear_textdiscrete0() {
  if (textdiscrete0_ != &::google::protobuf::internal::kEmptyString) {
    textdiscrete0_->clear();
  }
  clear_has_textdiscrete0();
}
inline const ::std::string& SchemaItemValue::textdiscrete0() const {
  return *textdiscrete0_;
}
inline void SchemaItemValue::set_textdiscrete0(const ::std::string& value) {
  set_has_textdiscrete0();
  if (textdiscrete0_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete0_ = new ::std::string;
  }
  textdiscrete0_->assign(value);
}
inline void SchemaItemValue::set_textdiscrete0(const char* value) {
  set_has_textdiscrete0();
  if (textdiscrete0_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete0_ = new ::std::string;
  }
  textdiscrete0_->assign(value);
}
inline void SchemaItemValue::set_textdiscrete0(const char* value, size_t size) {
  set_has_textdiscrete0();
  if (textdiscrete0_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete0_ = new ::std::string;
  }
  textdiscrete0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemValue::mutable_textdiscrete0() {
  set_has_textdiscrete0();
  if (textdiscrete0_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete0_ = new ::std::string;
  }
  return textdiscrete0_;
}
inline ::std::string* SchemaItemValue::release_textdiscrete0() {
  clear_has_textdiscrete0();
  if (textdiscrete0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = textdiscrete0_;
    textdiscrete0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemValue::set_allocated_textdiscrete0(::std::string* textdiscrete0) {
  if (textdiscrete0_ != &::google::protobuf::internal::kEmptyString) {
    delete textdiscrete0_;
  }
  if (textdiscrete0) {
    set_has_textdiscrete0();
    textdiscrete0_ = textdiscrete0;
  } else {
    clear_has_textdiscrete0();
    textdiscrete0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string textDiscrete1 = 15;
inline bool SchemaItemValue::has_textdiscrete1() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SchemaItemValue::set_has_textdiscrete1() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SchemaItemValue::clear_has_textdiscrete1() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SchemaItemValue::clear_textdiscrete1() {
  if (textdiscrete1_ != &::google::protobuf::internal::kEmptyString) {
    textdiscrete1_->clear();
  }
  clear_has_textdiscrete1();
}
inline const ::std::string& SchemaItemValue::textdiscrete1() const {
  return *textdiscrete1_;
}
inline void SchemaItemValue::set_textdiscrete1(const ::std::string& value) {
  set_has_textdiscrete1();
  if (textdiscrete1_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete1_ = new ::std::string;
  }
  textdiscrete1_->assign(value);
}
inline void SchemaItemValue::set_textdiscrete1(const char* value) {
  set_has_textdiscrete1();
  if (textdiscrete1_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete1_ = new ::std::string;
  }
  textdiscrete1_->assign(value);
}
inline void SchemaItemValue::set_textdiscrete1(const char* value, size_t size) {
  set_has_textdiscrete1();
  if (textdiscrete1_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete1_ = new ::std::string;
  }
  textdiscrete1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemValue::mutable_textdiscrete1() {
  set_has_textdiscrete1();
  if (textdiscrete1_ == &::google::protobuf::internal::kEmptyString) {
    textdiscrete1_ = new ::std::string;
  }
  return textdiscrete1_;
}
inline ::std::string* SchemaItemValue::release_textdiscrete1() {
  clear_has_textdiscrete1();
  if (textdiscrete1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = textdiscrete1_;
    textdiscrete1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemValue::set_allocated_textdiscrete1(::std::string* textdiscrete1) {
  if (textdiscrete1_ != &::google::protobuf::internal::kEmptyString) {
    delete textdiscrete1_;
  }
  if (textdiscrete1) {
    set_has_textdiscrete1();
    textdiscrete1_ = textdiscrete1;
  } else {
    clear_has_textdiscrete1();
    textdiscrete1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string textNonValid = 16;
inline bool SchemaItemValue::has_textnonvalid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SchemaItemValue::set_has_textnonvalid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SchemaItemValue::clear_has_textnonvalid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SchemaItemValue::clear_textnonvalid() {
  if (textnonvalid_ != &::google::protobuf::internal::kEmptyString) {
    textnonvalid_->clear();
  }
  clear_has_textnonvalid();
}
inline const ::std::string& SchemaItemValue::textnonvalid() const {
  return *textnonvalid_;
}
inline void SchemaItemValue::set_textnonvalid(const ::std::string& value) {
  set_has_textnonvalid();
  if (textnonvalid_ == &::google::protobuf::internal::kEmptyString) {
    textnonvalid_ = new ::std::string;
  }
  textnonvalid_->assign(value);
}
inline void SchemaItemValue::set_textnonvalid(const char* value) {
  set_has_textnonvalid();
  if (textnonvalid_ == &::google::protobuf::internal::kEmptyString) {
    textnonvalid_ = new ::std::string;
  }
  textnonvalid_->assign(value);
}
inline void SchemaItemValue::set_textnonvalid(const char* value, size_t size) {
  set_has_textnonvalid();
  if (textnonvalid_ == &::google::protobuf::internal::kEmptyString) {
    textnonvalid_ = new ::std::string;
  }
  textnonvalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemValue::mutable_textnonvalid() {
  set_has_textnonvalid();
  if (textnonvalid_ == &::google::protobuf::internal::kEmptyString) {
    textnonvalid_ = new ::std::string;
  }
  return textnonvalid_;
}
inline ::std::string* SchemaItemValue::release_textnonvalid() {
  clear_has_textnonvalid();
  if (textnonvalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = textnonvalid_;
    textnonvalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemValue::set_allocated_textnonvalid(::std::string* textnonvalid) {
  if (textnonvalid_ != &::google::protobuf::internal::kEmptyString) {
    delete textnonvalid_;
  }
  if (textnonvalid) {
    set_has_textnonvalid();
    textnonvalid_ = textnonvalid;
  } else {
    clear_has_textnonvalid();
    textnonvalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fillColorNonValid0 = 30;
inline bool SchemaItemValue::has_fillcolornonvalid0() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SchemaItemValue::set_has_fillcolornonvalid0() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SchemaItemValue::clear_has_fillcolornonvalid0() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SchemaItemValue::clear_fillcolornonvalid0() {
  fillcolornonvalid0_ = 0u;
  clear_has_fillcolornonvalid0();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolornonvalid0() const {
  return fillcolornonvalid0_;
}
inline void SchemaItemValue::set_fillcolornonvalid0(::google::protobuf::uint32 value) {
  set_has_fillcolornonvalid0();
  fillcolornonvalid0_ = value;
}

// optional uint32 fillColorNonValid1 = 31;
inline bool SchemaItemValue::has_fillcolornonvalid1() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SchemaItemValue::set_has_fillcolornonvalid1() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SchemaItemValue::clear_has_fillcolornonvalid1() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SchemaItemValue::clear_fillcolornonvalid1() {
  fillcolornonvalid1_ = 0u;
  clear_has_fillcolornonvalid1();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolornonvalid1() const {
  return fillcolornonvalid1_;
}
inline void SchemaItemValue::set_fillcolornonvalid1(::google::protobuf::uint32 value) {
  set_has_fillcolornonvalid1();
  fillcolornonvalid1_ = value;
}

// optional uint32 textColorNonValid0 = 32;
inline bool SchemaItemValue::has_textcolornonvalid0() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SchemaItemValue::set_has_textcolornonvalid0() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SchemaItemValue::clear_has_textcolornonvalid0() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SchemaItemValue::clear_textcolornonvalid0() {
  textcolornonvalid0_ = 0u;
  clear_has_textcolornonvalid0();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolornonvalid0() const {
  return textcolornonvalid0_;
}
inline void SchemaItemValue::set_textcolornonvalid0(::google::protobuf::uint32 value) {
  set_has_textcolornonvalid0();
  textcolornonvalid0_ = value;
}

// optional uint32 textColorNonValid1 = 33;
inline bool SchemaItemValue::has_textcolornonvalid1() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SchemaItemValue::set_has_textcolornonvalid1() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SchemaItemValue::clear_has_textcolornonvalid1() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SchemaItemValue::clear_textcolornonvalid1() {
  textcolornonvalid1_ = 0u;
  clear_has_textcolornonvalid1();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolornonvalid1() const {
  return textcolornonvalid1_;
}
inline void SchemaItemValue::set_textcolornonvalid1(::google::protobuf::uint32 value) {
  set_has_textcolornonvalid1();
  textcolornonvalid1_ = value;
}

// optional uint32 fillColorAnalog0 = 42;
inline bool SchemaItemValue::has_fillcoloranalog0() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SchemaItemValue::set_has_fillcoloranalog0() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SchemaItemValue::clear_has_fillcoloranalog0() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SchemaItemValue::clear_fillcoloranalog0() {
  fillcoloranalog0_ = 0u;
  clear_has_fillcoloranalog0();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcoloranalog0() const {
  return fillcoloranalog0_;
}
inline void SchemaItemValue::set_fillcoloranalog0(::google::protobuf::uint32 value) {
  set_has_fillcoloranalog0();
  fillcoloranalog0_ = value;
}

// optional uint32 fillColorAnalog1 = 43;
inline bool SchemaItemValue::has_fillcoloranalog1() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SchemaItemValue::set_has_fillcoloranalog1() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SchemaItemValue::clear_has_fillcoloranalog1() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SchemaItemValue::clear_fillcoloranalog1() {
  fillcoloranalog1_ = 0u;
  clear_has_fillcoloranalog1();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcoloranalog1() const {
  return fillcoloranalog1_;
}
inline void SchemaItemValue::set_fillcoloranalog1(::google::protobuf::uint32 value) {
  set_has_fillcoloranalog1();
  fillcoloranalog1_ = value;
}

// optional uint32 textColorAnalog0 = 44;
inline bool SchemaItemValue::has_textcoloranalog0() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SchemaItemValue::set_has_textcoloranalog0() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SchemaItemValue::clear_has_textcoloranalog0() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SchemaItemValue::clear_textcoloranalog0() {
  textcoloranalog0_ = 0u;
  clear_has_textcoloranalog0();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcoloranalog0() const {
  return textcoloranalog0_;
}
inline void SchemaItemValue::set_textcoloranalog0(::google::protobuf::uint32 value) {
  set_has_textcoloranalog0();
  textcoloranalog0_ = value;
}

// optional uint32 textColorAnalog1 = 45;
inline bool SchemaItemValue::has_textcoloranalog1() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SchemaItemValue::set_has_textcoloranalog1() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SchemaItemValue::clear_has_textcoloranalog1() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SchemaItemValue::clear_textcoloranalog1() {
  textcoloranalog1_ = 0u;
  clear_has_textcoloranalog1();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcoloranalog1() const {
  return textcoloranalog1_;
}
inline void SchemaItemValue::set_textcoloranalog1(::google::protobuf::uint32 value) {
  set_has_textcoloranalog1();
  textcoloranalog1_ = value;
}

// optional uint32 fillColorDiscrYes0 = 46;
inline bool SchemaItemValue::has_fillcolordiscryes0() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SchemaItemValue::set_has_fillcolordiscryes0() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SchemaItemValue::clear_has_fillcolordiscryes0() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SchemaItemValue::clear_fillcolordiscryes0() {
  fillcolordiscryes0_ = 0u;
  clear_has_fillcolordiscryes0();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolordiscryes0() const {
  return fillcolordiscryes0_;
}
inline void SchemaItemValue::set_fillcolordiscryes0(::google::protobuf::uint32 value) {
  set_has_fillcolordiscryes0();
  fillcolordiscryes0_ = value;
}

// optional uint32 fillColorDiscrYes1 = 47;
inline bool SchemaItemValue::has_fillcolordiscryes1() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SchemaItemValue::set_has_fillcolordiscryes1() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SchemaItemValue::clear_has_fillcolordiscryes1() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SchemaItemValue::clear_fillcolordiscryes1() {
  fillcolordiscryes1_ = 0u;
  clear_has_fillcolordiscryes1();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolordiscryes1() const {
  return fillcolordiscryes1_;
}
inline void SchemaItemValue::set_fillcolordiscryes1(::google::protobuf::uint32 value) {
  set_has_fillcolordiscryes1();
  fillcolordiscryes1_ = value;
}

// optional uint32 textColorDiscrYes0 = 48;
inline bool SchemaItemValue::has_textcolordiscryes0() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SchemaItemValue::set_has_textcolordiscryes0() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SchemaItemValue::clear_has_textcolordiscryes0() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SchemaItemValue::clear_textcolordiscryes0() {
  textcolordiscryes0_ = 0u;
  clear_has_textcolordiscryes0();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolordiscryes0() const {
  return textcolordiscryes0_;
}
inline void SchemaItemValue::set_textcolordiscryes0(::google::protobuf::uint32 value) {
  set_has_textcolordiscryes0();
  textcolordiscryes0_ = value;
}

// optional uint32 textColorDiscrYes1 = 49;
inline bool SchemaItemValue::has_textcolordiscryes1() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SchemaItemValue::set_has_textcolordiscryes1() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SchemaItemValue::clear_has_textcolordiscryes1() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SchemaItemValue::clear_textcolordiscryes1() {
  textcolordiscryes1_ = 0u;
  clear_has_textcolordiscryes1();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolordiscryes1() const {
  return textcolordiscryes1_;
}
inline void SchemaItemValue::set_textcolordiscryes1(::google::protobuf::uint32 value) {
  set_has_textcolordiscryes1();
  textcolordiscryes1_ = value;
}

// optional uint32 fillColorDiscrNo0 = 50;
inline bool SchemaItemValue::has_fillcolordiscrno0() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SchemaItemValue::set_has_fillcolordiscrno0() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SchemaItemValue::clear_has_fillcolordiscrno0() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SchemaItemValue::clear_fillcolordiscrno0() {
  fillcolordiscrno0_ = 0u;
  clear_has_fillcolordiscrno0();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolordiscrno0() const {
  return fillcolordiscrno0_;
}
inline void SchemaItemValue::set_fillcolordiscrno0(::google::protobuf::uint32 value) {
  set_has_fillcolordiscrno0();
  fillcolordiscrno0_ = value;
}

// optional uint32 fillColorDiscrNo1 = 51;
inline bool SchemaItemValue::has_fillcolordiscrno1() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SchemaItemValue::set_has_fillcolordiscrno1() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SchemaItemValue::clear_has_fillcolordiscrno1() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SchemaItemValue::clear_fillcolordiscrno1() {
  fillcolordiscrno1_ = 0u;
  clear_has_fillcolordiscrno1();
}
inline ::google::protobuf::uint32 SchemaItemValue::fillcolordiscrno1() const {
  return fillcolordiscrno1_;
}
inline void SchemaItemValue::set_fillcolordiscrno1(::google::protobuf::uint32 value) {
  set_has_fillcolordiscrno1();
  fillcolordiscrno1_ = value;
}

// optional uint32 textColorDiscrNo0 = 52;
inline bool SchemaItemValue::has_textcolordiscrno0() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SchemaItemValue::set_has_textcolordiscrno0() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SchemaItemValue::clear_has_textcolordiscrno0() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SchemaItemValue::clear_textcolordiscrno0() {
  textcolordiscrno0_ = 0u;
  clear_has_textcolordiscrno0();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolordiscrno0() const {
  return textcolordiscrno0_;
}
inline void SchemaItemValue::set_textcolordiscrno0(::google::protobuf::uint32 value) {
  set_has_textcolordiscrno0();
  textcolordiscrno0_ = value;
}

// optional uint32 textColorDiscrNo1 = 53;
inline bool SchemaItemValue::has_textcolordiscrno1() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SchemaItemValue::set_has_textcolordiscrno1() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SchemaItemValue::clear_has_textcolordiscrno1() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SchemaItemValue::clear_textcolordiscrno1() {
  textcolordiscrno1_ = 0u;
  clear_has_textcolordiscrno1();
}
inline ::google::protobuf::uint32 SchemaItemValue::textcolordiscrno1() const {
  return textcolordiscrno1_;
}
inline void SchemaItemValue::set_textcolordiscrno1(::google::protobuf::uint32 value) {
  set_has_textcolordiscrno1();
  textcolordiscrno1_ = value;
}

// -------------------------------------------------------------------

// SchemaItemBus

// optional string busTypeId = 2;
inline bool SchemaItemBus::has_bustypeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemBus::set_has_bustypeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemBus::clear_has_bustypeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemBus::clear_bustypeid() {
  if (bustypeid_ != &::google::protobuf::internal::kEmptyString) {
    bustypeid_->clear();
  }
  clear_has_bustypeid();
}
inline const ::std::string& SchemaItemBus::bustypeid() const {
  return *bustypeid_;
}
inline void SchemaItemBus::set_bustypeid(const ::std::string& value) {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  bustypeid_->assign(value);
}
inline void SchemaItemBus::set_bustypeid(const char* value) {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  bustypeid_->assign(value);
}
inline void SchemaItemBus::set_bustypeid(const char* value, size_t size) {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  bustypeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemBus::mutable_bustypeid() {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  return bustypeid_;
}
inline ::std::string* SchemaItemBus::release_bustypeid() {
  clear_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bustypeid_;
    bustypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemBus::set_allocated_bustypeid(::std::string* bustypeid) {
  if (bustypeid_ != &::google::protobuf::internal::kEmptyString) {
    delete bustypeid_;
  }
  if (bustypeid) {
    set_has_bustypeid();
    bustypeid_ = bustypeid;
  } else {
    clear_has_bustypeid();
    bustypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 busTypeHash = 3;
inline bool SchemaItemBus::has_bustypehash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemBus::set_has_bustypehash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemBus::clear_has_bustypehash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemBus::clear_bustypehash() {
  bustypehash_ = GOOGLE_ULONGLONG(0);
  clear_has_bustypehash();
}
inline ::google::protobuf::uint64 SchemaItemBus::bustypehash() const {
  return bustypehash_;
}
inline void SchemaItemBus::set_bustypehash(::google::protobuf::uint64 value) {
  set_has_bustypehash();
  bustypehash_ = value;
}

// optional string busTypeXml = 4;
inline bool SchemaItemBus::has_bustypexml() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemBus::set_has_bustypexml() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemBus::clear_has_bustypexml() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemBus::clear_bustypexml() {
  if (bustypexml_ != &::google::protobuf::internal::kEmptyString) {
    bustypexml_->clear();
  }
  clear_has_bustypexml();
}
inline const ::std::string& SchemaItemBus::bustypexml() const {
  return *bustypexml_;
}
inline void SchemaItemBus::set_bustypexml(const ::std::string& value) {
  set_has_bustypexml();
  if (bustypexml_ == &::google::protobuf::internal::kEmptyString) {
    bustypexml_ = new ::std::string;
  }
  bustypexml_->assign(value);
}
inline void SchemaItemBus::set_bustypexml(const char* value) {
  set_has_bustypexml();
  if (bustypexml_ == &::google::protobuf::internal::kEmptyString) {
    bustypexml_ = new ::std::string;
  }
  bustypexml_->assign(value);
}
inline void SchemaItemBus::set_bustypexml(const char* value, size_t size) {
  set_has_bustypexml();
  if (bustypexml_ == &::google::protobuf::internal::kEmptyString) {
    bustypexml_ = new ::std::string;
  }
  bustypexml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemBus::mutable_bustypexml() {
  set_has_bustypexml();
  if (bustypexml_ == &::google::protobuf::internal::kEmptyString) {
    bustypexml_ = new ::std::string;
  }
  return bustypexml_;
}
inline ::std::string* SchemaItemBus::release_bustypexml() {
  clear_has_bustypexml();
  if (bustypexml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bustypexml_;
    bustypexml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemBus::set_allocated_bustypexml(::std::string* bustypexml) {
  if (bustypexml_ != &::google::protobuf::internal::kEmptyString) {
    delete bustypexml_;
  }
  if (bustypexml) {
    set_has_bustypexml();
    bustypexml_ = bustypexml;
  } else {
    clear_has_bustypexml();
    bustypexml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SchemaItemBusComposer

// -------------------------------------------------------------------

// SchemaItemBusExtractor

// -------------------------------------------------------------------

// SchemaItemControl

// optional string styleSheet = 1;
inline bool SchemaItemControl::has_stylesheet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemControl::set_has_stylesheet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemControl::clear_has_stylesheet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemControl::clear_stylesheet() {
  if (stylesheet_ != &::google::protobuf::internal::kEmptyString) {
    stylesheet_->clear();
  }
  clear_has_stylesheet();
}
inline const ::std::string& SchemaItemControl::stylesheet() const {
  return *stylesheet_;
}
inline void SchemaItemControl::set_stylesheet(const ::std::string& value) {
  set_has_stylesheet();
  if (stylesheet_ == &::google::protobuf::internal::kEmptyString) {
    stylesheet_ = new ::std::string;
  }
  stylesheet_->assign(value);
}
inline void SchemaItemControl::set_stylesheet(const char* value) {
  set_has_stylesheet();
  if (stylesheet_ == &::google::protobuf::internal::kEmptyString) {
    stylesheet_ = new ::std::string;
  }
  stylesheet_->assign(value);
}
inline void SchemaItemControl::set_stylesheet(const char* value, size_t size) {
  set_has_stylesheet();
  if (stylesheet_ == &::google::protobuf::internal::kEmptyString) {
    stylesheet_ = new ::std::string;
  }
  stylesheet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemControl::mutable_stylesheet() {
  set_has_stylesheet();
  if (stylesheet_ == &::google::protobuf::internal::kEmptyString) {
    stylesheet_ = new ::std::string;
  }
  return stylesheet_;
}
inline ::std::string* SchemaItemControl::release_stylesheet() {
  clear_has_stylesheet();
  if (stylesheet_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stylesheet_;
    stylesheet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemControl::set_allocated_stylesheet(::std::string* stylesheet) {
  if (stylesheet_ != &::google::protobuf::internal::kEmptyString) {
    delete stylesheet_;
  }
  if (stylesheet) {
    set_has_stylesheet();
    stylesheet_ = stylesheet;
  } else {
    clear_has_stylesheet();
    stylesheet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string toolTip = 2;
inline bool SchemaItemControl::has_tooltip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemControl::set_has_tooltip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemControl::clear_has_tooltip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemControl::clear_tooltip() {
  if (tooltip_ != &::google::protobuf::internal::kEmptyString) {
    tooltip_->clear();
  }
  clear_has_tooltip();
}
inline const ::std::string& SchemaItemControl::tooltip() const {
  return *tooltip_;
}
inline void SchemaItemControl::set_tooltip(const ::std::string& value) {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::kEmptyString) {
    tooltip_ = new ::std::string;
  }
  tooltip_->assign(value);
}
inline void SchemaItemControl::set_tooltip(const char* value) {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::kEmptyString) {
    tooltip_ = new ::std::string;
  }
  tooltip_->assign(value);
}
inline void SchemaItemControl::set_tooltip(const char* value, size_t size) {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::kEmptyString) {
    tooltip_ = new ::std::string;
  }
  tooltip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemControl::mutable_tooltip() {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::kEmptyString) {
    tooltip_ = new ::std::string;
  }
  return tooltip_;
}
inline ::std::string* SchemaItemControl::release_tooltip() {
  clear_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tooltip_;
    tooltip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemControl::set_allocated_tooltip(::std::string* tooltip) {
  if (tooltip_ != &::google::protobuf::internal::kEmptyString) {
    delete tooltip_;
  }
  if (tooltip) {
    set_has_tooltip();
    tooltip_ = tooltip;
  } else {
    clear_has_tooltip();
    tooltip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SchemaItemPushButton

// optional string text = 1;
inline bool SchemaItemPushButton::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemPushButton::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemPushButton::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemPushButton::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SchemaItemPushButton::text() const {
  return *text_;
}
inline void SchemaItemPushButton::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SchemaItemPushButton::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SchemaItemPushButton::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemPushButton::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SchemaItemPushButton::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemPushButton::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool checkable = 2;
inline bool SchemaItemPushButton::has_checkable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemPushButton::set_has_checkable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemPushButton::clear_has_checkable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemPushButton::clear_checkable() {
  checkable_ = false;
  clear_has_checkable();
}
inline bool SchemaItemPushButton::checkable() const {
  return checkable_;
}
inline void SchemaItemPushButton::set_checkable(bool value) {
  set_has_checkable();
  checkable_ = value;
}

// optional bool checkedDefault = 3;
inline bool SchemaItemPushButton::has_checkeddefault() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemPushButton::set_has_checkeddefault() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemPushButton::clear_has_checkeddefault() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemPushButton::clear_checkeddefault() {
  checkeddefault_ = false;
  clear_has_checkeddefault();
}
inline bool SchemaItemPushButton::checkeddefault() const {
  return checkeddefault_;
}
inline void SchemaItemPushButton::set_checkeddefault(bool value) {
  set_has_checkeddefault();
  checkeddefault_ = value;
}

// optional bool autoRepeat = 4;
inline bool SchemaItemPushButton::has_autorepeat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemPushButton::set_has_autorepeat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemPushButton::clear_has_autorepeat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemPushButton::clear_autorepeat() {
  autorepeat_ = false;
  clear_has_autorepeat();
}
inline bool SchemaItemPushButton::autorepeat() const {
  return autorepeat_;
}
inline void SchemaItemPushButton::set_autorepeat(bool value) {
  set_has_autorepeat();
  autorepeat_ = value;
}

// optional int32 autoRepeatDelay = 5;
inline bool SchemaItemPushButton::has_autorepeatdelay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemPushButton::set_has_autorepeatdelay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemPushButton::clear_has_autorepeatdelay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemPushButton::clear_autorepeatdelay() {
  autorepeatdelay_ = 0;
  clear_has_autorepeatdelay();
}
inline ::google::protobuf::int32 SchemaItemPushButton::autorepeatdelay() const {
  return autorepeatdelay_;
}
inline void SchemaItemPushButton::set_autorepeatdelay(::google::protobuf::int32 value) {
  set_has_autorepeatdelay();
  autorepeatdelay_ = value;
}

// optional int32 autoRepeatInterval = 6;
inline bool SchemaItemPushButton::has_autorepeatinterval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemPushButton::set_has_autorepeatinterval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemPushButton::clear_has_autorepeatinterval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemPushButton::clear_autorepeatinterval() {
  autorepeatinterval_ = 0;
  clear_has_autorepeatinterval();
}
inline ::google::protobuf::int32 SchemaItemPushButton::autorepeatinterval() const {
  return autorepeatinterval_;
}
inline void SchemaItemPushButton::set_autorepeatinterval(::google::protobuf::int32 value) {
  set_has_autorepeatinterval();
  autorepeatinterval_ = value;
}

// optional string scriptAfterCreate = 21;
inline bool SchemaItemPushButton::has_scriptaftercreate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItemPushButton::set_has_scriptaftercreate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItemPushButton::clear_has_scriptaftercreate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItemPushButton::clear_scriptaftercreate() {
  if (scriptaftercreate_ != &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_->clear();
  }
  clear_has_scriptaftercreate();
}
inline const ::std::string& SchemaItemPushButton::scriptaftercreate() const {
  return *scriptaftercreate_;
}
inline void SchemaItemPushButton::set_scriptaftercreate(const ::std::string& value) {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  scriptaftercreate_->assign(value);
}
inline void SchemaItemPushButton::set_scriptaftercreate(const char* value) {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  scriptaftercreate_->assign(value);
}
inline void SchemaItemPushButton::set_scriptaftercreate(const char* value, size_t size) {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  scriptaftercreate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemPushButton::mutable_scriptaftercreate() {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  return scriptaftercreate_;
}
inline ::std::string* SchemaItemPushButton::release_scriptaftercreate() {
  clear_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptaftercreate_;
    scriptaftercreate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemPushButton::set_allocated_scriptaftercreate(::std::string* scriptaftercreate) {
  if (scriptaftercreate_ != &::google::protobuf::internal::kEmptyString) {
    delete scriptaftercreate_;
  }
  if (scriptaftercreate) {
    set_has_scriptaftercreate();
    scriptaftercreate_ = scriptaftercreate;
  } else {
    clear_has_scriptaftercreate();
    scriptaftercreate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptClicked = 22;
inline bool SchemaItemPushButton::has_scriptclicked() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItemPushButton::set_has_scriptclicked() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItemPushButton::clear_has_scriptclicked() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItemPushButton::clear_scriptclicked() {
  if (scriptclicked_ != &::google::protobuf::internal::kEmptyString) {
    scriptclicked_->clear();
  }
  clear_has_scriptclicked();
}
inline const ::std::string& SchemaItemPushButton::scriptclicked() const {
  return *scriptclicked_;
}
inline void SchemaItemPushButton::set_scriptclicked(const ::std::string& value) {
  set_has_scriptclicked();
  if (scriptclicked_ == &::google::protobuf::internal::kEmptyString) {
    scriptclicked_ = new ::std::string;
  }
  scriptclicked_->assign(value);
}
inline void SchemaItemPushButton::set_scriptclicked(const char* value) {
  set_has_scriptclicked();
  if (scriptclicked_ == &::google::protobuf::internal::kEmptyString) {
    scriptclicked_ = new ::std::string;
  }
  scriptclicked_->assign(value);
}
inline void SchemaItemPushButton::set_scriptclicked(const char* value, size_t size) {
  set_has_scriptclicked();
  if (scriptclicked_ == &::google::protobuf::internal::kEmptyString) {
    scriptclicked_ = new ::std::string;
  }
  scriptclicked_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemPushButton::mutable_scriptclicked() {
  set_has_scriptclicked();
  if (scriptclicked_ == &::google::protobuf::internal::kEmptyString) {
    scriptclicked_ = new ::std::string;
  }
  return scriptclicked_;
}
inline ::std::string* SchemaItemPushButton::release_scriptclicked() {
  clear_has_scriptclicked();
  if (scriptclicked_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptclicked_;
    scriptclicked_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemPushButton::set_allocated_scriptclicked(::std::string* scriptclicked) {
  if (scriptclicked_ != &::google::protobuf::internal::kEmptyString) {
    delete scriptclicked_;
  }
  if (scriptclicked) {
    set_has_scriptclicked();
    scriptclicked_ = scriptclicked;
  } else {
    clear_has_scriptclicked();
    scriptclicked_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptPressed = 23;
inline bool SchemaItemPushButton::has_scriptpressed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItemPushButton::set_has_scriptpressed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItemPushButton::clear_has_scriptpressed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItemPushButton::clear_scriptpressed() {
  if (scriptpressed_ != &::google::protobuf::internal::kEmptyString) {
    scriptpressed_->clear();
  }
  clear_has_scriptpressed();
}
inline const ::std::string& SchemaItemPushButton::scriptpressed() const {
  return *scriptpressed_;
}
inline void SchemaItemPushButton::set_scriptpressed(const ::std::string& value) {
  set_has_scriptpressed();
  if (scriptpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptpressed_ = new ::std::string;
  }
  scriptpressed_->assign(value);
}
inline void SchemaItemPushButton::set_scriptpressed(const char* value) {
  set_has_scriptpressed();
  if (scriptpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptpressed_ = new ::std::string;
  }
  scriptpressed_->assign(value);
}
inline void SchemaItemPushButton::set_scriptpressed(const char* value, size_t size) {
  set_has_scriptpressed();
  if (scriptpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptpressed_ = new ::std::string;
  }
  scriptpressed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemPushButton::mutable_scriptpressed() {
  set_has_scriptpressed();
  if (scriptpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptpressed_ = new ::std::string;
  }
  return scriptpressed_;
}
inline ::std::string* SchemaItemPushButton::release_scriptpressed() {
  clear_has_scriptpressed();
  if (scriptpressed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptpressed_;
    scriptpressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemPushButton::set_allocated_scriptpressed(::std::string* scriptpressed) {
  if (scriptpressed_ != &::google::protobuf::internal::kEmptyString) {
    delete scriptpressed_;
  }
  if (scriptpressed) {
    set_has_scriptpressed();
    scriptpressed_ = scriptpressed;
  } else {
    clear_has_scriptpressed();
    scriptpressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptReleased = 24;
inline bool SchemaItemPushButton::has_scriptreleased() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItemPushButton::set_has_scriptreleased() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItemPushButton::clear_has_scriptreleased() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItemPushButton::clear_scriptreleased() {
  if (scriptreleased_ != &::google::protobuf::internal::kEmptyString) {
    scriptreleased_->clear();
  }
  clear_has_scriptreleased();
}
inline const ::std::string& SchemaItemPushButton::scriptreleased() const {
  return *scriptreleased_;
}
inline void SchemaItemPushButton::set_scriptreleased(const ::std::string& value) {
  set_has_scriptreleased();
  if (scriptreleased_ == &::google::protobuf::internal::kEmptyString) {
    scriptreleased_ = new ::std::string;
  }
  scriptreleased_->assign(value);
}
inline void SchemaItemPushButton::set_scriptreleased(const char* value) {
  set_has_scriptreleased();
  if (scriptreleased_ == &::google::protobuf::internal::kEmptyString) {
    scriptreleased_ = new ::std::string;
  }
  scriptreleased_->assign(value);
}
inline void SchemaItemPushButton::set_scriptreleased(const char* value, size_t size) {
  set_has_scriptreleased();
  if (scriptreleased_ == &::google::protobuf::internal::kEmptyString) {
    scriptreleased_ = new ::std::string;
  }
  scriptreleased_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemPushButton::mutable_scriptreleased() {
  set_has_scriptreleased();
  if (scriptreleased_ == &::google::protobuf::internal::kEmptyString) {
    scriptreleased_ = new ::std::string;
  }
  return scriptreleased_;
}
inline ::std::string* SchemaItemPushButton::release_scriptreleased() {
  clear_has_scriptreleased();
  if (scriptreleased_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptreleased_;
    scriptreleased_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemPushButton::set_allocated_scriptreleased(::std::string* scriptreleased) {
  if (scriptreleased_ != &::google::protobuf::internal::kEmptyString) {
    delete scriptreleased_;
  }
  if (scriptreleased) {
    set_has_scriptreleased();
    scriptreleased_ = scriptreleased;
  } else {
    clear_has_scriptreleased();
    scriptreleased_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptToggled = 25;
inline bool SchemaItemPushButton::has_scripttoggled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SchemaItemPushButton::set_has_scripttoggled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SchemaItemPushButton::clear_has_scripttoggled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SchemaItemPushButton::clear_scripttoggled() {
  if (scripttoggled_ != &::google::protobuf::internal::kEmptyString) {
    scripttoggled_->clear();
  }
  clear_has_scripttoggled();
}
inline const ::std::string& SchemaItemPushButton::scripttoggled() const {
  return *scripttoggled_;
}
inline void SchemaItemPushButton::set_scripttoggled(const ::std::string& value) {
  set_has_scripttoggled();
  if (scripttoggled_ == &::google::protobuf::internal::kEmptyString) {
    scripttoggled_ = new ::std::string;
  }
  scripttoggled_->assign(value);
}
inline void SchemaItemPushButton::set_scripttoggled(const char* value) {
  set_has_scripttoggled();
  if (scripttoggled_ == &::google::protobuf::internal::kEmptyString) {
    scripttoggled_ = new ::std::string;
  }
  scripttoggled_->assign(value);
}
inline void SchemaItemPushButton::set_scripttoggled(const char* value, size_t size) {
  set_has_scripttoggled();
  if (scripttoggled_ == &::google::protobuf::internal::kEmptyString) {
    scripttoggled_ = new ::std::string;
  }
  scripttoggled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemPushButton::mutable_scripttoggled() {
  set_has_scripttoggled();
  if (scripttoggled_ == &::google::protobuf::internal::kEmptyString) {
    scripttoggled_ = new ::std::string;
  }
  return scripttoggled_;
}
inline ::std::string* SchemaItemPushButton::release_scripttoggled() {
  clear_has_scripttoggled();
  if (scripttoggled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scripttoggled_;
    scripttoggled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemPushButton::set_allocated_scripttoggled(::std::string* scripttoggled) {
  if (scripttoggled_ != &::google::protobuf::internal::kEmptyString) {
    delete scripttoggled_;
  }
  if (scripttoggled) {
    set_has_scripttoggled();
    scripttoggled_ = scripttoggled;
  } else {
    clear_has_scripttoggled();
    scripttoggled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SchemaItemLineEdit

// optional string text = 1;
inline bool SchemaItemLineEdit::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemLineEdit::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemLineEdit::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemLineEdit::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SchemaItemLineEdit::text() const {
  return *text_;
}
inline void SchemaItemLineEdit::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SchemaItemLineEdit::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SchemaItemLineEdit::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemLineEdit::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SchemaItemLineEdit::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemLineEdit::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 horzAlign = 2;
inline bool SchemaItemLineEdit::has_horzalign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemLineEdit::set_has_horzalign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemLineEdit::clear_has_horzalign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemLineEdit::clear_horzalign() {
  horzalign_ = 0;
  clear_has_horzalign();
}
inline ::google::protobuf::int32 SchemaItemLineEdit::horzalign() const {
  return horzalign_;
}
inline void SchemaItemLineEdit::set_horzalign(::google::protobuf::int32 value) {
  set_has_horzalign();
  horzalign_ = value;
}

// optional int32 vertAlign = 3;
inline bool SchemaItemLineEdit::has_vertalign() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemLineEdit::set_has_vertalign() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemLineEdit::clear_has_vertalign() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemLineEdit::clear_vertalign() {
  vertalign_ = 0;
  clear_has_vertalign();
}
inline ::google::protobuf::int32 SchemaItemLineEdit::vertalign() const {
  return vertalign_;
}
inline void SchemaItemLineEdit::set_vertalign(::google::protobuf::int32 value) {
  set_has_vertalign();
  vertalign_ = value;
}

// optional int32 maxLength = 4;
inline bool SchemaItemLineEdit::has_maxlength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemLineEdit::set_has_maxlength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemLineEdit::clear_has_maxlength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemLineEdit::clear_maxlength() {
  maxlength_ = 0;
  clear_has_maxlength();
}
inline ::google::protobuf::int32 SchemaItemLineEdit::maxlength() const {
  return maxlength_;
}
inline void SchemaItemLineEdit::set_maxlength(::google::protobuf::int32 value) {
  set_has_maxlength();
  maxlength_ = value;
}

// optional string placeholderText = 5;
inline bool SchemaItemLineEdit::has_placeholdertext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemLineEdit::set_has_placeholdertext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemLineEdit::clear_has_placeholdertext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemLineEdit::clear_placeholdertext() {
  if (placeholdertext_ != &::google::protobuf::internal::kEmptyString) {
    placeholdertext_->clear();
  }
  clear_has_placeholdertext();
}
inline const ::std::string& SchemaItemLineEdit::placeholdertext() const {
  return *placeholdertext_;
}
inline void SchemaItemLineEdit::set_placeholdertext(const ::std::string& value) {
  set_has_placeholdertext();
  if (placeholdertext_ == &::google::protobuf::internal::kEmptyString) {
    placeholdertext_ = new ::std::string;
  }
  placeholdertext_->assign(value);
}
inline void SchemaItemLineEdit::set_placeholdertext(const char* value) {
  set_has_placeholdertext();
  if (placeholdertext_ == &::google::protobuf::internal::kEmptyString) {
    placeholdertext_ = new ::std::string;
  }
  placeholdertext_->assign(value);
}
inline void SchemaItemLineEdit::set_placeholdertext(const char* value, size_t size) {
  set_has_placeholdertext();
  if (placeholdertext_ == &::google::protobuf::internal::kEmptyString) {
    placeholdertext_ = new ::std::string;
  }
  placeholdertext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemLineEdit::mutable_placeholdertext() {
  set_has_placeholdertext();
  if (placeholdertext_ == &::google::protobuf::internal::kEmptyString) {
    placeholdertext_ = new ::std::string;
  }
  return placeholdertext_;
}
inline ::std::string* SchemaItemLineEdit::release_placeholdertext() {
  clear_has_placeholdertext();
  if (placeholdertext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = placeholdertext_;
    placeholdertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemLineEdit::set_allocated_placeholdertext(::std::string* placeholdertext) {
  if (placeholdertext_ != &::google::protobuf::internal::kEmptyString) {
    delete placeholdertext_;
  }
  if (placeholdertext) {
    set_has_placeholdertext();
    placeholdertext_ = placeholdertext;
  } else {
    clear_has_placeholdertext();
    placeholdertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool readOnly = 6;
inline bool SchemaItemLineEdit::has_readonly() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemLineEdit::set_has_readonly() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemLineEdit::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemLineEdit::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool SchemaItemLineEdit::readonly() const {
  return readonly_;
}
inline void SchemaItemLineEdit::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
}

// optional string scriptAfterCreate = 21;
inline bool SchemaItemLineEdit::has_scriptaftercreate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItemLineEdit::set_has_scriptaftercreate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItemLineEdit::clear_has_scriptaftercreate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItemLineEdit::clear_scriptaftercreate() {
  if (scriptaftercreate_ != &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_->clear();
  }
  clear_has_scriptaftercreate();
}
inline const ::std::string& SchemaItemLineEdit::scriptaftercreate() const {
  return *scriptaftercreate_;
}
inline void SchemaItemLineEdit::set_scriptaftercreate(const ::std::string& value) {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  scriptaftercreate_->assign(value);
}
inline void SchemaItemLineEdit::set_scriptaftercreate(const char* value) {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  scriptaftercreate_->assign(value);
}
inline void SchemaItemLineEdit::set_scriptaftercreate(const char* value, size_t size) {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  scriptaftercreate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemLineEdit::mutable_scriptaftercreate() {
  set_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    scriptaftercreate_ = new ::std::string;
  }
  return scriptaftercreate_;
}
inline ::std::string* SchemaItemLineEdit::release_scriptaftercreate() {
  clear_has_scriptaftercreate();
  if (scriptaftercreate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptaftercreate_;
    scriptaftercreate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemLineEdit::set_allocated_scriptaftercreate(::std::string* scriptaftercreate) {
  if (scriptaftercreate_ != &::google::protobuf::internal::kEmptyString) {
    delete scriptaftercreate_;
  }
  if (scriptaftercreate) {
    set_has_scriptaftercreate();
    scriptaftercreate_ = scriptaftercreate;
  } else {
    clear_has_scriptaftercreate();
    scriptaftercreate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptEditingFinished = 22;
inline bool SchemaItemLineEdit::has_scripteditingfinished() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItemLineEdit::set_has_scripteditingfinished() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItemLineEdit::clear_has_scripteditingfinished() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItemLineEdit::clear_scripteditingfinished() {
  if (scripteditingfinished_ != &::google::protobuf::internal::kEmptyString) {
    scripteditingfinished_->clear();
  }
  clear_has_scripteditingfinished();
}
inline const ::std::string& SchemaItemLineEdit::scripteditingfinished() const {
  return *scripteditingfinished_;
}
inline void SchemaItemLineEdit::set_scripteditingfinished(const ::std::string& value) {
  set_has_scripteditingfinished();
  if (scripteditingfinished_ == &::google::protobuf::internal::kEmptyString) {
    scripteditingfinished_ = new ::std::string;
  }
  scripteditingfinished_->assign(value);
}
inline void SchemaItemLineEdit::set_scripteditingfinished(const char* value) {
  set_has_scripteditingfinished();
  if (scripteditingfinished_ == &::google::protobuf::internal::kEmptyString) {
    scripteditingfinished_ = new ::std::string;
  }
  scripteditingfinished_->assign(value);
}
inline void SchemaItemLineEdit::set_scripteditingfinished(const char* value, size_t size) {
  set_has_scripteditingfinished();
  if (scripteditingfinished_ == &::google::protobuf::internal::kEmptyString) {
    scripteditingfinished_ = new ::std::string;
  }
  scripteditingfinished_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemLineEdit::mutable_scripteditingfinished() {
  set_has_scripteditingfinished();
  if (scripteditingfinished_ == &::google::protobuf::internal::kEmptyString) {
    scripteditingfinished_ = new ::std::string;
  }
  return scripteditingfinished_;
}
inline ::std::string* SchemaItemLineEdit::release_scripteditingfinished() {
  clear_has_scripteditingfinished();
  if (scripteditingfinished_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scripteditingfinished_;
    scripteditingfinished_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemLineEdit::set_allocated_scripteditingfinished(::std::string* scripteditingfinished) {
  if (scripteditingfinished_ != &::google::protobuf::internal::kEmptyString) {
    delete scripteditingfinished_;
  }
  if (scripteditingfinished) {
    set_has_scripteditingfinished();
    scripteditingfinished_ = scripteditingfinished;
  } else {
    clear_has_scripteditingfinished();
    scripteditingfinished_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptReturnPressed = 23;
inline bool SchemaItemLineEdit::has_scriptreturnpressed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItemLineEdit::set_has_scriptreturnpressed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItemLineEdit::clear_has_scriptreturnpressed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItemLineEdit::clear_scriptreturnpressed() {
  if (scriptreturnpressed_ != &::google::protobuf::internal::kEmptyString) {
    scriptreturnpressed_->clear();
  }
  clear_has_scriptreturnpressed();
}
inline const ::std::string& SchemaItemLineEdit::scriptreturnpressed() const {
  return *scriptreturnpressed_;
}
inline void SchemaItemLineEdit::set_scriptreturnpressed(const ::std::string& value) {
  set_has_scriptreturnpressed();
  if (scriptreturnpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptreturnpressed_ = new ::std::string;
  }
  scriptreturnpressed_->assign(value);
}
inline void SchemaItemLineEdit::set_scriptreturnpressed(const char* value) {
  set_has_scriptreturnpressed();
  if (scriptreturnpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptreturnpressed_ = new ::std::string;
  }
  scriptreturnpressed_->assign(value);
}
inline void SchemaItemLineEdit::set_scriptreturnpressed(const char* value, size_t size) {
  set_has_scriptreturnpressed();
  if (scriptreturnpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptreturnpressed_ = new ::std::string;
  }
  scriptreturnpressed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemLineEdit::mutable_scriptreturnpressed() {
  set_has_scriptreturnpressed();
  if (scriptreturnpressed_ == &::google::protobuf::internal::kEmptyString) {
    scriptreturnpressed_ = new ::std::string;
  }
  return scriptreturnpressed_;
}
inline ::std::string* SchemaItemLineEdit::release_scriptreturnpressed() {
  clear_has_scriptreturnpressed();
  if (scriptreturnpressed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scriptreturnpressed_;
    scriptreturnpressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemLineEdit::set_allocated_scriptreturnpressed(::std::string* scriptreturnpressed) {
  if (scriptreturnpressed_ != &::google::protobuf::internal::kEmptyString) {
    delete scriptreturnpressed_;
  }
  if (scriptreturnpressed) {
    set_has_scriptreturnpressed();
    scriptreturnpressed_ = scriptreturnpressed;
  } else {
    clear_has_scriptreturnpressed();
    scriptreturnpressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scriptTextChanged = 24;
inline bool SchemaItemLineEdit::has_scripttextchanged() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItemLineEdit::set_has_scripttextchanged() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItemLineEdit::clear_has_scripttextchanged() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItemLineEdit::clear_scripttextchanged() {
  if (scripttextchanged_ != &::google::protobuf::internal::kEmptyString) {
    scripttextchanged_->clear();
  }
  clear_has_scripttextchanged();
}
inline const ::std::string& SchemaItemLineEdit::scripttextchanged() const {
  return *scripttextchanged_;
}
inline void SchemaItemLineEdit::set_scripttextchanged(const ::std::string& value) {
  set_has_scripttextchanged();
  if (scripttextchanged_ == &::google::protobuf::internal::kEmptyString) {
    scripttextchanged_ = new ::std::string;
  }
  scripttextchanged_->assign(value);
}
inline void SchemaItemLineEdit::set_scripttextchanged(const char* value) {
  set_has_scripttextchanged();
  if (scripttextchanged_ == &::google::protobuf::internal::kEmptyString) {
    scripttextchanged_ = new ::std::string;
  }
  scripttextchanged_->assign(value);
}
inline void SchemaItemLineEdit::set_scripttextchanged(const char* value, size_t size) {
  set_has_scripttextchanged();
  if (scripttextchanged_ == &::google::protobuf::internal::kEmptyString) {
    scripttextchanged_ = new ::std::string;
  }
  scripttextchanged_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaItemLineEdit::mutable_scripttextchanged() {
  set_has_scripttextchanged();
  if (scripttextchanged_ == &::google::protobuf::internal::kEmptyString) {
    scripttextchanged_ = new ::std::string;
  }
  return scripttextchanged_;
}
inline ::std::string* SchemaItemLineEdit::release_scripttextchanged() {
  clear_has_scripttextchanged();
  if (scripttextchanged_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scripttextchanged_;
    scripttextchanged_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaItemLineEdit::set_allocated_scripttextchanged(::std::string* scripttextchanged) {
  if (scripttextchanged_ != &::google::protobuf::internal::kEmptyString) {
    delete scripttextchanged_;
  }
  if (scripttextchanged) {
    set_has_scripttextchanged();
    scripttextchanged_ = scripttextchanged;
  } else {
    clear_has_scripttextchanged();
    scripttextchanged_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeviceObject

// required .Proto.Uuid uuid = 1;
inline bool DeviceObject::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceObject::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceObject::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceObject::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& DeviceObject::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* DeviceObject::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* DeviceObject::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring equipmentId = 2;
inline bool DeviceObject::has_equipmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceObject::set_has_equipmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceObject::clear_has_equipmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceObject::clear_equipmentid() {
  if (equipmentid_ != NULL) equipmentid_->::Proto::wstring::Clear();
  clear_has_equipmentid();
}
inline const ::Proto::wstring& DeviceObject::equipmentid() const {
  return equipmentid_ != NULL ? *equipmentid_ : *default_instance_->equipmentid_;
}
inline ::Proto::wstring* DeviceObject::mutable_equipmentid() {
  set_has_equipmentid();
  if (equipmentid_ == NULL) equipmentid_ = new ::Proto::wstring;
  return equipmentid_;
}
inline ::Proto::wstring* DeviceObject::release_equipmentid() {
  clear_has_equipmentid();
  ::Proto::wstring* temp = equipmentid_;
  equipmentid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_equipmentid(::Proto::wstring* equipmentid) {
  delete equipmentid_;
  equipmentid_ = equipmentid;
  if (equipmentid) {
    set_has_equipmentid();
  } else {
    clear_has_equipmentid();
  }
}

// required .Proto.wstring caption = 3;
inline bool DeviceObject::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceObject::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceObject::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceObject::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& DeviceObject::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* DeviceObject::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* DeviceObject::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// optional .Proto.wstring childRestriction = 4;
inline bool DeviceObject::has_childrestriction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceObject::set_has_childrestriction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceObject::clear_has_childrestriction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceObject::clear_childrestriction() {
  if (childrestriction_ != NULL) childrestriction_->::Proto::wstring::Clear();
  clear_has_childrestriction();
}
inline const ::Proto::wstring& DeviceObject::childrestriction() const {
  return childrestriction_ != NULL ? *childrestriction_ : *default_instance_->childrestriction_;
}
inline ::Proto::wstring* DeviceObject::mutable_childrestriction() {
  set_has_childrestriction();
  if (childrestriction_ == NULL) childrestriction_ = new ::Proto::wstring;
  return childrestriction_;
}
inline ::Proto::wstring* DeviceObject::release_childrestriction() {
  clear_has_childrestriction();
  ::Proto::wstring* temp = childrestriction_;
  childrestriction_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_childrestriction(::Proto::wstring* childrestriction) {
  delete childrestriction_;
  childrestriction_ = childrestriction;
  if (childrestriction) {
    set_has_childrestriction();
  } else {
    clear_has_childrestriction();
  }
}

// optional int32 place = 5 [default = 0];
inline bool DeviceObject::has_place() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceObject::set_has_place() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceObject::clear_has_place() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceObject::clear_place() {
  place_ = 0;
  clear_has_place();
}
inline ::google::protobuf::int32 DeviceObject::place() const {
  return place_;
}
inline void DeviceObject::set_place(::google::protobuf::int32 value) {
  set_has_place();
  place_ = value;
}

// optional string specific_properties_struct = 6;
inline bool DeviceObject::has_specific_properties_struct() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceObject::set_has_specific_properties_struct() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceObject::clear_has_specific_properties_struct() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceObject::clear_specific_properties_struct() {
  if (specific_properties_struct_ != &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_->clear();
  }
  clear_has_specific_properties_struct();
}
inline const ::std::string& DeviceObject::specific_properties_struct() const {
  return *specific_properties_struct_;
}
inline void DeviceObject::set_specific_properties_struct(const ::std::string& value) {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  specific_properties_struct_->assign(value);
}
inline void DeviceObject::set_specific_properties_struct(const char* value) {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  specific_properties_struct_->assign(value);
}
inline void DeviceObject::set_specific_properties_struct(const char* value, size_t size) {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  specific_properties_struct_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceObject::mutable_specific_properties_struct() {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  return specific_properties_struct_;
}
inline ::std::string* DeviceObject::release_specific_properties_struct() {
  clear_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = specific_properties_struct_;
    specific_properties_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceObject::set_allocated_specific_properties_struct(::std::string* specific_properties_struct) {
  if (specific_properties_struct_ != &::google::protobuf::internal::kEmptyString) {
    delete specific_properties_struct_;
  }
  if (specific_properties_struct) {
    set_has_specific_properties_struct();
    specific_properties_struct_ = specific_properties_struct;
  } else {
    clear_has_specific_properties_struct();
    specific_properties_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.Property properties = 7;
inline int DeviceObject::properties_size() const {
  return properties_.size();
}
inline void DeviceObject::clear_properties() {
  properties_.Clear();
}
inline const ::Proto::Property& DeviceObject::properties(int index) const {
  return properties_.Get(index);
}
inline ::Proto::Property* DeviceObject::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Proto::Property* DeviceObject::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Property >&
DeviceObject::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Property >*
DeviceObject::mutable_properties() {
  return &properties_;
}

// optional bool preset = 32 [default = false];
inline bool DeviceObject::has_preset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceObject::set_has_preset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceObject::clear_has_preset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceObject::clear_preset() {
  preset_ = false;
  clear_has_preset();
}
inline bool DeviceObject::preset() const {
  return preset_;
}
inline void DeviceObject::set_preset(bool value) {
  set_has_preset();
  preset_ = value;
}

// optional bool presetRoot = 33 [default = false];
inline bool DeviceObject::has_presetroot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceObject::set_has_presetroot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceObject::clear_has_presetroot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceObject::clear_presetroot() {
  presetroot_ = false;
  clear_has_presetroot();
}
inline bool DeviceObject::presetroot() const {
  return presetroot_;
}
inline void DeviceObject::set_presetroot(bool value) {
  set_has_presetroot();
  presetroot_ = value;
}

// optional .Proto.wstring presetName = 34;
inline bool DeviceObject::has_presetname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceObject::set_has_presetname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceObject::clear_has_presetname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceObject::clear_presetname() {
  if (presetname_ != NULL) presetname_->::Proto::wstring::Clear();
  clear_has_presetname();
}
inline const ::Proto::wstring& DeviceObject::presetname() const {
  return presetname_ != NULL ? *presetname_ : *default_instance_->presetname_;
}
inline ::Proto::wstring* DeviceObject::mutable_presetname() {
  set_has_presetname();
  if (presetname_ == NULL) presetname_ = new ::Proto::wstring;
  return presetname_;
}
inline ::Proto::wstring* DeviceObject::release_presetname() {
  clear_has_presetname();
  ::Proto::wstring* temp = presetname_;
  presetname_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_presetname(::Proto::wstring* presetname) {
  delete presetname_;
  presetname_ = presetname;
  if (presetname) {
    set_has_presetname();
  } else {
    clear_has_presetname();
  }
}

// optional .Proto.Uuid presetObjectUuid = 35;
inline bool DeviceObject::has_presetobjectuuid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceObject::set_has_presetobjectuuid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeviceObject::clear_has_presetobjectuuid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceObject::clear_presetobjectuuid() {
  if (presetobjectuuid_ != NULL) presetobjectuuid_->::Proto::Uuid::Clear();
  clear_has_presetobjectuuid();
}
inline const ::Proto::Uuid& DeviceObject::presetobjectuuid() const {
  return presetobjectuuid_ != NULL ? *presetobjectuuid_ : *default_instance_->presetobjectuuid_;
}
inline ::Proto::Uuid* DeviceObject::mutable_presetobjectuuid() {
  set_has_presetobjectuuid();
  if (presetobjectuuid_ == NULL) presetobjectuuid_ = new ::Proto::Uuid;
  return presetobjectuuid_;
}
inline ::Proto::Uuid* DeviceObject::release_presetobjectuuid() {
  clear_has_presetobjectuuid();
  ::Proto::Uuid* temp = presetobjectuuid_;
  presetobjectuuid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_presetobjectuuid(::Proto::Uuid* presetobjectuuid) {
  delete presetobjectuuid_;
  presetobjectuuid_ = presetobjectuuid;
  if (presetobjectuuid) {
    set_has_presetobjectuuid();
  } else {
    clear_has_presetobjectuuid();
  }
}

// optional int32 childCountHint = 36 [default = 0];
inline bool DeviceObject::has_childcounthint() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceObject::set_has_childcounthint() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeviceObject::clear_has_childcounthint() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceObject::clear_childcounthint() {
  childcounthint_ = 0;
  clear_has_childcounthint();
}
inline ::google::protobuf::int32 DeviceObject::childcounthint() const {
  return childcounthint_;
}
inline void DeviceObject::set_childcounthint(::google::protobuf::int32 value) {
  set_has_childcounthint();
  childcounthint_ = value;
}

// optional .Proto.DeviceRoot Root = 100;
inline bool DeviceObject::has_root() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceObject::set_has_root() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DeviceObject::clear_has_root() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceObject::clear_root() {
  if (root_ != NULL) root_->::Proto::DeviceRoot::Clear();
  clear_has_root();
}
inline const ::Proto::DeviceRoot& DeviceObject::root() const {
  return root_ != NULL ? *root_ : *default_instance_->root_;
}
inline ::Proto::DeviceRoot* DeviceObject::mutable_root() {
  set_has_root();
  if (root_ == NULL) root_ = new ::Proto::DeviceRoot;
  return root_;
}
inline ::Proto::DeviceRoot* DeviceObject::release_root() {
  clear_has_root();
  ::Proto::DeviceRoot* temp = root_;
  root_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_root(::Proto::DeviceRoot* root) {
  delete root_;
  root_ = root;
  if (root) {
    set_has_root();
  } else {
    clear_has_root();
  }
}

// optional .Proto.DeviceSystem System = 101;
inline bool DeviceObject::has_system() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceObject::set_has_system() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DeviceObject::clear_has_system() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceObject::clear_system() {
  if (system_ != NULL) system_->::Proto::DeviceSystem::Clear();
  clear_has_system();
}
inline const ::Proto::DeviceSystem& DeviceObject::system() const {
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::Proto::DeviceSystem* DeviceObject::mutable_system() {
  set_has_system();
  if (system_ == NULL) system_ = new ::Proto::DeviceSystem;
  return system_;
}
inline ::Proto::DeviceSystem* DeviceObject::release_system() {
  clear_has_system();
  ::Proto::DeviceSystem* temp = system_;
  system_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_system(::Proto::DeviceSystem* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
}

// optional .Proto.DeviceRack Rack = 102;
inline bool DeviceObject::has_rack() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceObject::set_has_rack() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DeviceObject::clear_has_rack() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceObject::clear_rack() {
  if (rack_ != NULL) rack_->::Proto::DeviceRack::Clear();
  clear_has_rack();
}
inline const ::Proto::DeviceRack& DeviceObject::rack() const {
  return rack_ != NULL ? *rack_ : *default_instance_->rack_;
}
inline ::Proto::DeviceRack* DeviceObject::mutable_rack() {
  set_has_rack();
  if (rack_ == NULL) rack_ = new ::Proto::DeviceRack;
  return rack_;
}
inline ::Proto::DeviceRack* DeviceObject::release_rack() {
  clear_has_rack();
  ::Proto::DeviceRack* temp = rack_;
  rack_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_rack(::Proto::DeviceRack* rack) {
  delete rack_;
  rack_ = rack;
  if (rack) {
    set_has_rack();
  } else {
    clear_has_rack();
  }
}

// optional .Proto.DeviceChassis Chassis = 103;
inline bool DeviceObject::has_chassis() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceObject::set_has_chassis() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DeviceObject::clear_has_chassis() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceObject::clear_chassis() {
  if (chassis_ != NULL) chassis_->::Proto::DeviceChassis::Clear();
  clear_has_chassis();
}
inline const ::Proto::DeviceChassis& DeviceObject::chassis() const {
  return chassis_ != NULL ? *chassis_ : *default_instance_->chassis_;
}
inline ::Proto::DeviceChassis* DeviceObject::mutable_chassis() {
  set_has_chassis();
  if (chassis_ == NULL) chassis_ = new ::Proto::DeviceChassis;
  return chassis_;
}
inline ::Proto::DeviceChassis* DeviceObject::release_chassis() {
  clear_has_chassis();
  ::Proto::DeviceChassis* temp = chassis_;
  chassis_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_chassis(::Proto::DeviceChassis* chassis) {
  delete chassis_;
  chassis_ = chassis;
  if (chassis) {
    set_has_chassis();
  } else {
    clear_has_chassis();
  }
}

// optional .Proto.DeviceModule Module = 104;
inline bool DeviceObject::has_module() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceObject::set_has_module() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DeviceObject::clear_has_module() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceObject::clear_module() {
  if (module_ != NULL) module_->::Proto::DeviceModule::Clear();
  clear_has_module();
}
inline const ::Proto::DeviceModule& DeviceObject::module() const {
  return module_ != NULL ? *module_ : *default_instance_->module_;
}
inline ::Proto::DeviceModule* DeviceObject::mutable_module() {
  set_has_module();
  if (module_ == NULL) module_ = new ::Proto::DeviceModule;
  return module_;
}
inline ::Proto::DeviceModule* DeviceObject::release_module() {
  clear_has_module();
  ::Proto::DeviceModule* temp = module_;
  module_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_module(::Proto::DeviceModule* module) {
  delete module_;
  module_ = module;
  if (module) {
    set_has_module();
  } else {
    clear_has_module();
  }
}

// optional .Proto.DeviceController Controller = 105;
inline bool DeviceObject::has_controller() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceObject::set_has_controller() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DeviceObject::clear_has_controller() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceObject::clear_controller() {
  if (controller_ != NULL) controller_->::Proto::DeviceController::Clear();
  clear_has_controller();
}
inline const ::Proto::DeviceController& DeviceObject::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::Proto::DeviceController* DeviceObject::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::Proto::DeviceController;
  return controller_;
}
inline ::Proto::DeviceController* DeviceObject::release_controller() {
  clear_has_controller();
  ::Proto::DeviceController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_controller(::Proto::DeviceController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// optional .Proto.DeviceSignal Signal = 106;
inline bool DeviceObject::has_signal() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceObject::set_has_signal() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DeviceObject::clear_has_signal() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DeviceObject::clear_signal() {
  if (signal_ != NULL) signal_->::Proto::DeviceSignal::Clear();
  clear_has_signal();
}
inline const ::Proto::DeviceSignal& DeviceObject::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Proto::DeviceSignal* DeviceObject::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Proto::DeviceSignal;
  return signal_;
}
inline ::Proto::DeviceSignal* DeviceObject::release_signal() {
  clear_has_signal();
  ::Proto::DeviceSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_signal(::Proto::DeviceSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Proto.Workstation Workstation = 107;
inline bool DeviceObject::has_workstation() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DeviceObject::set_has_workstation() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DeviceObject::clear_has_workstation() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DeviceObject::clear_workstation() {
  if (workstation_ != NULL) workstation_->::Proto::Workstation::Clear();
  clear_has_workstation();
}
inline const ::Proto::Workstation& DeviceObject::workstation() const {
  return workstation_ != NULL ? *workstation_ : *default_instance_->workstation_;
}
inline ::Proto::Workstation* DeviceObject::mutable_workstation() {
  set_has_workstation();
  if (workstation_ == NULL) workstation_ = new ::Proto::Workstation;
  return workstation_;
}
inline ::Proto::Workstation* DeviceObject::release_workstation() {
  clear_has_workstation();
  ::Proto::Workstation* temp = workstation_;
  workstation_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_workstation(::Proto::Workstation* workstation) {
  delete workstation_;
  workstation_ = workstation;
  if (workstation) {
    set_has_workstation();
  } else {
    clear_has_workstation();
  }
}

// optional .Proto.Software Software = 108;
inline bool DeviceObject::has_software() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DeviceObject::set_has_software() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DeviceObject::clear_has_software() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DeviceObject::clear_software() {
  if (software_ != NULL) software_->::Proto::Software::Clear();
  clear_has_software();
}
inline const ::Proto::Software& DeviceObject::software() const {
  return software_ != NULL ? *software_ : *default_instance_->software_;
}
inline ::Proto::Software* DeviceObject::mutable_software() {
  set_has_software();
  if (software_ == NULL) software_ = new ::Proto::Software;
  return software_;
}
inline ::Proto::Software* DeviceObject::release_software() {
  clear_has_software();
  ::Proto::Software* temp = software_;
  software_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_software(::Proto::Software* software) {
  delete software_;
  software_ = software;
  if (software) {
    set_has_software();
  } else {
    clear_has_software();
  }
}

// repeated .Proto.Envelope children = 200;
inline int DeviceObject::children_size() const {
  return children_.size();
}
inline void DeviceObject::clear_children() {
  children_.Clear();
}
inline const ::Proto::Envelope& DeviceObject::children(int index) const {
  return children_.Get(index);
}
inline ::Proto::Envelope* DeviceObject::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::Proto::Envelope* DeviceObject::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
DeviceObject::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
DeviceObject::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// DeviceRoot

// -------------------------------------------------------------------

// DeviceSystem

// -------------------------------------------------------------------

// DeviceRack

// -------------------------------------------------------------------

// DeviceChassis

// optional int32 type = 1 [default = 0];
inline bool DeviceChassis::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceChassis::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceChassis::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceChassis::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceChassis::type() const {
  return type_;
}
inline void DeviceChassis::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// DeviceModule

// optional int32 typeObsolete = 1 [default = 0];
inline bool DeviceModule::has_typeobsolete() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceModule::set_has_typeobsolete() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceModule::clear_has_typeobsolete() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceModule::clear_typeobsolete() {
  typeobsolete_ = 0;
  clear_has_typeobsolete();
}
inline ::google::protobuf::int32 DeviceModule::typeobsolete() const {
  return typeobsolete_;
}
inline void DeviceModule::set_typeobsolete(::google::protobuf::int32 value) {
  set_has_typeobsolete();
  typeobsolete_ = value;
}

// optional string configurationScript = 2;
inline bool DeviceModule::has_configurationscript() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceModule::set_has_configurationscript() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceModule::clear_has_configurationscript() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceModule::clear_configurationscript() {
  if (configurationscript_ != &::google::protobuf::internal::kEmptyString) {
    configurationscript_->clear();
  }
  clear_has_configurationscript();
}
inline const ::std::string& DeviceModule::configurationscript() const {
  return *configurationscript_;
}
inline void DeviceModule::set_configurationscript(const ::std::string& value) {
  set_has_configurationscript();
  if (configurationscript_ == &::google::protobuf::internal::kEmptyString) {
    configurationscript_ = new ::std::string;
  }
  configurationscript_->assign(value);
}
inline void DeviceModule::set_configurationscript(const char* value) {
  set_has_configurationscript();
  if (configurationscript_ == &::google::protobuf::internal::kEmptyString) {
    configurationscript_ = new ::std::string;
  }
  configurationscript_->assign(value);
}
inline void DeviceModule::set_configurationscript(const char* value, size_t size) {
  set_has_configurationscript();
  if (configurationscript_ == &::google::protobuf::internal::kEmptyString) {
    configurationscript_ = new ::std::string;
  }
  configurationscript_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceModule::mutable_configurationscript() {
  set_has_configurationscript();
  if (configurationscript_ == &::google::protobuf::internal::kEmptyString) {
    configurationscript_ = new ::std::string;
  }
  return configurationscript_;
}
inline ::std::string* DeviceModule::release_configurationscript() {
  clear_has_configurationscript();
  if (configurationscript_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configurationscript_;
    configurationscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceModule::set_allocated_configurationscript(::std::string* configurationscript) {
  if (configurationscript_ != &::google::protobuf::internal::kEmptyString) {
    delete configurationscript_;
  }
  if (configurationscript) {
    set_has_configurationscript();
    configurationscript_ = configurationscript;
  } else {
    clear_has_configurationscript();
    configurationscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 moduleType = 3;
inline bool DeviceModule::has_moduletype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceModule::set_has_moduletype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceModule::clear_has_moduletype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceModule::clear_moduletype() {
  moduletype_ = 0;
  clear_has_moduletype();
}
inline ::google::protobuf::int32 DeviceModule::moduletype() const {
  return moduletype_;
}
inline void DeviceModule::set_moduletype(::google::protobuf::int32 value) {
  set_has_moduletype();
  moduletype_ = value;
}

// optional string rawDataDescription = 4;
inline bool DeviceModule::has_rawdatadescription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceModule::set_has_rawdatadescription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceModule::clear_has_rawdatadescription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceModule::clear_rawdatadescription() {
  if (rawdatadescription_ != &::google::protobuf::internal::kEmptyString) {
    rawdatadescription_->clear();
  }
  clear_has_rawdatadescription();
}
inline const ::std::string& DeviceModule::rawdatadescription() const {
  return *rawdatadescription_;
}
inline void DeviceModule::set_rawdatadescription(const ::std::string& value) {
  set_has_rawdatadescription();
  if (rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    rawdatadescription_ = new ::std::string;
  }
  rawdatadescription_->assign(value);
}
inline void DeviceModule::set_rawdatadescription(const char* value) {
  set_has_rawdatadescription();
  if (rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    rawdatadescription_ = new ::std::string;
  }
  rawdatadescription_->assign(value);
}
inline void DeviceModule::set_rawdatadescription(const char* value, size_t size) {
  set_has_rawdatadescription();
  if (rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    rawdatadescription_ = new ::std::string;
  }
  rawdatadescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceModule::mutable_rawdatadescription() {
  set_has_rawdatadescription();
  if (rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    rawdatadescription_ = new ::std::string;
  }
  return rawdatadescription_;
}
inline ::std::string* DeviceModule::release_rawdatadescription() {
  clear_has_rawdatadescription();
  if (rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rawdatadescription_;
    rawdatadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceModule::set_allocated_rawdatadescription(::std::string* rawdatadescription) {
  if (rawdatadescription_ != &::google::protobuf::internal::kEmptyString) {
    delete rawdatadescription_;
  }
  if (rawdatadescription) {
    set_has_rawdatadescription();
    rawdatadescription_ = rawdatadescription;
  } else {
    clear_has_rawdatadescription();
    rawdatadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeviceController

// -------------------------------------------------------------------

// DeviceSignal

// optional int32 obsoletetype = 1 [default = 0];
inline bool DeviceSignal::has_obsoletetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceSignal::set_has_obsoletetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceSignal::clear_has_obsoletetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceSignal::clear_obsoletetype() {
  obsoletetype_ = 0;
  clear_has_obsoletetype();
}
inline ::google::protobuf::int32 DeviceSignal::obsoletetype() const {
  return obsoletetype_;
}
inline void DeviceSignal::set_obsoletetype(::google::protobuf::int32 value) {
  set_has_obsoletetype();
  obsoletetype_ = value;
}

// optional int32 byteOrder = 2 [default = 0];
inline bool DeviceSignal::has_byteorder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceSignal::set_has_byteorder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceSignal::clear_has_byteorder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceSignal::clear_byteorder() {
  byteorder_ = 0;
  clear_has_byteorder();
}
inline ::google::protobuf::int32 DeviceSignal::byteorder() const {
  return byteorder_;
}
inline void DeviceSignal::set_byteorder(::google::protobuf::int32 value) {
  set_has_byteorder();
  byteorder_ = value;
}

// optional int32 format = 3 [default = 0];
inline bool DeviceSignal::has_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceSignal::set_has_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceSignal::clear_has_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceSignal::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 DeviceSignal::format() const {
  return format_;
}
inline void DeviceSignal::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
}

// optional int32 size = 4 [default = 0];
inline bool DeviceSignal::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceSignal::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceSignal::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceSignal::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 DeviceSignal::size() const {
  return size_;
}
inline void DeviceSignal::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int32 valueOffset = 7 [default = 0];
inline bool DeviceSignal::has_valueoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceSignal::set_has_valueoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceSignal::clear_has_valueoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceSignal::clear_valueoffset() {
  valueoffset_ = 0;
  clear_has_valueoffset();
}
inline ::google::protobuf::int32 DeviceSignal::valueoffset() const {
  return valueoffset_;
}
inline void DeviceSignal::set_valueoffset(::google::protobuf::int32 value) {
  set_has_valueoffset();
  valueoffset_ = value;
}

// optional int32 valueBit = 8 [default = 0];
inline bool DeviceSignal::has_valuebit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceSignal::set_has_valuebit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceSignal::clear_has_valuebit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceSignal::clear_valuebit() {
  valuebit_ = 0;
  clear_has_valuebit();
}
inline ::google::protobuf::int32 DeviceSignal::valuebit() const {
  return valuebit_;
}
inline void DeviceSignal::set_valuebit(::google::protobuf::int32 value) {
  set_has_valuebit();
  valuebit_ = value;
}

// optional int32 type = 9 [default = 0];
inline bool DeviceSignal::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceSignal::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceSignal::type() const {
  return type_;
}
inline void DeviceSignal::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 function = 10 [default = 0];
inline bool DeviceSignal::has_function() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceSignal::set_has_function() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceSignal::clear_has_function() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceSignal::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::google::protobuf::int32 DeviceSignal::function() const {
  return function_;
}
inline void DeviceSignal::set_function(::google::protobuf::int32 value) {
  set_has_function();
  function_ = value;
}

// optional int32 memoryArea = 11 [default = 0];
inline bool DeviceSignal::has_memoryarea() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceSignal::set_has_memoryarea() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceSignal::clear_has_memoryarea() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceSignal::clear_memoryarea() {
  memoryarea_ = 0;
  clear_has_memoryarea();
}
inline ::google::protobuf::int32 DeviceSignal::memoryarea() const {
  return memoryarea_;
}
inline void DeviceSignal::set_memoryarea(::google::protobuf::int32 value) {
  set_has_memoryarea();
  memoryarea_ = value;
}

// optional int32 appSignalLowAdc = 12 [default = 0];
inline bool DeviceSignal::has_appsignallowadc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceSignal::set_has_appsignallowadc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceSignal::clear_has_appsignallowadc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceSignal::clear_appsignallowadc() {
  appsignallowadc_ = 0;
  clear_has_appsignallowadc();
}
inline ::google::protobuf::int32 DeviceSignal::appsignallowadc() const {
  return appsignallowadc_;
}
inline void DeviceSignal::set_appsignallowadc(::google::protobuf::int32 value) {
  set_has_appsignallowadc();
  appsignallowadc_ = value;
}

// optional int32 appSignalHighAdc = 13 [default = 65535];
inline bool DeviceSignal::has_appsignalhighadc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceSignal::set_has_appsignalhighadc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeviceSignal::clear_has_appsignalhighadc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceSignal::clear_appsignalhighadc() {
  appsignalhighadc_ = 65535;
  clear_has_appsignalhighadc();
}
inline ::google::protobuf::int32 DeviceSignal::appsignalhighadc() const {
  return appsignalhighadc_;
}
inline void DeviceSignal::set_appsignalhighadc(::google::protobuf::int32 value) {
  set_has_appsignalhighadc();
  appsignalhighadc_ = value;
}

// optional double appSignalLowEngUnits = 14 [default = 0];
inline bool DeviceSignal::has_appsignallowengunits() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceSignal::set_has_appsignallowengunits() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeviceSignal::clear_has_appsignallowengunits() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceSignal::clear_appsignallowengunits() {
  appsignallowengunits_ = 0;
  clear_has_appsignallowengunits();
}
inline double DeviceSignal::appsignallowengunits() const {
  return appsignallowengunits_;
}
inline void DeviceSignal::set_appsignallowengunits(double value) {
  set_has_appsignallowengunits();
  appsignallowengunits_ = value;
}

// optional double appSignalHighEngUnits = 15 [default = 100];
inline bool DeviceSignal::has_appsignalhighengunits() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceSignal::set_has_appsignalhighengunits() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DeviceSignal::clear_has_appsignalhighengunits() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceSignal::clear_appsignalhighengunits() {
  appsignalhighengunits_ = 100;
  clear_has_appsignalhighengunits();
}
inline double DeviceSignal::appsignalhighengunits() const {
  return appsignalhighengunits_;
}
inline void DeviceSignal::set_appsignalhighengunits(double value) {
  set_has_appsignalhighengunits();
  appsignalhighengunits_ = value;
}

// optional int32 appSignalDataFormat = 16 [default = 2];
inline bool DeviceSignal::has_appsignaldataformat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceSignal::set_has_appsignaldataformat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DeviceSignal::clear_has_appsignaldataformat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceSignal::clear_appsignaldataformat() {
  appsignaldataformat_ = 2;
  clear_has_appsignaldataformat();
}
inline ::google::protobuf::int32 DeviceSignal::appsignaldataformat() const {
  return appsignaldataformat_;
}
inline void DeviceSignal::set_appsignaldataformat(::google::protobuf::int32 value) {
  set_has_appsignaldataformat();
  appsignaldataformat_ = value;
}

// optional string validitySignalId = 20;
inline bool DeviceSignal::has_validitysignalid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceSignal::set_has_validitysignalid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DeviceSignal::clear_has_validitysignalid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceSignal::clear_validitysignalid() {
  if (validitysignalid_ != &::google::protobuf::internal::kEmptyString) {
    validitysignalid_->clear();
  }
  clear_has_validitysignalid();
}
inline const ::std::string& DeviceSignal::validitysignalid() const {
  return *validitysignalid_;
}
inline void DeviceSignal::set_validitysignalid(const ::std::string& value) {
  set_has_validitysignalid();
  if (validitysignalid_ == &::google::protobuf::internal::kEmptyString) {
    validitysignalid_ = new ::std::string;
  }
  validitysignalid_->assign(value);
}
inline void DeviceSignal::set_validitysignalid(const char* value) {
  set_has_validitysignalid();
  if (validitysignalid_ == &::google::protobuf::internal::kEmptyString) {
    validitysignalid_ = new ::std::string;
  }
  validitysignalid_->assign(value);
}
inline void DeviceSignal::set_validitysignalid(const char* value, size_t size) {
  set_has_validitysignalid();
  if (validitysignalid_ == &::google::protobuf::internal::kEmptyString) {
    validitysignalid_ = new ::std::string;
  }
  validitysignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceSignal::mutable_validitysignalid() {
  set_has_validitysignalid();
  if (validitysignalid_ == &::google::protobuf::internal::kEmptyString) {
    validitysignalid_ = new ::std::string;
  }
  return validitysignalid_;
}
inline ::std::string* DeviceSignal::release_validitysignalid() {
  clear_has_validitysignalid();
  if (validitysignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validitysignalid_;
    validitysignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceSignal::set_allocated_validitysignalid(::std::string* validitysignalid) {
  if (validitysignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete validitysignalid_;
  }
  if (validitysignalid) {
    set_has_validitysignalid();
    validitysignalid_ = validitysignalid;
  } else {
    clear_has_validitysignalid();
    validitysignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Workstation

// optional int32 type = 1 [default = 0];
inline bool Workstation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Workstation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Workstation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Workstation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Workstation::type() const {
  return type_;
}
inline void Workstation::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// Software

// optional int32 type = 1 [default = 0];
inline bool Software::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Software::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Software::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Software::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Software::type() const {
  return type_;
}
inline void Software::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ModuleConfiguration

// optional string struct_description = 1;
inline bool ModuleConfiguration::has_struct_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleConfiguration::set_has_struct_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleConfiguration::clear_has_struct_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleConfiguration::clear_struct_description() {
  if (struct_description_ != &::google::protobuf::internal::kEmptyString) {
    struct_description_->clear();
  }
  clear_has_struct_description();
}
inline const ::std::string& ModuleConfiguration::struct_description() const {
  return *struct_description_;
}
inline void ModuleConfiguration::set_struct_description(const ::std::string& value) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(value);
}
inline void ModuleConfiguration::set_struct_description(const char* value) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(value);
}
inline void ModuleConfiguration::set_struct_description(const char* value, size_t size) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfiguration::mutable_struct_description() {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  return struct_description_;
}
inline ::std::string* ModuleConfiguration::release_struct_description() {
  clear_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = struct_description_;
    struct_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfiguration::set_allocated_struct_description(::std::string* struct_description) {
  if (struct_description_ != &::google::protobuf::internal::kEmptyString) {
    delete struct_description_;
  }
  if (struct_description) {
    set_has_struct_description();
    struct_description_ = struct_description;
  } else {
    clear_has_struct_description();
    struct_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.ModuleConfigurationValue values = 2;
inline int ModuleConfiguration::values_size() const {
  return values_.size();
}
inline void ModuleConfiguration::clear_values() {
  values_.Clear();
}
inline const ::Proto::ModuleConfigurationValue& ModuleConfiguration::values(int index) const {
  return values_.Get(index);
}
inline ::Proto::ModuleConfigurationValue* ModuleConfiguration::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::Proto::ModuleConfigurationValue* ModuleConfiguration::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >&
ModuleConfiguration::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >*
ModuleConfiguration::mutable_values() {
  return &values_;
}

// optional string name = 3 [default = ""];
inline bool ModuleConfiguration::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModuleConfiguration::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModuleConfiguration::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModuleConfiguration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleConfiguration::name() const {
  return *name_;
}
inline void ModuleConfiguration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfiguration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfiguration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfiguration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleConfiguration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfiguration::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModuleConfigurationValue

// required string name = 1;
inline bool ModuleConfigurationValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleConfigurationValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleConfigurationValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleConfigurationValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleConfigurationValue::name() const {
  return *name_;
}
inline void ModuleConfigurationValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfigurationValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfigurationValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfigurationValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleConfigurationValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfigurationValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool ModuleConfigurationValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleConfigurationValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleConfigurationValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleConfigurationValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ModuleConfigurationValue::value() const {
  return *value_;
}
inline void ModuleConfigurationValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ModuleConfigurationValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ModuleConfigurationValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfigurationValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ModuleConfigurationValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfigurationValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Property

// required string name = 1;
inline bool Property::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Property::name() const {
  return *name_;
}
inline void Property::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Property::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Property::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Property::value() const {
  return *value_;
}
inline void Property::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Property::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Address16

// required int32 offset = 1 [default = -1];
inline bool Address16::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address16::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address16::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address16::clear_offset() {
  offset_ = -1;
  clear_has_offset();
}
inline ::google::protobuf::int32 Address16::offset() const {
  return offset_;
}
inline void Address16::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 bit = 2 [default = -1];
inline bool Address16::has_bit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address16::set_has_bit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address16::clear_has_bit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address16::clear_bit() {
  bit_ = -1;
  clear_has_bit();
}
inline ::google::protobuf::int32 Address16::bit() const {
  return bit_;
}
inline void Address16::set_bit(::google::protobuf::int32 value) {
  set_has_bit();
  bit_ = value;
}

// -------------------------------------------------------------------

// AppSignal

// optional int32 ID = 1;
inline bool AppSignal::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppSignal::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppSignal::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppSignal::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AppSignal::id() const {
  return id_;
}
inline void AppSignal::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 signalGroupID = 2;
inline bool AppSignal::has_signalgroupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppSignal::set_has_signalgroupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppSignal::clear_has_signalgroupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppSignal::clear_signalgroupid() {
  signalgroupid_ = 0;
  clear_has_signalgroupid();
}
inline ::google::protobuf::int32 AppSignal::signalgroupid() const {
  return signalgroupid_;
}
inline void AppSignal::set_signalgroupid(::google::protobuf::int32 value) {
  set_has_signalgroupid();
  signalgroupid_ = value;
}

// optional int32 signalInstanceID = 3;
inline bool AppSignal::has_signalinstanceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppSignal::set_has_signalinstanceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppSignal::clear_has_signalinstanceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppSignal::clear_signalinstanceid() {
  signalinstanceid_ = 0;
  clear_has_signalinstanceid();
}
inline ::google::protobuf::int32 AppSignal::signalinstanceid() const {
  return signalinstanceid_;
}
inline void AppSignal::set_signalinstanceid(::google::protobuf::int32 value) {
  set_has_signalinstanceid();
  signalinstanceid_ = value;
}

// optional int32 changesetID = 4;
inline bool AppSignal::has_changesetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppSignal::set_has_changesetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppSignal::clear_has_changesetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppSignal::clear_changesetid() {
  changesetid_ = 0;
  clear_has_changesetid();
}
inline ::google::protobuf::int32 AppSignal::changesetid() const {
  return changesetid_;
}
inline void AppSignal::set_changesetid(::google::protobuf::int32 value) {
  set_has_changesetid();
  changesetid_ = value;
}

// optional bool checkedOut = 5;
inline bool AppSignal::has_checkedout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppSignal::set_has_checkedout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppSignal::clear_has_checkedout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppSignal::clear_checkedout() {
  checkedout_ = false;
  clear_has_checkedout();
}
inline bool AppSignal::checkedout() const {
  return checkedout_;
}
inline void AppSignal::set_checkedout(bool value) {
  set_has_checkedout();
  checkedout_ = value;
}

// optional int32 userID = 6;
inline bool AppSignal::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppSignal::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppSignal::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppSignal::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 AppSignal::userid() const {
  return userid_;
}
inline void AppSignal::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 subsystemChannel = 7;
inline bool AppSignal::has_subsystemchannel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppSignal::set_has_subsystemchannel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AppSignal::clear_has_subsystemchannel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AppSignal::clear_subsystemchannel() {
  subsystemchannel_ = 0;
  clear_has_subsystemchannel();
}
inline ::google::protobuf::int32 AppSignal::subsystemchannel() const {
  return subsystemchannel_;
}
inline void AppSignal::set_subsystemchannel(::google::protobuf::int32 value) {
  set_has_subsystemchannel();
  subsystemchannel_ = value;
}

// optional int32 type = 8;
inline bool AppSignal::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppSignal::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AppSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AppSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AppSignal::type() const {
  return type_;
}
inline void AppSignal::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int64 created = 9;
inline bool AppSignal::has_created() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppSignal::set_has_created() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AppSignal::clear_has_created() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AppSignal::clear_created() {
  created_ = GOOGLE_LONGLONG(0);
  clear_has_created();
}
inline ::google::protobuf::int64 AppSignal::created() const {
  return created_;
}
inline void AppSignal::set_created(::google::protobuf::int64 value) {
  set_has_created();
  created_ = value;
}

// optional bool deleted = 10;
inline bool AppSignal::has_deleted() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AppSignal::set_has_deleted() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AppSignal::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AppSignal::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool AppSignal::deleted() const {
  return deleted_;
}
inline void AppSignal::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
}

// optional int64 instanceCreated = 11;
inline bool AppSignal::has_instancecreated() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AppSignal::set_has_instancecreated() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AppSignal::clear_has_instancecreated() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AppSignal::clear_instancecreated() {
  instancecreated_ = GOOGLE_LONGLONG(0);
  clear_has_instancecreated();
}
inline ::google::protobuf::int64 AppSignal::instancecreated() const {
  return instancecreated_;
}
inline void AppSignal::set_instancecreated(::google::protobuf::int64 value) {
  set_has_instancecreated();
  instancecreated_ = value;
}

// optional int32 instanceAction = 12;
inline bool AppSignal::has_instanceaction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AppSignal::set_has_instanceaction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AppSignal::clear_has_instanceaction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AppSignal::clear_instanceaction() {
  instanceaction_ = 0;
  clear_has_instanceaction();
}
inline ::google::protobuf::int32 AppSignal::instanceaction() const {
  return instanceaction_;
}
inline void AppSignal::set_instanceaction(::google::protobuf::int32 value) {
  set_has_instanceaction();
  instanceaction_ = value;
}

// optional string appSignalID = 13;
inline bool AppSignal::has_appsignalid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AppSignal::set_has_appsignalid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AppSignal::clear_has_appsignalid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AppSignal::clear_appsignalid() {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    appsignalid_->clear();
  }
  clear_has_appsignalid();
}
inline const ::std::string& AppSignal::appsignalid() const {
  return *appsignalid_;
}
inline void AppSignal::set_appsignalid(const ::std::string& value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void AppSignal::set_appsignalid(const char* value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void AppSignal::set_appsignalid(const char* value, size_t size) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_appsignalid() {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  return appsignalid_;
}
inline ::std::string* AppSignal::release_appsignalid() {
  clear_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appsignalid_;
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_appsignalid(::std::string* appsignalid) {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete appsignalid_;
  }
  if (appsignalid) {
    set_has_appsignalid();
    appsignalid_ = appsignalid;
  } else {
    clear_has_appsignalid();
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customAppSignalID = 14;
inline bool AppSignal::has_customappsignalid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AppSignal::set_has_customappsignalid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AppSignal::clear_has_customappsignalid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AppSignal::clear_customappsignalid() {
  if (customappsignalid_ != &::google::protobuf::internal::kEmptyString) {
    customappsignalid_->clear();
  }
  clear_has_customappsignalid();
}
inline const ::std::string& AppSignal::customappsignalid() const {
  return *customappsignalid_;
}
inline void AppSignal::set_customappsignalid(const ::std::string& value) {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  customappsignalid_->assign(value);
}
inline void AppSignal::set_customappsignalid(const char* value) {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  customappsignalid_->assign(value);
}
inline void AppSignal::set_customappsignalid(const char* value, size_t size) {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  customappsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_customappsignalid() {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  return customappsignalid_;
}
inline ::std::string* AppSignal::release_customappsignalid() {
  clear_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customappsignalid_;
    customappsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_customappsignalid(::std::string* customappsignalid) {
  if (customappsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete customappsignalid_;
  }
  if (customappsignalid) {
    set_has_customappsignalid();
    customappsignalid_ = customappsignalid;
  } else {
    clear_has_customappsignalid();
    customappsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string caption = 15;
inline bool AppSignal::has_caption() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AppSignal::set_has_caption() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AppSignal::clear_has_caption() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AppSignal::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& AppSignal::caption() const {
  return *caption_;
}
inline void AppSignal::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void AppSignal::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void AppSignal::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* AppSignal::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dataFormat = 16;
inline bool AppSignal::has_dataformat() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AppSignal::set_has_dataformat() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AppSignal::clear_has_dataformat() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AppSignal::clear_dataformat() {
  dataformat_ = 0;
  clear_has_dataformat();
}
inline ::google::protobuf::int32 AppSignal::dataformat() const {
  return dataformat_;
}
inline void AppSignal::set_dataformat(::google::protobuf::int32 value) {
  set_has_dataformat();
  dataformat_ = value;
}

// optional int32 dataSize = 17;
inline bool AppSignal::has_datasize() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AppSignal::set_has_datasize() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AppSignal::clear_has_datasize() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AppSignal::clear_datasize() {
  datasize_ = 0;
  clear_has_datasize();
}
inline ::google::protobuf::int32 AppSignal::datasize() const {
  return datasize_;
}
inline void AppSignal::set_datasize(::google::protobuf::int32 value) {
  set_has_datasize();
  datasize_ = value;
}

// optional int32 lowADC = 18;
inline bool AppSignal::has_lowadc() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AppSignal::set_has_lowadc() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AppSignal::clear_has_lowadc() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AppSignal::clear_lowadc() {
  lowadc_ = 0;
  clear_has_lowadc();
}
inline ::google::protobuf::int32 AppSignal::lowadc() const {
  return lowadc_;
}
inline void AppSignal::set_lowadc(::google::protobuf::int32 value) {
  set_has_lowadc();
  lowadc_ = value;
}

// optional int32 highADC = 19;
inline bool AppSignal::has_highadc() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AppSignal::set_has_highadc() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AppSignal::clear_has_highadc() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AppSignal::clear_highadc() {
  highadc_ = 0;
  clear_has_highadc();
}
inline ::google::protobuf::int32 AppSignal::highadc() const {
  return highadc_;
}
inline void AppSignal::set_highadc(::google::protobuf::int32 value) {
  set_has_highadc();
  highadc_ = value;
}

// optional double lowEngeneeringUnits = 20;
inline bool AppSignal::has_lowengeneeringunits() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AppSignal::set_has_lowengeneeringunits() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AppSignal::clear_has_lowengeneeringunits() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AppSignal::clear_lowengeneeringunits() {
  lowengeneeringunits_ = 0;
  clear_has_lowengeneeringunits();
}
inline double AppSignal::lowengeneeringunits() const {
  return lowengeneeringunits_;
}
inline void AppSignal::set_lowengeneeringunits(double value) {
  set_has_lowengeneeringunits();
  lowengeneeringunits_ = value;
}

// optional double highEngeneeringUnits = 21;
inline bool AppSignal::has_highengeneeringunits() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AppSignal::set_has_highengeneeringunits() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AppSignal::clear_has_highengeneeringunits() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AppSignal::clear_highengeneeringunits() {
  highengeneeringunits_ = 0;
  clear_has_highengeneeringunits();
}
inline double AppSignal::highengeneeringunits() const {
  return highengeneeringunits_;
}
inline void AppSignal::set_highengeneeringunits(double value) {
  set_has_highengeneeringunits();
  highengeneeringunits_ = value;
}

// optional int32 unitID = 22;
inline bool AppSignal::has_unitid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AppSignal::set_has_unitid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AppSignal::clear_has_unitid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AppSignal::clear_unitid() {
  unitid_ = 0;
  clear_has_unitid();
}
inline ::google::protobuf::int32 AppSignal::unitid() const {
  return unitid_;
}
inline void AppSignal::set_unitid(::google::protobuf::int32 value) {
  set_has_unitid();
  unitid_ = value;
}

// optional double adjustment = 23;
inline bool AppSignal::has_adjustment() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AppSignal::set_has_adjustment() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AppSignal::clear_has_adjustment() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AppSignal::clear_adjustment() {
  adjustment_ = 0;
  clear_has_adjustment();
}
inline double AppSignal::adjustment() const {
  return adjustment_;
}
inline void AppSignal::set_adjustment(double value) {
  set_has_adjustment();
  adjustment_ = value;
}

// optional double lowValidRange = 24;
inline bool AppSignal::has_lowvalidrange() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AppSignal::set_has_lowvalidrange() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AppSignal::clear_has_lowvalidrange() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AppSignal::clear_lowvalidrange() {
  lowvalidrange_ = 0;
  clear_has_lowvalidrange();
}
inline double AppSignal::lowvalidrange() const {
  return lowvalidrange_;
}
inline void AppSignal::set_lowvalidrange(double value) {
  set_has_lowvalidrange();
  lowvalidrange_ = value;
}

// optional double highValidRange = 25;
inline bool AppSignal::has_highvalidrange() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AppSignal::set_has_highvalidrange() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AppSignal::clear_has_highvalidrange() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AppSignal::clear_highvalidrange() {
  highvalidrange_ = 0;
  clear_has_highvalidrange();
}
inline double AppSignal::highvalidrange() const {
  return highvalidrange_;
}
inline void AppSignal::set_highvalidrange(double value) {
  set_has_highvalidrange();
  highvalidrange_ = value;
}

// optional double unbalanceLimit = 26;
inline bool AppSignal::has_unbalancelimit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AppSignal::set_has_unbalancelimit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AppSignal::clear_has_unbalancelimit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AppSignal::clear_unbalancelimit() {
  unbalancelimit_ = 0;
  clear_has_unbalancelimit();
}
inline double AppSignal::unbalancelimit() const {
  return unbalancelimit_;
}
inline void AppSignal::set_unbalancelimit(double value) {
  set_has_unbalancelimit();
  unbalancelimit_ = value;
}

// optional double inputLowLimit = 27;
inline bool AppSignal::has_inputlowlimit() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AppSignal::set_has_inputlowlimit() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AppSignal::clear_has_inputlowlimit() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AppSignal::clear_inputlowlimit() {
  inputlowlimit_ = 0;
  clear_has_inputlowlimit();
}
inline double AppSignal::inputlowlimit() const {
  return inputlowlimit_;
}
inline void AppSignal::set_inputlowlimit(double value) {
  set_has_inputlowlimit();
  inputlowlimit_ = value;
}

// optional double inputHighLimit = 28;
inline bool AppSignal::has_inputhighlimit() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AppSignal::set_has_inputhighlimit() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AppSignal::clear_has_inputhighlimit() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AppSignal::clear_inputhighlimit() {
  inputhighlimit_ = 0;
  clear_has_inputhighlimit();
}
inline double AppSignal::inputhighlimit() const {
  return inputhighlimit_;
}
inline void AppSignal::set_inputhighlimit(double value) {
  set_has_inputhighlimit();
  inputhighlimit_ = value;
}

// optional int32 inputUnitID = 29;
inline bool AppSignal::has_inputunitid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AppSignal::set_has_inputunitid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AppSignal::clear_has_inputunitid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AppSignal::clear_inputunitid() {
  inputunitid_ = 0;
  clear_has_inputunitid();
}
inline ::google::protobuf::int32 AppSignal::inputunitid() const {
  return inputunitid_;
}
inline void AppSignal::set_inputunitid(::google::protobuf::int32 value) {
  set_has_inputunitid();
  inputunitid_ = value;
}

// optional int32 inputSensorID = 30;
inline bool AppSignal::has_inputsensorid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AppSignal::set_has_inputsensorid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AppSignal::clear_has_inputsensorid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AppSignal::clear_inputsensorid() {
  inputsensorid_ = 0;
  clear_has_inputsensorid();
}
inline ::google::protobuf::int32 AppSignal::inputsensorid() const {
  return inputsensorid_;
}
inline void AppSignal::set_inputsensorid(::google::protobuf::int32 value) {
  set_has_inputsensorid();
  inputsensorid_ = value;
}

// optional double outputLowLimit = 31;
inline bool AppSignal::has_outputlowlimit() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AppSignal::set_has_outputlowlimit() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AppSignal::clear_has_outputlowlimit() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AppSignal::clear_outputlowlimit() {
  outputlowlimit_ = 0;
  clear_has_outputlowlimit();
}
inline double AppSignal::outputlowlimit() const {
  return outputlowlimit_;
}
inline void AppSignal::set_outputlowlimit(double value) {
  set_has_outputlowlimit();
  outputlowlimit_ = value;
}

// optional double outputHighLimit = 32;
inline bool AppSignal::has_outputhighlimit() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AppSignal::set_has_outputhighlimit() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AppSignal::clear_has_outputhighlimit() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AppSignal::clear_outputhighlimit() {
  outputhighlimit_ = 0;
  clear_has_outputhighlimit();
}
inline double AppSignal::outputhighlimit() const {
  return outputhighlimit_;
}
inline void AppSignal::set_outputhighlimit(double value) {
  set_has_outputhighlimit();
  outputhighlimit_ = value;
}

// optional int32 outputUnitID = 33;
inline bool AppSignal::has_outputunitid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AppSignal::set_has_outputunitid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AppSignal::clear_has_outputunitid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AppSignal::clear_outputunitid() {
  outputunitid_ = 0;
  clear_has_outputunitid();
}
inline ::google::protobuf::int32 AppSignal::outputunitid() const {
  return outputunitid_;
}
inline void AppSignal::set_outputunitid(::google::protobuf::int32 value) {
  set_has_outputunitid();
  outputunitid_ = value;
}

// optional int32 outputMode = 34;
inline bool AppSignal::has_outputmode() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AppSignal::set_has_outputmode() {
  _has_bits_[1] |= 0x00000002u;
}
inline void AppSignal::clear_has_outputmode() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void AppSignal::clear_outputmode() {
  outputmode_ = 0;
  clear_has_outputmode();
}
inline ::google::protobuf::int32 AppSignal::outputmode() const {
  return outputmode_;
}
inline void AppSignal::set_outputmode(::google::protobuf::int32 value) {
  set_has_outputmode();
  outputmode_ = value;
}

// optional int32 outputSensorID = 35;
inline bool AppSignal::has_outputsensorid() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AppSignal::set_has_outputsensorid() {
  _has_bits_[1] |= 0x00000004u;
}
inline void AppSignal::clear_has_outputsensorid() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void AppSignal::clear_outputsensorid() {
  outputsensorid_ = 0;
  clear_has_outputsensorid();
}
inline ::google::protobuf::int32 AppSignal::outputsensorid() const {
  return outputsensorid_;
}
inline void AppSignal::set_outputsensorid(::google::protobuf::int32 value) {
  set_has_outputsensorid();
  outputsensorid_ = value;
}

// optional bool acquire = 36;
inline bool AppSignal::has_acquire() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AppSignal::set_has_acquire() {
  _has_bits_[1] |= 0x00000008u;
}
inline void AppSignal::clear_has_acquire() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void AppSignal::clear_acquire() {
  acquire_ = false;
  clear_has_acquire();
}
inline bool AppSignal::acquire() const {
  return acquire_;
}
inline void AppSignal::set_acquire(bool value) {
  set_has_acquire();
  acquire_ = value;
}

// optional bool calculated = 37;
inline bool AppSignal::has_calculated() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AppSignal::set_has_calculated() {
  _has_bits_[1] |= 0x00000010u;
}
inline void AppSignal::clear_has_calculated() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void AppSignal::clear_calculated() {
  calculated_ = false;
  clear_has_calculated();
}
inline bool AppSignal::calculated() const {
  return calculated_;
}
inline void AppSignal::set_calculated(bool value) {
  set_has_calculated();
  calculated_ = value;
}

// optional int32 normalState = 38;
inline bool AppSignal::has_normalstate() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AppSignal::set_has_normalstate() {
  _has_bits_[1] |= 0x00000020u;
}
inline void AppSignal::clear_has_normalstate() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void AppSignal::clear_normalstate() {
  normalstate_ = 0;
  clear_has_normalstate();
}
inline ::google::protobuf::int32 AppSignal::normalstate() const {
  return normalstate_;
}
inline void AppSignal::set_normalstate(::google::protobuf::int32 value) {
  set_has_normalstate();
  normalstate_ = value;
}

// optional int32 decimalPlaces = 39;
inline bool AppSignal::has_decimalplaces() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void AppSignal::set_has_decimalplaces() {
  _has_bits_[1] |= 0x00000040u;
}
inline void AppSignal::clear_has_decimalplaces() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void AppSignal::clear_decimalplaces() {
  decimalplaces_ = 0;
  clear_has_decimalplaces();
}
inline ::google::protobuf::int32 AppSignal::decimalplaces() const {
  return decimalplaces_;
}
inline void AppSignal::set_decimalplaces(::google::protobuf::int32 value) {
  set_has_decimalplaces();
  decimalplaces_ = value;
}

// optional double aperture = 40;
inline bool AppSignal::has_aperture() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void AppSignal::set_has_aperture() {
  _has_bits_[1] |= 0x00000080u;
}
inline void AppSignal::clear_has_aperture() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void AppSignal::clear_aperture() {
  aperture_ = 0;
  clear_has_aperture();
}
inline double AppSignal::aperture() const {
  return aperture_;
}
inline void AppSignal::set_aperture(double value) {
  set_has_aperture();
  aperture_ = value;
}

// optional int32 inOutType = 41;
inline bool AppSignal::has_inouttype() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void AppSignal::set_has_inouttype() {
  _has_bits_[1] |= 0x00000100u;
}
inline void AppSignal::clear_has_inouttype() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void AppSignal::clear_inouttype() {
  inouttype_ = 0;
  clear_has_inouttype();
}
inline ::google::protobuf::int32 AppSignal::inouttype() const {
  return inouttype_;
}
inline void AppSignal::set_inouttype(::google::protobuf::int32 value) {
  set_has_inouttype();
  inouttype_ = value;
}

// optional string equipmentID = 42;
inline bool AppSignal::has_equipmentid() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void AppSignal::set_has_equipmentid() {
  _has_bits_[1] |= 0x00000200u;
}
inline void AppSignal::clear_has_equipmentid() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void AppSignal::clear_equipmentid() {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    equipmentid_->clear();
  }
  clear_has_equipmentid();
}
inline const ::std::string& AppSignal::equipmentid() const {
  return *equipmentid_;
}
inline void AppSignal::set_equipmentid(const ::std::string& value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void AppSignal::set_equipmentid(const char* value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void AppSignal::set_equipmentid(const char* value, size_t size) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_equipmentid() {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  return equipmentid_;
}
inline ::std::string* AppSignal::release_equipmentid() {
  clear_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equipmentid_;
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_equipmentid(::std::string* equipmentid) {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete equipmentid_;
  }
  if (equipmentid) {
    set_has_equipmentid();
    equipmentid_ = equipmentid;
  } else {
    clear_has_equipmentid();
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double filteringTime = 43;
inline bool AppSignal::has_filteringtime() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void AppSignal::set_has_filteringtime() {
  _has_bits_[1] |= 0x00000400u;
}
inline void AppSignal::clear_has_filteringtime() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void AppSignal::clear_filteringtime() {
  filteringtime_ = 0;
  clear_has_filteringtime();
}
inline double AppSignal::filteringtime() const {
  return filteringtime_;
}
inline void AppSignal::set_filteringtime(double value) {
  set_has_filteringtime();
  filteringtime_ = value;
}

// optional double spreadTolerance = 44;
inline bool AppSignal::has_spreadtolerance() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void AppSignal::set_has_spreadtolerance() {
  _has_bits_[1] |= 0x00000800u;
}
inline void AppSignal::clear_has_spreadtolerance() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void AppSignal::clear_spreadtolerance() {
  spreadtolerance_ = 0;
  clear_has_spreadtolerance();
}
inline double AppSignal::spreadtolerance() const {
  return spreadtolerance_;
}
inline void AppSignal::set_spreadtolerance(double value) {
  set_has_spreadtolerance();
  spreadtolerance_ = value;
}

// optional int32 byteOrder = 45;
inline bool AppSignal::has_byteorder() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void AppSignal::set_has_byteorder() {
  _has_bits_[1] |= 0x00001000u;
}
inline void AppSignal::clear_has_byteorder() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void AppSignal::clear_byteorder() {
  byteorder_ = 0;
  clear_has_byteorder();
}
inline ::google::protobuf::int32 AppSignal::byteorder() const {
  return byteorder_;
}
inline void AppSignal::set_byteorder(::google::protobuf::int32 value) {
  set_has_byteorder();
  byteorder_ = value;
}

// optional bool enableTuning = 46;
inline bool AppSignal::has_enabletuning() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void AppSignal::set_has_enabletuning() {
  _has_bits_[1] |= 0x00002000u;
}
inline void AppSignal::clear_has_enabletuning() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void AppSignal::clear_enabletuning() {
  enabletuning_ = false;
  clear_has_enabletuning();
}
inline bool AppSignal::enabletuning() const {
  return enabletuning_;
}
inline void AppSignal::set_enabletuning(bool value) {
  set_has_enabletuning();
  enabletuning_ = value;
}

// optional float tuningDefaultValue = 47;
inline bool AppSignal::has_tuningdefaultvalue() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void AppSignal::set_has_tuningdefaultvalue() {
  _has_bits_[1] |= 0x00004000u;
}
inline void AppSignal::clear_has_tuningdefaultvalue() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void AppSignal::clear_tuningdefaultvalue() {
  tuningdefaultvalue_ = 0;
  clear_has_tuningdefaultvalue();
}
inline float AppSignal::tuningdefaultvalue() const {
  return tuningdefaultvalue_;
}
inline void AppSignal::set_tuningdefaultvalue(float value) {
  set_has_tuningdefaultvalue();
  tuningdefaultvalue_ = value;
}

// optional float tuningLowBound = 48;
inline bool AppSignal::has_tuninglowbound() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void AppSignal::set_has_tuninglowbound() {
  _has_bits_[1] |= 0x00008000u;
}
inline void AppSignal::clear_has_tuninglowbound() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void AppSignal::clear_tuninglowbound() {
  tuninglowbound_ = 0;
  clear_has_tuninglowbound();
}
inline float AppSignal::tuninglowbound() const {
  return tuninglowbound_;
}
inline void AppSignal::set_tuninglowbound(float value) {
  set_has_tuninglowbound();
  tuninglowbound_ = value;
}

// optional float tuningHighBound = 49;
inline bool AppSignal::has_tuninghighbound() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void AppSignal::set_has_tuninghighbound() {
  _has_bits_[1] |= 0x00010000u;
}
inline void AppSignal::clear_has_tuninghighbound() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void AppSignal::clear_tuninghighbound() {
  tuninghighbound_ = 0;
  clear_has_tuninghighbound();
}
inline float AppSignal::tuninghighbound() const {
  return tuninghighbound_;
}
inline void AppSignal::set_tuninghighbound(float value) {
  set_has_tuninghighbound();
  tuninghighbound_ = value;
}

// optional uint64 hash = 50;
inline bool AppSignal::has_hash() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void AppSignal::set_has_hash() {
  _has_bits_[1] |= 0x00020000u;
}
inline void AppSignal::clear_has_hash() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void AppSignal::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 AppSignal::hash() const {
  return hash_;
}
inline void AppSignal::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// optional string busTypeID = 51;
inline bool AppSignal::has_bustypeid() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void AppSignal::set_has_bustypeid() {
  _has_bits_[1] |= 0x00040000u;
}
inline void AppSignal::clear_has_bustypeid() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void AppSignal::clear_bustypeid() {
  if (bustypeid_ != &::google::protobuf::internal::kEmptyString) {
    bustypeid_->clear();
  }
  clear_has_bustypeid();
}
inline const ::std::string& AppSignal::bustypeid() const {
  return *bustypeid_;
}
inline void AppSignal::set_bustypeid(const ::std::string& value) {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  bustypeid_->assign(value);
}
inline void AppSignal::set_bustypeid(const char* value) {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  bustypeid_->assign(value);
}
inline void AppSignal::set_bustypeid(const char* value, size_t size) {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  bustypeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_bustypeid() {
  set_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    bustypeid_ = new ::std::string;
  }
  return bustypeid_;
}
inline ::std::string* AppSignal::release_bustypeid() {
  clear_has_bustypeid();
  if (bustypeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bustypeid_;
    bustypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_bustypeid(::std::string* bustypeid) {
  if (bustypeid_ != &::google::protobuf::internal::kEmptyString) {
    delete bustypeid_;
  }
  if (bustypeid) {
    set_has_bustypeid();
    bustypeid_ = bustypeid;
  } else {
    clear_has_bustypeid();
    bustypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool adaptiveAperture = 52;
inline bool AppSignal::has_adaptiveaperture() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void AppSignal::set_has_adaptiveaperture() {
  _has_bits_[1] |= 0x00080000u;
}
inline void AppSignal::clear_has_adaptiveaperture() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void AppSignal::clear_adaptiveaperture() {
  adaptiveaperture_ = false;
  clear_has_adaptiveaperture();
}
inline bool AppSignal::adaptiveaperture() const {
  return adaptiveaperture_;
}
inline void AppSignal::set_adaptiveaperture(bool value) {
  set_has_adaptiveaperture();
  adaptiveaperture_ = value;
}

// optional int32 regValueAddrOffset = 200;
inline bool AppSignal::has_regvalueaddroffset() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void AppSignal::set_has_regvalueaddroffset() {
  _has_bits_[1] |= 0x00100000u;
}
inline void AppSignal::clear_has_regvalueaddroffset() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void AppSignal::clear_regvalueaddroffset() {
  regvalueaddroffset_ = 0;
  clear_has_regvalueaddroffset();
}
inline ::google::protobuf::int32 AppSignal::regvalueaddroffset() const {
  return regvalueaddroffset_;
}
inline void AppSignal::set_regvalueaddroffset(::google::protobuf::int32 value) {
  set_has_regvalueaddroffset();
  regvalueaddroffset_ = value;
}

// optional int32 regValueAddrBit = 201;
inline bool AppSignal::has_regvalueaddrbit() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void AppSignal::set_has_regvalueaddrbit() {
  _has_bits_[1] |= 0x00200000u;
}
inline void AppSignal::clear_has_regvalueaddrbit() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void AppSignal::clear_regvalueaddrbit() {
  regvalueaddrbit_ = 0;
  clear_has_regvalueaddrbit();
}
inline ::google::protobuf::int32 AppSignal::regvalueaddrbit() const {
  return regvalueaddrbit_;
}
inline void AppSignal::set_regvalueaddrbit(::google::protobuf::int32 value) {
  set_has_regvalueaddrbit();
  regvalueaddrbit_ = value;
}

// optional int32 regValidityAddrOffset = 202;
inline bool AppSignal::has_regvalidityaddroffset() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void AppSignal::set_has_regvalidityaddroffset() {
  _has_bits_[1] |= 0x00400000u;
}
inline void AppSignal::clear_has_regvalidityaddroffset() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void AppSignal::clear_regvalidityaddroffset() {
  regvalidityaddroffset_ = 0;
  clear_has_regvalidityaddroffset();
}
inline ::google::protobuf::int32 AppSignal::regvalidityaddroffset() const {
  return regvalidityaddroffset_;
}
inline void AppSignal::set_regvalidityaddroffset(::google::protobuf::int32 value) {
  set_has_regvalidityaddroffset();
  regvalidityaddroffset_ = value;
}

// optional int32 regValidityAddrBit = 203;
inline bool AppSignal::has_regvalidityaddrbit() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void AppSignal::set_has_regvalidityaddrbit() {
  _has_bits_[1] |= 0x00800000u;
}
inline void AppSignal::clear_has_regvalidityaddrbit() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void AppSignal::clear_regvalidityaddrbit() {
  regvalidityaddrbit_ = 0;
  clear_has_regvalidityaddrbit();
}
inline ::google::protobuf::int32 AppSignal::regvalidityaddrbit() const {
  return regvalidityaddrbit_;
}
inline void AppSignal::set_regvalidityaddrbit(::google::protobuf::int32 value) {
  set_has_regvalidityaddrbit();
  regvalidityaddrbit_ = value;
}

// optional int32 ioBufferAddrOffset = 204;
inline bool AppSignal::has_iobufferaddroffset() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void AppSignal::set_has_iobufferaddroffset() {
  _has_bits_[1] |= 0x01000000u;
}
inline void AppSignal::clear_has_iobufferaddroffset() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void AppSignal::clear_iobufferaddroffset() {
  iobufferaddroffset_ = 0;
  clear_has_iobufferaddroffset();
}
inline ::google::protobuf::int32 AppSignal::iobufferaddroffset() const {
  return iobufferaddroffset_;
}
inline void AppSignal::set_iobufferaddroffset(::google::protobuf::int32 value) {
  set_has_iobufferaddroffset();
  iobufferaddroffset_ = value;
}

// optional int32 ioBufferAddrBit = 205;
inline bool AppSignal::has_iobufferaddrbit() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void AppSignal::set_has_iobufferaddrbit() {
  _has_bits_[1] |= 0x02000000u;
}
inline void AppSignal::clear_has_iobufferaddrbit() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void AppSignal::clear_iobufferaddrbit() {
  iobufferaddrbit_ = 0;
  clear_has_iobufferaddrbit();
}
inline ::google::protobuf::int32 AppSignal::iobufferaddrbit() const {
  return iobufferaddrbit_;
}
inline void AppSignal::set_iobufferaddrbit(::google::protobuf::int32 value) {
  set_has_iobufferaddrbit();
  iobufferaddrbit_ = value;
}

// optional int32 ramAddrOffset = 206;
inline bool AppSignal::has_ramaddroffset() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void AppSignal::set_has_ramaddroffset() {
  _has_bits_[1] |= 0x04000000u;
}
inline void AppSignal::clear_has_ramaddroffset() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void AppSignal::clear_ramaddroffset() {
  ramaddroffset_ = 0;
  clear_has_ramaddroffset();
}
inline ::google::protobuf::int32 AppSignal::ramaddroffset() const {
  return ramaddroffset_;
}
inline void AppSignal::set_ramaddroffset(::google::protobuf::int32 value) {
  set_has_ramaddroffset();
  ramaddroffset_ = value;
}

// optional int32 ramAddrBit = 207;
inline bool AppSignal::has_ramaddrbit() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void AppSignal::set_has_ramaddrbit() {
  _has_bits_[1] |= 0x08000000u;
}
inline void AppSignal::clear_has_ramaddrbit() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void AppSignal::clear_ramaddrbit() {
  ramaddrbit_ = 0;
  clear_has_ramaddrbit();
}
inline ::google::protobuf::int32 AppSignal::ramaddrbit() const {
  return ramaddrbit_;
}
inline void AppSignal::set_ramaddrbit(::google::protobuf::int32 value) {
  set_has_ramaddrbit();
  ramaddrbit_ = value;
}

// -------------------------------------------------------------------

// AppSignalState

// optional uint64 hash = 1 [default = 0];
inline bool AppSignalState::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppSignalState::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppSignalState::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppSignalState::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 AppSignalState::hash() const {
  return hash_;
}
inline void AppSignalState::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// optional double value = 2 [default = 0];
inline bool AppSignalState::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppSignalState::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppSignalState::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppSignalState::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double AppSignalState::value() const {
  return value_;
}
inline void AppSignalState::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional uint32 flags = 3 [default = 0];
inline bool AppSignalState::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppSignalState::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppSignalState::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppSignalState::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 AppSignalState::flags() const {
  return flags_;
}
inline void AppSignalState::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional sint64 systemTime = 4 [default = 0];
inline bool AppSignalState::has_systemtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppSignalState::set_has_systemtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppSignalState::clear_has_systemtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppSignalState::clear_systemtime() {
  systemtime_ = GOOGLE_LONGLONG(0);
  clear_has_systemtime();
}
inline ::google::protobuf::int64 AppSignalState::systemtime() const {
  return systemtime_;
}
inline void AppSignalState::set_systemtime(::google::protobuf::int64 value) {
  set_has_systemtime();
  systemtime_ = value;
}

// optional sint64 localTime = 5 [default = 0];
inline bool AppSignalState::has_localtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppSignalState::set_has_localtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppSignalState::clear_has_localtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppSignalState::clear_localtime() {
  localtime_ = GOOGLE_LONGLONG(0);
  clear_has_localtime();
}
inline ::google::protobuf::int64 AppSignalState::localtime() const {
  return localtime_;
}
inline void AppSignalState::set_localtime(::google::protobuf::int64 value) {
  set_has_localtime();
  localtime_ = value;
}

// optional sint64 plantTime = 6 [default = 0];
inline bool AppSignalState::has_planttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppSignalState::set_has_planttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppSignalState::clear_has_planttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppSignalState::clear_planttime() {
  planttime_ = GOOGLE_LONGLONG(0);
  clear_has_planttime();
}
inline ::google::protobuf::int64 AppSignalState::planttime() const {
  return planttime_;
}
inline void AppSignalState::set_planttime(::google::protobuf::int64 value) {
  set_has_planttime();
  planttime_ = value;
}

// -------------------------------------------------------------------

// AppSignalParam

// optional uint64 hash = 2 [default = 0];
inline bool AppSignalParam::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppSignalParam::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppSignalParam::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppSignalParam::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 AppSignalParam::hash() const {
  return hash_;
}
inline void AppSignalParam::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// optional string appSignalId = 3 [default = ""];
inline bool AppSignalParam::has_appsignalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppSignalParam::set_has_appsignalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppSignalParam::clear_has_appsignalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppSignalParam::clear_appsignalid() {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    appsignalid_->clear();
  }
  clear_has_appsignalid();
}
inline const ::std::string& AppSignalParam::appsignalid() const {
  return *appsignalid_;
}
inline void AppSignalParam::set_appsignalid(const ::std::string& value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void AppSignalParam::set_appsignalid(const char* value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void AppSignalParam::set_appsignalid(const char* value, size_t size) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignalParam::mutable_appsignalid() {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  return appsignalid_;
}
inline ::std::string* AppSignalParam::release_appsignalid() {
  clear_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appsignalid_;
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignalParam::set_allocated_appsignalid(::std::string* appsignalid) {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete appsignalid_;
  }
  if (appsignalid) {
    set_has_appsignalid();
    appsignalid_ = appsignalid;
  } else {
    clear_has_appsignalid();
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customSignalId = 4 [default = ""];
inline bool AppSignalParam::has_customsignalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppSignalParam::set_has_customsignalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppSignalParam::clear_has_customsignalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppSignalParam::clear_customsignalid() {
  if (customsignalid_ != &::google::protobuf::internal::kEmptyString) {
    customsignalid_->clear();
  }
  clear_has_customsignalid();
}
inline const ::std::string& AppSignalParam::customsignalid() const {
  return *customsignalid_;
}
inline void AppSignalParam::set_customsignalid(const ::std::string& value) {
  set_has_customsignalid();
  if (customsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customsignalid_ = new ::std::string;
  }
  customsignalid_->assign(value);
}
inline void AppSignalParam::set_customsignalid(const char* value) {
  set_has_customsignalid();
  if (customsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customsignalid_ = new ::std::string;
  }
  customsignalid_->assign(value);
}
inline void AppSignalParam::set_customsignalid(const char* value, size_t size) {
  set_has_customsignalid();
  if (customsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customsignalid_ = new ::std::string;
  }
  customsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignalParam::mutable_customsignalid() {
  set_has_customsignalid();
  if (customsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customsignalid_ = new ::std::string;
  }
  return customsignalid_;
}
inline ::std::string* AppSignalParam::release_customsignalid() {
  clear_has_customsignalid();
  if (customsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customsignalid_;
    customsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignalParam::set_allocated_customsignalid(::std::string* customsignalid) {
  if (customsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete customsignalid_;
  }
  if (customsignalid) {
    set_has_customsignalid();
    customsignalid_ = customsignalid;
  } else {
    clear_has_customsignalid();
    customsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string caption = 5 [default = ""];
inline bool AppSignalParam::has_caption() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppSignalParam::set_has_caption() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppSignalParam::clear_has_caption() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppSignalParam::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& AppSignalParam::caption() const {
  return *caption_;
}
inline void AppSignalParam::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void AppSignalParam::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void AppSignalParam::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignalParam::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* AppSignalParam::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignalParam::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string equipmentId = 6 [default = ""];
inline bool AppSignalParam::has_equipmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppSignalParam::set_has_equipmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppSignalParam::clear_has_equipmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppSignalParam::clear_equipmentid() {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    equipmentid_->clear();
  }
  clear_has_equipmentid();
}
inline const ::std::string& AppSignalParam::equipmentid() const {
  return *equipmentid_;
}
inline void AppSignalParam::set_equipmentid(const ::std::string& value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void AppSignalParam::set_equipmentid(const char* value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void AppSignalParam::set_equipmentid(const char* value, size_t size) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignalParam::mutable_equipmentid() {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  return equipmentid_;
}
inline ::std::string* AppSignalParam::release_equipmentid() {
  clear_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equipmentid_;
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignalParam::set_allocated_equipmentid(::std::string* equipmentid) {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete equipmentid_;
  }
  if (equipmentid) {
    set_has_equipmentid();
    equipmentid_ = equipmentid;
  } else {
    clear_has_equipmentid();
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channel = 10 [default = 0];
inline bool AppSignalParam::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppSignalParam::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppSignalParam::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppSignalParam::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 AppSignalParam::channel() const {
  return channel_;
}
inline void AppSignalParam::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 inOutType = 11 [default = 2];
inline bool AppSignalParam::has_inouttype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppSignalParam::set_has_inouttype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AppSignalParam::clear_has_inouttype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AppSignalParam::clear_inouttype() {
  inouttype_ = 2;
  clear_has_inouttype();
}
inline ::google::protobuf::int32 AppSignalParam::inouttype() const {
  return inouttype_;
}
inline void AppSignalParam::set_inouttype(::google::protobuf::int32 value) {
  set_has_inouttype();
  inouttype_ = value;
}

// optional int32 signalType = 12 [default = 0];
inline bool AppSignalParam::has_signaltype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppSignalParam::set_has_signaltype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AppSignalParam::clear_has_signaltype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AppSignalParam::clear_signaltype() {
  signaltype_ = 0;
  clear_has_signaltype();
}
inline ::google::protobuf::int32 AppSignalParam::signaltype() const {
  return signaltype_;
}
inline void AppSignalParam::set_signaltype(::google::protobuf::int32 value) {
  set_has_signaltype();
  signaltype_ = value;
}

// optional int32 analogSignalFormat = 13 [default = 2];
inline bool AppSignalParam::has_analogsignalformat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppSignalParam::set_has_analogsignalformat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AppSignalParam::clear_has_analogsignalformat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AppSignalParam::clear_analogsignalformat() {
  analogsignalformat_ = 2;
  clear_has_analogsignalformat();
}
inline ::google::protobuf::int32 AppSignalParam::analogsignalformat() const {
  return analogsignalformat_;
}
inline void AppSignalParam::set_analogsignalformat(::google::protobuf::int32 value) {
  set_has_analogsignalformat();
  analogsignalformat_ = value;
}

// optional int32 byteOrder = 14 [default = 2];
inline bool AppSignalParam::has_byteorder() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AppSignalParam::set_has_byteorder() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AppSignalParam::clear_has_byteorder() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AppSignalParam::clear_byteorder() {
  byteorder_ = 2;
  clear_has_byteorder();
}
inline ::google::protobuf::int32 AppSignalParam::byteorder() const {
  return byteorder_;
}
inline void AppSignalParam::set_byteorder(::google::protobuf::int32 value) {
  set_has_byteorder();
  byteorder_ = value;
}

// optional int32 unitId = 15 [default = 1];
inline bool AppSignalParam::has_unitid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AppSignalParam::set_has_unitid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AppSignalParam::clear_has_unitid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AppSignalParam::clear_unitid() {
  unitid_ = 1;
  clear_has_unitid();
}
inline ::google::protobuf::int32 AppSignalParam::unitid() const {
  return unitid_;
}
inline void AppSignalParam::set_unitid(::google::protobuf::int32 value) {
  set_has_unitid();
  unitid_ = value;
}

// optional string unit = 16 [default = ""];
inline bool AppSignalParam::has_unit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AppSignalParam::set_has_unit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AppSignalParam::clear_has_unit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AppSignalParam::clear_unit() {
  if (unit_ != &::google::protobuf::internal::kEmptyString) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& AppSignalParam::unit() const {
  return *unit_;
}
inline void AppSignalParam::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
}
inline void AppSignalParam::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
}
inline void AppSignalParam::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignalParam::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  return unit_;
}
inline ::std::string* AppSignalParam::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignalParam::set_allocated_unit(::std::string* unit) {
  if (unit_ != &::google::protobuf::internal::kEmptyString) {
    delete unit_;
  }
  if (unit) {
    set_has_unit();
    unit_ = unit;
  } else {
    clear_has_unit();
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double lowValidRange = 20 [default = 0];
inline bool AppSignalParam::has_lowvalidrange() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AppSignalParam::set_has_lowvalidrange() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AppSignalParam::clear_has_lowvalidrange() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AppSignalParam::clear_lowvalidrange() {
  lowvalidrange_ = 0;
  clear_has_lowvalidrange();
}
inline double AppSignalParam::lowvalidrange() const {
  return lowvalidrange_;
}
inline void AppSignalParam::set_lowvalidrange(double value) {
  set_has_lowvalidrange();
  lowvalidrange_ = value;
}

// optional double highValidRange = 21 [default = 0];
inline bool AppSignalParam::has_highvalidrange() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AppSignalParam::set_has_highvalidrange() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AppSignalParam::clear_has_highvalidrange() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AppSignalParam::clear_highvalidrange() {
  highvalidrange_ = 0;
  clear_has_highvalidrange();
}
inline double AppSignalParam::highvalidrange() const {
  return highvalidrange_;
}
inline void AppSignalParam::set_highvalidrange(double value) {
  set_has_highvalidrange();
  highvalidrange_ = value;
}

// optional double lowEngeneeringUnits = 22 [default = 0];
inline bool AppSignalParam::has_lowengeneeringunits() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AppSignalParam::set_has_lowengeneeringunits() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AppSignalParam::clear_has_lowengeneeringunits() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AppSignalParam::clear_lowengeneeringunits() {
  lowengeneeringunits_ = 0;
  clear_has_lowengeneeringunits();
}
inline double AppSignalParam::lowengeneeringunits() const {
  return lowengeneeringunits_;
}
inline void AppSignalParam::set_lowengeneeringunits(double value) {
  set_has_lowengeneeringunits();
  lowengeneeringunits_ = value;
}

// optional double highEngeneeringUnits = 23 [default = 0];
inline bool AppSignalParam::has_highengeneeringunits() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AppSignalParam::set_has_highengeneeringunits() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AppSignalParam::clear_has_highengeneeringunits() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AppSignalParam::clear_highengeneeringunits() {
  highengeneeringunits_ = 0;
  clear_has_highengeneeringunits();
}
inline double AppSignalParam::highengeneeringunits() const {
  return highengeneeringunits_;
}
inline void AppSignalParam::set_highengeneeringunits(double value) {
  set_has_highengeneeringunits();
  highengeneeringunits_ = value;
}

// optional double inputLowLimit = 30 [default = 0];
inline bool AppSignalParam::has_inputlowlimit() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AppSignalParam::set_has_inputlowlimit() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AppSignalParam::clear_has_inputlowlimit() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AppSignalParam::clear_inputlowlimit() {
  inputlowlimit_ = 0;
  clear_has_inputlowlimit();
}
inline double AppSignalParam::inputlowlimit() const {
  return inputlowlimit_;
}
inline void AppSignalParam::set_inputlowlimit(double value) {
  set_has_inputlowlimit();
  inputlowlimit_ = value;
}

// optional double inputHighLimit = 31 [default = 0];
inline bool AppSignalParam::has_inputhighlimit() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AppSignalParam::set_has_inputhighlimit() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AppSignalParam::clear_has_inputhighlimit() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AppSignalParam::clear_inputhighlimit() {
  inputhighlimit_ = 0;
  clear_has_inputhighlimit();
}
inline double AppSignalParam::inputhighlimit() const {
  return inputhighlimit_;
}
inline void AppSignalParam::set_inputhighlimit(double value) {
  set_has_inputhighlimit();
  inputhighlimit_ = value;
}

// optional int32 inputUnitId = 32 [default = 1];
inline bool AppSignalParam::has_inputunitid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AppSignalParam::set_has_inputunitid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AppSignalParam::clear_has_inputunitid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AppSignalParam::clear_inputunitid() {
  inputunitid_ = 1;
  clear_has_inputunitid();
}
inline ::google::protobuf::int32 AppSignalParam::inputunitid() const {
  return inputunitid_;
}
inline void AppSignalParam::set_inputunitid(::google::protobuf::int32 value) {
  set_has_inputunitid();
  inputunitid_ = value;
}

// optional int32 inputSensorType = 33 [default = 0];
inline bool AppSignalParam::has_inputsensortype() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AppSignalParam::set_has_inputsensortype() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AppSignalParam::clear_has_inputsensortype() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AppSignalParam::clear_inputsensortype() {
  inputsensortype_ = 0;
  clear_has_inputsensortype();
}
inline ::google::protobuf::int32 AppSignalParam::inputsensortype() const {
  return inputsensortype_;
}
inline void AppSignalParam::set_inputsensortype(::google::protobuf::int32 value) {
  set_has_inputsensortype();
  inputsensortype_ = value;
}

// optional double outputLowLimit = 40 [default = 0];
inline bool AppSignalParam::has_outputlowlimit() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AppSignalParam::set_has_outputlowlimit() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AppSignalParam::clear_has_outputlowlimit() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AppSignalParam::clear_outputlowlimit() {
  outputlowlimit_ = 0;
  clear_has_outputlowlimit();
}
inline double AppSignalParam::outputlowlimit() const {
  return outputlowlimit_;
}
inline void AppSignalParam::set_outputlowlimit(double value) {
  set_has_outputlowlimit();
  outputlowlimit_ = value;
}

// optional double outputHighLimit = 41 [default = 0];
inline bool AppSignalParam::has_outputhighlimit() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AppSignalParam::set_has_outputhighlimit() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AppSignalParam::clear_has_outputhighlimit() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AppSignalParam::clear_outputhighlimit() {
  outputhighlimit_ = 0;
  clear_has_outputhighlimit();
}
inline double AppSignalParam::outputhighlimit() const {
  return outputhighlimit_;
}
inline void AppSignalParam::set_outputhighlimit(double value) {
  set_has_outputhighlimit();
  outputhighlimit_ = value;
}

// optional int32 outputUnitId = 42 [default = 1];
inline bool AppSignalParam::has_outputunitid() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AppSignalParam::set_has_outputunitid() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AppSignalParam::clear_has_outputunitid() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AppSignalParam::clear_outputunitid() {
  outputunitid_ = 1;
  clear_has_outputunitid();
}
inline ::google::protobuf::int32 AppSignalParam::outputunitid() const {
  return outputunitid_;
}
inline void AppSignalParam::set_outputunitid(::google::protobuf::int32 value) {
  set_has_outputunitid();
  outputunitid_ = value;
}

// optional int32 outputMode = 43 [default = 0];
inline bool AppSignalParam::has_outputmode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AppSignalParam::set_has_outputmode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AppSignalParam::clear_has_outputmode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AppSignalParam::clear_outputmode() {
  outputmode_ = 0;
  clear_has_outputmode();
}
inline ::google::protobuf::int32 AppSignalParam::outputmode() const {
  return outputmode_;
}
inline void AppSignalParam::set_outputmode(::google::protobuf::int32 value) {
  set_has_outputmode();
  outputmode_ = value;
}

// optional int32 outputSensorType = 44 [default = 0];
inline bool AppSignalParam::has_outputsensortype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AppSignalParam::set_has_outputsensortype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AppSignalParam::clear_has_outputsensortype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AppSignalParam::clear_outputsensortype() {
  outputsensortype_ = 0;
  clear_has_outputsensortype();
}
inline ::google::protobuf::int32 AppSignalParam::outputsensortype() const {
  return outputsensortype_;
}
inline void AppSignalParam::set_outputsensortype(::google::protobuf::int32 value) {
  set_has_outputsensortype();
  outputsensortype_ = value;
}

// optional int32 precision = 50 [default = 2];
inline bool AppSignalParam::has_precision() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AppSignalParam::set_has_precision() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AppSignalParam::clear_has_precision() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AppSignalParam::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 AppSignalParam::precision() const {
  return precision_;
}
inline void AppSignalParam::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional double aperture = 51 [default = 1];
inline bool AppSignalParam::has_aperture() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AppSignalParam::set_has_aperture() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AppSignalParam::clear_has_aperture() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AppSignalParam::clear_aperture() {
  aperture_ = 1;
  clear_has_aperture();
}
inline double AppSignalParam::aperture() const {
  return aperture_;
}
inline void AppSignalParam::set_aperture(double value) {
  set_has_aperture();
  aperture_ = value;
}

// optional double filteringTime = 52 [default = 0.005];
inline bool AppSignalParam::has_filteringtime() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AppSignalParam::set_has_filteringtime() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AppSignalParam::clear_has_filteringtime() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AppSignalParam::clear_filteringtime() {
  filteringtime_ = 0.005;
  clear_has_filteringtime();
}
inline double AppSignalParam::filteringtime() const {
  return filteringtime_;
}
inline void AppSignalParam::set_filteringtime(double value) {
  set_has_filteringtime();
  filteringtime_ = value;
}

// optional double spreadTolerance = 53 [default = 2];
inline bool AppSignalParam::has_spreadtolerance() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AppSignalParam::set_has_spreadtolerance() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AppSignalParam::clear_has_spreadtolerance() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AppSignalParam::clear_spreadtolerance() {
  spreadtolerance_ = 2;
  clear_has_spreadtolerance();
}
inline double AppSignalParam::spreadtolerance() const {
  return spreadtolerance_;
}
inline void AppSignalParam::set_spreadtolerance(double value) {
  set_has_spreadtolerance();
  spreadtolerance_ = value;
}

// optional bool enableTuning = 54 [default = false];
inline bool AppSignalParam::has_enabletuning() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AppSignalParam::set_has_enabletuning() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AppSignalParam::clear_has_enabletuning() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AppSignalParam::clear_enabletuning() {
  enabletuning_ = false;
  clear_has_enabletuning();
}
inline bool AppSignalParam::enabletuning() const {
  return enabletuning_;
}
inline void AppSignalParam::set_enabletuning(bool value) {
  set_has_enabletuning();
  enabletuning_ = value;
}

// optional double tuningDefaultValue = 55 [default = 0];
inline bool AppSignalParam::has_tuningdefaultvalue() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AppSignalParam::set_has_tuningdefaultvalue() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AppSignalParam::clear_has_tuningdefaultvalue() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AppSignalParam::clear_tuningdefaultvalue() {
  tuningdefaultvalue_ = 0;
  clear_has_tuningdefaultvalue();
}
inline double AppSignalParam::tuningdefaultvalue() const {
  return tuningdefaultvalue_;
}
inline void AppSignalParam::set_tuningdefaultvalue(double value) {
  set_has_tuningdefaultvalue();
  tuningdefaultvalue_ = value;
}

// -------------------------------------------------------------------

// AppSignalParamSet

// repeated .Proto.AppSignalParam items = 1;
inline int AppSignalParamSet::items_size() const {
  return items_.size();
}
inline void AppSignalParamSet::clear_items() {
  items_.Clear();
}
inline const ::Proto::AppSignalParam& AppSignalParamSet::items(int index) const {
  return items_.Get(index);
}
inline ::Proto::AppSignalParam* AppSignalParamSet::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Proto::AppSignalParam* AppSignalParamSet::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AppSignalParam >&
AppSignalParamSet::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AppSignalParam >*
AppSignalParamSet::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// Connection

// optional string ConnectionID = 2 [default = ""];
inline bool Connection::has_connectionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connection::set_has_connectionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connection::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connection::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& Connection::connectionid() const {
  return *connectionid_;
}
inline void Connection::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void Connection::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void Connection::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connection::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* Connection::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connection::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Port1EquipmentID = 3 [default = ""];
inline bool Connection::has_port1equipmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connection::set_has_port1equipmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connection::clear_has_port1equipmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connection::clear_port1equipmentid() {
  if (port1equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    port1equipmentid_->clear();
  }
  clear_has_port1equipmentid();
}
inline const ::std::string& Connection::port1equipmentid() const {
  return *port1equipmentid_;
}
inline void Connection::set_port1equipmentid(const ::std::string& value) {
  set_has_port1equipmentid();
  if (port1equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port1equipmentid_ = new ::std::string;
  }
  port1equipmentid_->assign(value);
}
inline void Connection::set_port1equipmentid(const char* value) {
  set_has_port1equipmentid();
  if (port1equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port1equipmentid_ = new ::std::string;
  }
  port1equipmentid_->assign(value);
}
inline void Connection::set_port1equipmentid(const char* value, size_t size) {
  set_has_port1equipmentid();
  if (port1equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port1equipmentid_ = new ::std::string;
  }
  port1equipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connection::mutable_port1equipmentid() {
  set_has_port1equipmentid();
  if (port1equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port1equipmentid_ = new ::std::string;
  }
  return port1equipmentid_;
}
inline ::std::string* Connection::release_port1equipmentid() {
  clear_has_port1equipmentid();
  if (port1equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port1equipmentid_;
    port1equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connection::set_allocated_port1equipmentid(::std::string* port1equipmentid) {
  if (port1equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete port1equipmentid_;
  }
  if (port1equipmentid) {
    set_has_port1equipmentid();
    port1equipmentid_ = port1equipmentid;
  } else {
    clear_has_port1equipmentid();
    port1equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Port2EquipmentID = 4 [default = ""];
inline bool Connection::has_port2equipmentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Connection::set_has_port2equipmentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Connection::clear_has_port2equipmentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Connection::clear_port2equipmentid() {
  if (port2equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    port2equipmentid_->clear();
  }
  clear_has_port2equipmentid();
}
inline const ::std::string& Connection::port2equipmentid() const {
  return *port2equipmentid_;
}
inline void Connection::set_port2equipmentid(const ::std::string& value) {
  set_has_port2equipmentid();
  if (port2equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port2equipmentid_ = new ::std::string;
  }
  port2equipmentid_->assign(value);
}
inline void Connection::set_port2equipmentid(const char* value) {
  set_has_port2equipmentid();
  if (port2equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port2equipmentid_ = new ::std::string;
  }
  port2equipmentid_->assign(value);
}
inline void Connection::set_port2equipmentid(const char* value, size_t size) {
  set_has_port2equipmentid();
  if (port2equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port2equipmentid_ = new ::std::string;
  }
  port2equipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connection::mutable_port2equipmentid() {
  set_has_port2equipmentid();
  if (port2equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    port2equipmentid_ = new ::std::string;
  }
  return port2equipmentid_;
}
inline ::std::string* Connection::release_port2equipmentid() {
  clear_has_port2equipmentid();
  if (port2equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port2equipmentid_;
    port2equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connection::set_allocated_port2equipmentid(::std::string* port2equipmentid) {
  if (port2equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete port2equipmentid_;
  }
  if (port2equipmentid) {
    set_has_port2equipmentid();
    port2equipmentid_ = port2equipmentid;
  } else {
    clear_has_port2equipmentid();
    port2equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Port1RawDataDescription = 5 [default = ""];
inline bool Connection::has_port1rawdatadescription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Connection::set_has_port1rawdatadescription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Connection::clear_has_port1rawdatadescription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Connection::clear_port1rawdatadescription() {
  if (port1rawdatadescription_ != &::google::protobuf::internal::kEmptyString) {
    port1rawdatadescription_->clear();
  }
  clear_has_port1rawdatadescription();
}
inline const ::std::string& Connection::port1rawdatadescription() const {
  return *port1rawdatadescription_;
}
inline void Connection::set_port1rawdatadescription(const ::std::string& value) {
  set_has_port1rawdatadescription();
  if (port1rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port1rawdatadescription_ = new ::std::string;
  }
  port1rawdatadescription_->assign(value);
}
inline void Connection::set_port1rawdatadescription(const char* value) {
  set_has_port1rawdatadescription();
  if (port1rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port1rawdatadescription_ = new ::std::string;
  }
  port1rawdatadescription_->assign(value);
}
inline void Connection::set_port1rawdatadescription(const char* value, size_t size) {
  set_has_port1rawdatadescription();
  if (port1rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port1rawdatadescription_ = new ::std::string;
  }
  port1rawdatadescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connection::mutable_port1rawdatadescription() {
  set_has_port1rawdatadescription();
  if (port1rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port1rawdatadescription_ = new ::std::string;
  }
  return port1rawdatadescription_;
}
inline ::std::string* Connection::release_port1rawdatadescription() {
  clear_has_port1rawdatadescription();
  if (port1rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port1rawdatadescription_;
    port1rawdatadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connection::set_allocated_port1rawdatadescription(::std::string* port1rawdatadescription) {
  if (port1rawdatadescription_ != &::google::protobuf::internal::kEmptyString) {
    delete port1rawdatadescription_;
  }
  if (port1rawdatadescription) {
    set_has_port1rawdatadescription();
    port1rawdatadescription_ = port1rawdatadescription;
  } else {
    clear_has_port1rawdatadescription();
    port1rawdatadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Port2RawDataDescription = 6 [default = ""];
inline bool Connection::has_port2rawdatadescription() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Connection::set_has_port2rawdatadescription() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Connection::clear_has_port2rawdatadescription() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Connection::clear_port2rawdatadescription() {
  if (port2rawdatadescription_ != &::google::protobuf::internal::kEmptyString) {
    port2rawdatadescription_->clear();
  }
  clear_has_port2rawdatadescription();
}
inline const ::std::string& Connection::port2rawdatadescription() const {
  return *port2rawdatadescription_;
}
inline void Connection::set_port2rawdatadescription(const ::std::string& value) {
  set_has_port2rawdatadescription();
  if (port2rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port2rawdatadescription_ = new ::std::string;
  }
  port2rawdatadescription_->assign(value);
}
inline void Connection::set_port2rawdatadescription(const char* value) {
  set_has_port2rawdatadescription();
  if (port2rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port2rawdatadescription_ = new ::std::string;
  }
  port2rawdatadescription_->assign(value);
}
inline void Connection::set_port2rawdatadescription(const char* value, size_t size) {
  set_has_port2rawdatadescription();
  if (port2rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port2rawdatadescription_ = new ::std::string;
  }
  port2rawdatadescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connection::mutable_port2rawdatadescription() {
  set_has_port2rawdatadescription();
  if (port2rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    port2rawdatadescription_ = new ::std::string;
  }
  return port2rawdatadescription_;
}
inline ::std::string* Connection::release_port2rawdatadescription() {
  clear_has_port2rawdatadescription();
  if (port2rawdatadescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port2rawdatadescription_;
    port2rawdatadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connection::set_allocated_port2rawdatadescription(::std::string* port2rawdatadescription) {
  if (port2rawdatadescription_ != &::google::protobuf::internal::kEmptyString) {
    delete port2rawdatadescription_;
  }
  if (port2rawdatadescription) {
    set_has_port2rawdatadescription();
    port2rawdatadescription_ = port2rawdatadescription;
  } else {
    clear_has_port2rawdatadescription();
    port2rawdatadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool ManualSettings = 11 [default = false];
inline bool Connection::has_manualsettings() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Connection::set_has_manualsettings() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Connection::clear_has_manualsettings() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Connection::clear_manualsettings() {
  manualsettings_ = false;
  clear_has_manualsettings();
}
inline bool Connection::manualsettings() const {
  return manualsettings_;
}
inline void Connection::set_manualsettings(bool value) {
  set_has_manualsettings();
  manualsettings_ = value;
}

// optional bool DisableDataID = 12 [default = false];
inline bool Connection::has_disabledataid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Connection::set_has_disabledataid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Connection::clear_has_disabledataid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Connection::clear_disabledataid() {
  disabledataid_ = false;
  clear_has_disabledataid();
}
inline bool Connection::disabledataid() const {
  return disabledataid_;
}
inline void Connection::set_disabledataid(bool value) {
  set_has_disabledataid();
  disabledataid_ = value;
}

// optional bool GenerateVHDFile = 13 [default = false];
inline bool Connection::has_generatevhdfile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Connection::set_has_generatevhdfile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Connection::clear_has_generatevhdfile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Connection::clear_generatevhdfile() {
  generatevhdfile_ = false;
  clear_has_generatevhdfile();
}
inline bool Connection::generatevhdfile() const {
  return generatevhdfile_;
}
inline void Connection::set_generatevhdfile(bool value) {
  set_has_generatevhdfile();
  generatevhdfile_ = value;
}

// optional int32 Port1TxStartAddress = 14 [default = 0];
inline bool Connection::has_port1txstartaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Connection::set_has_port1txstartaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Connection::clear_has_port1txstartaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Connection::clear_port1txstartaddress() {
  port1txstartaddress_ = 0;
  clear_has_port1txstartaddress();
}
inline ::google::protobuf::int32 Connection::port1txstartaddress() const {
  return port1txstartaddress_;
}
inline void Connection::set_port1txstartaddress(::google::protobuf::int32 value) {
  set_has_port1txstartaddress();
  port1txstartaddress_ = value;
}

// optional int32 Port1TxWordsQuantity = 15 [default = 479];
inline bool Connection::has_port1txwordsquantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Connection::set_has_port1txwordsquantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Connection::clear_has_port1txwordsquantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Connection::clear_port1txwordsquantity() {
  port1txwordsquantity_ = 479;
  clear_has_port1txwordsquantity();
}
inline ::google::protobuf::int32 Connection::port1txwordsquantity() const {
  return port1txwordsquantity_;
}
inline void Connection::set_port1txwordsquantity(::google::protobuf::int32 value) {
  set_has_port1txwordsquantity();
  port1txwordsquantity_ = value;
}

// optional int32 Port1RxWordsQuantity = 16 [default = 479];
inline bool Connection::has_port1rxwordsquantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Connection::set_has_port1rxwordsquantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Connection::clear_has_port1rxwordsquantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Connection::clear_port1rxwordsquantity() {
  port1rxwordsquantity_ = 479;
  clear_has_port1rxwordsquantity();
}
inline ::google::protobuf::int32 Connection::port1rxwordsquantity() const {
  return port1rxwordsquantity_;
}
inline void Connection::set_port1rxwordsquantity(::google::protobuf::int32 value) {
  set_has_port1rxwordsquantity();
  port1rxwordsquantity_ = value;
}

// optional int32 Port2TxStartAddress = 17 [default = 0];
inline bool Connection::has_port2txstartaddress() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Connection::set_has_port2txstartaddress() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Connection::clear_has_port2txstartaddress() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Connection::clear_port2txstartaddress() {
  port2txstartaddress_ = 0;
  clear_has_port2txstartaddress();
}
inline ::google::protobuf::int32 Connection::port2txstartaddress() const {
  return port2txstartaddress_;
}
inline void Connection::set_port2txstartaddress(::google::protobuf::int32 value) {
  set_has_port2txstartaddress();
  port2txstartaddress_ = value;
}

// optional int32 Port2TxWordsQuantity = 18 [default = 479];
inline bool Connection::has_port2txwordsquantity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Connection::set_has_port2txwordsquantity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Connection::clear_has_port2txwordsquantity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Connection::clear_port2txwordsquantity() {
  port2txwordsquantity_ = 479;
  clear_has_port2txwordsquantity();
}
inline ::google::protobuf::int32 Connection::port2txwordsquantity() const {
  return port2txwordsquantity_;
}
inline void Connection::set_port2txwordsquantity(::google::protobuf::int32 value) {
  set_has_port2txwordsquantity();
  port2txwordsquantity_ = value;
}

// optional int32 Port2RxWordsQuantity = 19 [default = 479];
inline bool Connection::has_port2rxwordsquantity() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Connection::set_has_port2rxwordsquantity() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Connection::clear_has_port2rxwordsquantity() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Connection::clear_port2rxwordsquantity() {
  port2rxwordsquantity_ = 479;
  clear_has_port2rxwordsquantity();
}
inline ::google::protobuf::int32 Connection::port2rxwordsquantity() const {
  return port2rxwordsquantity_;
}
inline void Connection::set_port2rxwordsquantity(::google::protobuf::int32 value) {
  set_has_port2rxwordsquantity();
  port2rxwordsquantity_ = value;
}

// optional .Proto.Uuid uuid = 20;
inline bool Connection::has_uuid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Connection::set_has_uuid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Connection::clear_has_uuid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Connection::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Connection::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Connection::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Connection::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Connection::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// optional bool Port1EnableSerial = 21 [default = false];
inline bool Connection::has_port1enableserial() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Connection::set_has_port1enableserial() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Connection::clear_has_port1enableserial() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Connection::clear_port1enableserial() {
  port1enableserial_ = false;
  clear_has_port1enableserial();
}
inline bool Connection::port1enableserial() const {
  return port1enableserial_;
}
inline void Connection::set_port1enableserial(bool value) {
  set_has_port1enableserial();
  port1enableserial_ = value;
}

// optional int32 Port1SerialMode = 22 [default = 0];
inline bool Connection::has_port1serialmode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Connection::set_has_port1serialmode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Connection::clear_has_port1serialmode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Connection::clear_port1serialmode() {
  port1serialmode_ = 0;
  clear_has_port1serialmode();
}
inline ::google::protobuf::int32 Connection::port1serialmode() const {
  return port1serialmode_;
}
inline void Connection::set_port1serialmode(::google::protobuf::int32 value) {
  set_has_port1serialmode();
  port1serialmode_ = value;
}

// optional bool Port1EnableDuplex = 23 [default = false];
inline bool Connection::has_port1enableduplex() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Connection::set_has_port1enableduplex() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Connection::clear_has_port1enableduplex() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Connection::clear_port1enableduplex() {
  port1enableduplex_ = false;
  clear_has_port1enableduplex();
}
inline bool Connection::port1enableduplex() const {
  return port1enableduplex_;
}
inline void Connection::set_port1enableduplex(bool value) {
  set_has_port1enableduplex();
  port1enableduplex_ = value;
}

// optional bool Port2EnableSerial = 24 [default = false];
inline bool Connection::has_port2enableserial() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Connection::set_has_port2enableserial() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Connection::clear_has_port2enableserial() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Connection::clear_port2enableserial() {
  port2enableserial_ = false;
  clear_has_port2enableserial();
}
inline bool Connection::port2enableserial() const {
  return port2enableserial_;
}
inline void Connection::set_port2enableserial(bool value) {
  set_has_port2enableserial();
  port2enableserial_ = value;
}

// optional int32 Port2SerialMode = 25 [default = 0];
inline bool Connection::has_port2serialmode() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Connection::set_has_port2serialmode() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Connection::clear_has_port2serialmode() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Connection::clear_port2serialmode() {
  port2serialmode_ = 0;
  clear_has_port2serialmode();
}
inline ::google::protobuf::int32 Connection::port2serialmode() const {
  return port2serialmode_;
}
inline void Connection::set_port2serialmode(::google::protobuf::int32 value) {
  set_has_port2serialmode();
  port2serialmode_ = value;
}

// optional bool Port2EnableDuplex = 26 [default = false];
inline bool Connection::has_port2enableduplex() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Connection::set_has_port2enableduplex() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Connection::clear_has_port2enableduplex() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Connection::clear_port2enableduplex() {
  port2enableduplex_ = false;
  clear_has_port2enableduplex();
}
inline bool Connection::port2enableduplex() const {
  return port2enableduplex_;
}
inline void Connection::set_port2enableduplex(bool value) {
  set_has_port2enableduplex();
  port2enableduplex_ = value;
}

// optional int32 Type = 27 [default = 0];
inline bool Connection::has_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Connection::set_has_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Connection::clear_has_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Connection::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Connection::type() const {
  return type_;
}
inline void Connection::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 ObsoleteMode = 8 [default = 0];
inline bool Connection::has_obsoletemode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Connection::set_has_obsoletemode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Connection::clear_has_obsoletemode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Connection::clear_obsoletemode() {
  obsoletemode_ = 0;
  clear_has_obsoletemode();
}
inline ::google::protobuf::int32 Connection::obsoletemode() const {
  return obsoletemode_;
}
inline void Connection::set_obsoletemode(::google::protobuf::int32 value) {
  set_has_obsoletemode();
  obsoletemode_ = value;
}

// optional int32 ObsoleteSerialMode = 7 [default = 0];
inline bool Connection::has_obsoleteserialmode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Connection::set_has_obsoleteserialmode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Connection::clear_has_obsoleteserialmode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Connection::clear_obsoleteserialmode() {
  obsoleteserialmode_ = 0;
  clear_has_obsoleteserialmode();
}
inline ::google::protobuf::int32 Connection::obsoleteserialmode() const {
  return obsoleteserialmode_;
}
inline void Connection::set_obsoleteserialmode(::google::protobuf::int32 value) {
  set_has_obsoleteserialmode();
  obsoleteserialmode_ = value;
}

// optional bool ObsoleteEnableDuplex = 10 [default = false];
inline bool Connection::has_obsoleteenableduplex() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Connection::set_has_obsoleteenableduplex() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Connection::clear_has_obsoleteenableduplex() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Connection::clear_obsoleteenableduplex() {
  obsoleteenableduplex_ = false;
  clear_has_obsoleteenableduplex();
}
inline bool Connection::obsoleteenableduplex() const {
  return obsoleteenableduplex_;
}
inline void Connection::set_obsoleteenableduplex(bool value) {
  set_has_obsoleteenableduplex();
  obsoleteenableduplex_ = value;
}

// -------------------------------------------------------------------

// SchemaDetailsSet

// repeated .Proto.SchemaDetails schemasDetails = 2;
inline int SchemaDetailsSet::schemasdetails_size() const {
  return schemasdetails_.size();
}
inline void SchemaDetailsSet::clear_schemasdetails() {
  schemasdetails_.Clear();
}
inline const ::Proto::SchemaDetails& SchemaDetailsSet::schemasdetails(int index) const {
  return schemasdetails_.Get(index);
}
inline ::Proto::SchemaDetails* SchemaDetailsSet::mutable_schemasdetails(int index) {
  return schemasdetails_.Mutable(index);
}
inline ::Proto::SchemaDetails* SchemaDetailsSet::add_schemasdetails() {
  return schemasdetails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaDetails >&
SchemaDetailsSet::schemasdetails() const {
  return schemasdetails_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaDetails >*
SchemaDetailsSet::mutable_schemasdetails() {
  return &schemasdetails_;
}

// -------------------------------------------------------------------

// SchemaDetails

// optional int32 version = 2;
inline bool SchemaDetails::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaDetails::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaDetails::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaDetails::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 SchemaDetails::version() const {
  return version_;
}
inline void SchemaDetails::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string schemaId = 4;
inline bool SchemaDetails::has_schemaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaDetails::set_has_schemaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaDetails::clear_has_schemaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaDetails::clear_schemaid() {
  if (schemaid_ != &::google::protobuf::internal::kEmptyString) {
    schemaid_->clear();
  }
  clear_has_schemaid();
}
inline const ::std::string& SchemaDetails::schemaid() const {
  return *schemaid_;
}
inline void SchemaDetails::set_schemaid(const ::std::string& value) {
  set_has_schemaid();
  if (schemaid_ == &::google::protobuf::internal::kEmptyString) {
    schemaid_ = new ::std::string;
  }
  schemaid_->assign(value);
}
inline void SchemaDetails::set_schemaid(const char* value) {
  set_has_schemaid();
  if (schemaid_ == &::google::protobuf::internal::kEmptyString) {
    schemaid_ = new ::std::string;
  }
  schemaid_->assign(value);
}
inline void SchemaDetails::set_schemaid(const char* value, size_t size) {
  set_has_schemaid();
  if (schemaid_ == &::google::protobuf::internal::kEmptyString) {
    schemaid_ = new ::std::string;
  }
  schemaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::mutable_schemaid() {
  set_has_schemaid();
  if (schemaid_ == &::google::protobuf::internal::kEmptyString) {
    schemaid_ = new ::std::string;
  }
  return schemaid_;
}
inline ::std::string* SchemaDetails::release_schemaid() {
  clear_has_schemaid();
  if (schemaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schemaid_;
    schemaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaDetails::set_allocated_schemaid(::std::string* schemaid) {
  if (schemaid_ != &::google::protobuf::internal::kEmptyString) {
    delete schemaid_;
  }
  if (schemaid) {
    set_has_schemaid();
    schemaid_ = schemaid;
  } else {
    clear_has_schemaid();
    schemaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string caption = 5;
inline bool SchemaDetails::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaDetails::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaDetails::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaDetails::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& SchemaDetails::caption() const {
  return *caption_;
}
inline void SchemaDetails::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void SchemaDetails::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void SchemaDetails::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* SchemaDetails::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaDetails::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool excludedfromBuild = 6;
inline bool SchemaDetails::has_excludedfrombuild() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaDetails::set_has_excludedfrombuild() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaDetails::clear_has_excludedfrombuild() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaDetails::clear_excludedfrombuild() {
  excludedfrombuild_ = false;
  clear_has_excludedfrombuild();
}
inline bool SchemaDetails::excludedfrombuild() const {
  return excludedfrombuild_;
}
inline void SchemaDetails::set_excludedfrombuild(bool value) {
  set_has_excludedfrombuild();
  excludedfrombuild_ = value;
}

// optional string equipmentId = 7;
inline bool SchemaDetails::has_equipmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaDetails::set_has_equipmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaDetails::clear_has_equipmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaDetails::clear_equipmentid() {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    equipmentid_->clear();
  }
  clear_has_equipmentid();
}
inline const ::std::string& SchemaDetails::equipmentid() const {
  return *equipmentid_;
}
inline void SchemaDetails::set_equipmentid(const ::std::string& value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void SchemaDetails::set_equipmentid(const char* value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void SchemaDetails::set_equipmentid(const char* value, size_t size) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::mutable_equipmentid() {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  return equipmentid_;
}
inline ::std::string* SchemaDetails::release_equipmentid() {
  clear_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equipmentid_;
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaDetails::set_allocated_equipmentid(::std::string* equipmentid) {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete equipmentid_;
  }
  if (equipmentid) {
    set_has_equipmentid();
    equipmentid_ = equipmentid;
  } else {
    clear_has_equipmentid();
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lmDescriptionFile = 8;
inline bool SchemaDetails::has_lmdescriptionfile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaDetails::set_has_lmdescriptionfile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaDetails::clear_has_lmdescriptionfile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaDetails::clear_lmdescriptionfile() {
  if (lmdescriptionfile_ != &::google::protobuf::internal::kEmptyString) {
    lmdescriptionfile_->clear();
  }
  clear_has_lmdescriptionfile();
}
inline const ::std::string& SchemaDetails::lmdescriptionfile() const {
  return *lmdescriptionfile_;
}
inline void SchemaDetails::set_lmdescriptionfile(const ::std::string& value) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == &::google::protobuf::internal::kEmptyString) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(value);
}
inline void SchemaDetails::set_lmdescriptionfile(const char* value) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == &::google::protobuf::internal::kEmptyString) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(value);
}
inline void SchemaDetails::set_lmdescriptionfile(const char* value, size_t size) {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == &::google::protobuf::internal::kEmptyString) {
    lmdescriptionfile_ = new ::std::string;
  }
  lmdescriptionfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::mutable_lmdescriptionfile() {
  set_has_lmdescriptionfile();
  if (lmdescriptionfile_ == &::google::protobuf::internal::kEmptyString) {
    lmdescriptionfile_ = new ::std::string;
  }
  return lmdescriptionfile_;
}
inline ::std::string* SchemaDetails::release_lmdescriptionfile() {
  clear_has_lmdescriptionfile();
  if (lmdescriptionfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lmdescriptionfile_;
    lmdescriptionfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SchemaDetails::set_allocated_lmdescriptionfile(::std::string* lmdescriptionfile) {
  if (lmdescriptionfile_ != &::google::protobuf::internal::kEmptyString) {
    delete lmdescriptionfile_;
  }
  if (lmdescriptionfile) {
    set_has_lmdescriptionfile();
    lmdescriptionfile_ = lmdescriptionfile;
  } else {
    clear_has_lmdescriptionfile();
    lmdescriptionfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string signalIds = 20;
inline int SchemaDetails::signalids_size() const {
  return signalids_.size();
}
inline void SchemaDetails::clear_signalids() {
  signalids_.Clear();
}
inline const ::std::string& SchemaDetails::signalids(int index) const {
  return signalids_.Get(index);
}
inline ::std::string* SchemaDetails::mutable_signalids(int index) {
  return signalids_.Mutable(index);
}
inline void SchemaDetails::set_signalids(int index, const ::std::string& value) {
  signalids_.Mutable(index)->assign(value);
}
inline void SchemaDetails::set_signalids(int index, const char* value) {
  signalids_.Mutable(index)->assign(value);
}
inline void SchemaDetails::set_signalids(int index, const char* value, size_t size) {
  signalids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::add_signalids() {
  return signalids_.Add();
}
inline void SchemaDetails::add_signalids(const ::std::string& value) {
  signalids_.Add()->assign(value);
}
inline void SchemaDetails::add_signalids(const char* value) {
  signalids_.Add()->assign(value);
}
inline void SchemaDetails::add_signalids(const char* value, size_t size) {
  signalids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SchemaDetails::signalids() const {
  return signalids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SchemaDetails::mutable_signalids() {
  return &signalids_;
}

// repeated string labels = 21;
inline int SchemaDetails::labels_size() const {
  return labels_.size();
}
inline void SchemaDetails::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& SchemaDetails::labels(int index) const {
  return labels_.Get(index);
}
inline ::std::string* SchemaDetails::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline void SchemaDetails::set_labels(int index, const ::std::string& value) {
  labels_.Mutable(index)->assign(value);
}
inline void SchemaDetails::set_labels(int index, const char* value) {
  labels_.Mutable(index)->assign(value);
}
inline void SchemaDetails::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::add_labels() {
  return labels_.Add();
}
inline void SchemaDetails::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
}
inline void SchemaDetails::add_labels(const char* value) {
  labels_.Add()->assign(value);
}
inline void SchemaDetails::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SchemaDetails::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SchemaDetails::mutable_labels() {
  return &labels_;
}

// repeated string connections = 22;
inline int SchemaDetails::connections_size() const {
  return connections_.size();
}
inline void SchemaDetails::clear_connections() {
  connections_.Clear();
}
inline const ::std::string& SchemaDetails::connections(int index) const {
  return connections_.Get(index);
}
inline ::std::string* SchemaDetails::mutable_connections(int index) {
  return connections_.Mutable(index);
}
inline void SchemaDetails::set_connections(int index, const ::std::string& value) {
  connections_.Mutable(index)->assign(value);
}
inline void SchemaDetails::set_connections(int index, const char* value) {
  connections_.Mutable(index)->assign(value);
}
inline void SchemaDetails::set_connections(int index, const char* value, size_t size) {
  connections_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SchemaDetails::add_connections() {
  return connections_.Add();
}
inline void SchemaDetails::add_connections(const ::std::string& value) {
  connections_.Add()->assign(value);
}
inline void SchemaDetails::add_connections(const char* value) {
  connections_.Add()->assign(value);
}
inline void SchemaDetails::add_connections(const char* value, size_t size) {
  connections_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SchemaDetails::connections() const {
  return connections_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SchemaDetails::mutable_connections() {
  return &connections_;
}

// repeated .Proto.Uuid guids = 23;
inline int SchemaDetails::guids_size() const {
  return guids_.size();
}
inline void SchemaDetails::clear_guids() {
  guids_.Clear();
}
inline const ::Proto::Uuid& SchemaDetails::guids(int index) const {
  return guids_.Get(index);
}
inline ::Proto::Uuid* SchemaDetails::mutable_guids(int index) {
  return guids_.Mutable(index);
}
inline ::Proto::Uuid* SchemaDetails::add_guids() {
  return guids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
SchemaDetails::guids() const {
  return guids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
SchemaDetails::mutable_guids() {
  return &guids_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::SchemaUnit>() {
  return ::Proto::SchemaUnit_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::ConnectionDirrection>() {
  return ::Proto::ConnectionDirrection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::FblSignalType>() {
  return ::Proto::FblSignalType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::FblDataFormat>() {
  return ::Proto::FblDataFormat_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_serialization_2eproto__INCLUDED
