// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serialization.proto

#ifndef PROTOBUF_serialization_2eproto__INCLUDED
#define PROTOBUF_serialization_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_serialization_2eproto();
void protobuf_AssignDesc_serialization_2eproto();
void protobuf_ShutdownFile_serialization_2eproto();

class Uuid;
class qvariant;
class wstring;
class FontParam;
class SchemaPoint;
class Envelope;
class EnvelopeSet;
class Configuration;
class AfbElementCollection;
class AfbElementXml;
class FblElement;
class AfbSignal;
class AfbParam;
class Schema;
class LogicSchema;
class SchemaLayer;
class SchemaItem;
class PosRectImpl;
class PosLineImpl;
class PosConnectionImpl;
class SchemaItemRect;
class SchemaItemLine;
class SchemaItemPath;
class FblConnectionPoint;
class FblItem;
class FblItemRect;
class FblItemLine;
class SchemaItemSignal;
class SchemaItemInput;
class SchemaItemOutput;
class SchemaItemLink;
class SchemaItemAfb;
class SchemaItemConst;
class DeviceObject;
class DeviceRoot;
class DeviceSystem;
class DeviceRack;
class DeviceChassis;
class DeviceModule;
class DeviceController;
class DeviceSignal;
class Workstation;
class Software;
class ModuleConfiguration;
class ModuleConfigurationValue;
class Property;
class Address16;
class AppSignal;
class AppSignalState;

enum SchemaUnit {
  Display = 0,
  Millimeter = 1,
  Inch = 2
};
bool SchemaUnit_IsValid(int value);
const SchemaUnit SchemaUnit_MIN = Display;
const SchemaUnit SchemaUnit_MAX = Inch;
const int SchemaUnit_ARRAYSIZE = SchemaUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* SchemaUnit_descriptor();
inline const ::std::string& SchemaUnit_Name(SchemaUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    SchemaUnit_descriptor(), value);
}
inline bool SchemaUnit_Parse(
    const ::std::string& name, SchemaUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SchemaUnit>(
    SchemaUnit_descriptor(), name, value);
}
enum ConnectionDirrection {
  Input = 0,
  Output = 1
};
bool ConnectionDirrection_IsValid(int value);
const ConnectionDirrection ConnectionDirrection_MIN = Input;
const ConnectionDirrection ConnectionDirrection_MAX = Output;
const int ConnectionDirrection_ARRAYSIZE = ConnectionDirrection_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionDirrection_descriptor();
inline const ::std::string& ConnectionDirrection_Name(ConnectionDirrection value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionDirrection_descriptor(), value);
}
inline bool ConnectionDirrection_Parse(
    const ::std::string& name, ConnectionDirrection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionDirrection>(
    ConnectionDirrection_descriptor(), name, value);
}
enum FblSignalType {
  Analog = 0,
  Discrete = 1
};
bool FblSignalType_IsValid(int value);
const FblSignalType FblSignalType_MIN = Analog;
const FblSignalType FblSignalType_MAX = Discrete;
const int FblSignalType_ARRAYSIZE = FblSignalType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FblSignalType_descriptor();
inline const ::std::string& FblSignalType_Name(FblSignalType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FblSignalType_descriptor(), value);
}
inline bool FblSignalType_Parse(
    const ::std::string& name, FblSignalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FblSignalType>(
    FblSignalType_descriptor(), name, value);
}
enum FblDataFormat {
  UnsignedInt = 0,
  SignedInt = 1,
  Float = 2
};
bool FblDataFormat_IsValid(int value);
const FblDataFormat FblDataFormat_MIN = UnsignedInt;
const FblDataFormat FblDataFormat_MAX = Float;
const int FblDataFormat_ARRAYSIZE = FblDataFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* FblDataFormat_descriptor();
inline const ::std::string& FblDataFormat_Name(FblDataFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    FblDataFormat_descriptor(), value);
}
inline bool FblDataFormat_Parse(
    const ::std::string& name, FblDataFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FblDataFormat>(
    FblDataFormat_descriptor(), name, value);
}
// ===================================================================

class Uuid : public ::google::protobuf::Message {
 public:
  Uuid();
  virtual ~Uuid();

  Uuid(const Uuid& from);

  inline Uuid& operator=(const Uuid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uuid& default_instance();

  void Swap(Uuid* other);

  // implements Message ----------------------------------------------

  Uuid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Uuid& from);
  void MergeFrom(const Uuid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:Proto.Uuid)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Uuid* default_instance_;
};
// -------------------------------------------------------------------

class qvariant : public ::google::protobuf::Message {
 public:
  qvariant();
  virtual ~qvariant();

  qvariant(const qvariant& from);

  inline qvariant& operator=(const qvariant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const qvariant& default_instance();

  void Swap(qvariant* other);

  // implements Message ----------------------------------------------

  qvariant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const qvariant& from);
  void MergeFrom(const qvariant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 intValue = 2 [default = 0];
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional uint32 uintValue = 3 [default = 0];
  inline bool has_uintvalue() const;
  inline void clear_uintvalue();
  static const int kUintValueFieldNumber = 3;
  inline ::google::protobuf::uint32 uintvalue() const;
  inline void set_uintvalue(::google::protobuf::uint32 value);

  // optional double doubleValue = 4 [default = 0];
  inline bool has_doublevalue() const;
  inline void clear_doublevalue();
  static const int kDoubleValueFieldNumber = 4;
  inline double doublevalue() const;
  inline void set_doublevalue(double value);

  // optional bool boolValue = 5 [default = false];
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 5;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  // @@protoc_insertion_point(class_scope:Proto.qvariant)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_uintvalue();
  inline void clear_has_uintvalue();
  inline void set_has_doublevalue();
  inline void clear_has_doublevalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 intvalue_;
  double doublevalue_;
  ::google::protobuf::uint32 uintvalue_;
  bool boolvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static qvariant* default_instance_;
};
// -------------------------------------------------------------------

class wstring : public ::google::protobuf::Message {
 public:
  wstring();
  virtual ~wstring();

  wstring(const wstring& from);

  inline wstring& operator=(const wstring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wstring& default_instance();

  void Swap(wstring* other);

  // implements Message ----------------------------------------------

  wstring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wstring& from);
  void MergeFrom(const wstring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:Proto.wstring)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static wstring* default_instance_;
};
// -------------------------------------------------------------------

class FontParam : public ::google::protobuf::Message {
 public:
  FontParam();
  virtual ~FontParam();

  FontParam(const FontParam& from);

  inline FontParam& operator=(const FontParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FontParam& default_instance();

  void Swap(FontParam* other);

  // implements Message ----------------------------------------------

  FontParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FontParam& from);
  void MergeFrom(const FontParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::Proto::wstring& name() const;
  inline ::Proto::wstring* mutable_name();
  inline ::Proto::wstring* release_name();
  inline void set_allocated_name(::Proto::wstring* name);

  // required double size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline double size() const;
  inline void set_size(double value);

  // required bool bold = 3;
  inline bool has_bold() const;
  inline void clear_bold();
  static const int kBoldFieldNumber = 3;
  inline bool bold() const;
  inline void set_bold(bool value);

  // required bool italic = 4;
  inline bool has_italic() const;
  inline void clear_italic();
  static const int kItalicFieldNumber = 4;
  inline bool italic() const;
  inline void set_italic(bool value);

  // @@protoc_insertion_point(class_scope:Proto.FontParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_bold();
  inline void clear_has_bold();
  inline void set_has_italic();
  inline void clear_has_italic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* name_;
  double size_;
  bool bold_;
  bool italic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FontParam* default_instance_;
};
// -------------------------------------------------------------------

class SchemaPoint : public ::google::protobuf::Message {
 public:
  SchemaPoint();
  virtual ~SchemaPoint();

  SchemaPoint(const SchemaPoint& from);

  inline SchemaPoint& operator=(const SchemaPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaPoint& default_instance();

  void Swap(SchemaPoint* other);

  // implements Message ----------------------------------------------

  SchemaPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaPoint& from);
  void MergeFrom(const SchemaPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaPoint* default_instance_;
};
// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 classnamehash = 1;
  inline bool has_classnamehash() const;
  inline void clear_classnamehash();
  static const int kClassnamehashFieldNumber = 1;
  inline ::google::protobuf::uint32 classnamehash() const;
  inline void set_classnamehash(::google::protobuf::uint32 value);

  // optional .Proto.SchemaItem schemaitem = 6;
  inline bool has_schemaitem() const;
  inline void clear_schemaitem();
  static const int kSchemaitemFieldNumber = 6;
  inline const ::Proto::SchemaItem& schemaitem() const;
  inline ::Proto::SchemaItem* mutable_schemaitem();
  inline ::Proto::SchemaItem* release_schemaitem();
  inline void set_allocated_schemaitem(::Proto::SchemaItem* schemaitem);

  // optional .Proto.DeviceObject deviceobject = 7;
  inline bool has_deviceobject() const;
  inline void clear_deviceobject();
  static const int kDeviceobjectFieldNumber = 7;
  inline const ::Proto::DeviceObject& deviceobject() const;
  inline ::Proto::DeviceObject* mutable_deviceobject();
  inline ::Proto::DeviceObject* release_deviceobject();
  inline void set_allocated_deviceobject(::Proto::DeviceObject* deviceobject);

  // optional .Proto.Schema schema = 100;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 100;
  inline const ::Proto::Schema& schema() const;
  inline ::Proto::Schema* mutable_schema();
  inline ::Proto::Schema* release_schema();
  inline void set_allocated_schema(::Proto::Schema* schema);

  // optional .Proto.SchemaLayer schemalayer = 101;
  inline bool has_schemalayer() const;
  inline void clear_schemalayer();
  static const int kSchemalayerFieldNumber = 101;
  inline const ::Proto::SchemaLayer& schemalayer() const;
  inline ::Proto::SchemaLayer* mutable_schemalayer();
  inline ::Proto::SchemaLayer* release_schemalayer();
  inline void set_allocated_schemalayer(::Proto::SchemaLayer* schemalayer);

  // optional .Proto.FblElement fblelement = 102;
  inline bool has_fblelement() const;
  inline void clear_fblelement();
  static const int kFblelementFieldNumber = 102;
  inline const ::Proto::FblElement& fblelement() const;
  inline ::Proto::FblElement* mutable_fblelement();
  inline ::Proto::FblElement* release_fblelement();
  inline void set_allocated_fblelement(::Proto::FblElement* fblelement);

  // optional .Proto.Configuration configuration = 103;
  inline bool has_configuration() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 103;
  inline const ::Proto::Configuration& configuration() const;
  inline ::Proto::Configuration* mutable_configuration();
  inline ::Proto::Configuration* release_configuration();
  inline void set_allocated_configuration(::Proto::Configuration* configuration);

  // @@protoc_insertion_point(class_scope:Proto.Envelope)
 private:
  inline void set_has_classnamehash();
  inline void clear_has_classnamehash();
  inline void set_has_schemaitem();
  inline void clear_has_schemaitem();
  inline void set_has_deviceobject();
  inline void clear_has_deviceobject();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_schemalayer();
  inline void clear_has_schemalayer();
  inline void set_has_fblelement();
  inline void clear_has_fblelement();
  inline void set_has_configuration();
  inline void clear_has_configuration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::SchemaItem* schemaitem_;
  ::Proto::DeviceObject* deviceobject_;
  ::Proto::Schema* schema_;
  ::Proto::SchemaLayer* schemalayer_;
  ::Proto::FblElement* fblelement_;
  ::Proto::Configuration* configuration_;
  ::google::protobuf::uint32 classnamehash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class EnvelopeSet : public ::google::protobuf::Message {
 public:
  EnvelopeSet();
  virtual ~EnvelopeSet();

  EnvelopeSet(const EnvelopeSet& from);

  inline EnvelopeSet& operator=(const EnvelopeSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnvelopeSet& default_instance();

  void Swap(EnvelopeSet* other);

  // implements Message ----------------------------------------------

  EnvelopeSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnvelopeSet& from);
  void MergeFrom(const EnvelopeSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.Envelope schemaItems = 1;
  inline int schemaitems_size() const;
  inline void clear_schemaitems();
  static const int kSchemaItemsFieldNumber = 1;
  inline const ::Proto::Envelope& schemaitems(int index) const;
  inline ::Proto::Envelope* mutable_schemaitems(int index);
  inline ::Proto::Envelope* add_schemaitems();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      schemaitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_schemaitems();

  // @@protoc_insertion_point(class_scope:Proto.EnvelopeSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > schemaitems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static EnvelopeSet* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.wstring variables = 4;
  inline bool has_variables() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 4;
  inline const ::Proto::wstring& variables() const;
  inline ::Proto::wstring* mutable_variables();
  inline ::Proto::wstring* release_variables();
  inline void set_allocated_variables(::Proto::wstring* variables);

  // required .Proto.wstring globals = 5;
  inline bool has_globals() const;
  inline void clear_globals();
  static const int kGlobalsFieldNumber = 5;
  inline const ::Proto::wstring& globals() const;
  inline ::Proto::wstring* mutable_globals();
  inline ::Proto::wstring* release_globals();
  inline void set_allocated_globals(::Proto::wstring* globals);

  // repeated .Proto.Uuid schemasIDs = 100;
  inline int schemasids_size() const;
  inline void clear_schemasids();
  static const int kSchemasIDsFieldNumber = 100;
  inline const ::Proto::Uuid& schemasids(int index) const;
  inline ::Proto::Uuid* mutable_schemasids(int index);
  inline ::Proto::Uuid* add_schemasids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
      schemasids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
      mutable_schemasids();

  // repeated .Proto.Envelope schemas = 101;
  inline int schemas_size() const;
  inline void clear_schemas();
  static const int kSchemasFieldNumber = 101;
  inline const ::Proto::Envelope& schemas(int index) const;
  inline ::Proto::Envelope* mutable_schemas(int index);
  inline ::Proto::Envelope* add_schemas();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      schemas() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_schemas();

  // @@protoc_insertion_point(class_scope:Proto.Configuration)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_variables();
  inline void clear_has_variables();
  inline void set_has_globals();
  inline void clear_has_globals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::Proto::wstring* variables_;
  ::Proto::wstring* globals_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Uuid > schemasids_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > schemas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class AfbElementCollection : public ::google::protobuf::Message {
 public:
  AfbElementCollection();
  virtual ~AfbElementCollection();

  AfbElementCollection(const AfbElementCollection& from);

  inline AfbElementCollection& operator=(const AfbElementCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbElementCollection& default_instance();

  void Swap(AfbElementCollection* other);

  // implements Message ----------------------------------------------

  AfbElementCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbElementCollection& from);
  void MergeFrom(const AfbElementCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.AfbElementXml elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Proto::AfbElementXml& elements(int index) const;
  inline ::Proto::AfbElementXml* mutable_elements(int index);
  inline ::Proto::AfbElementXml* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Proto.AfbElementCollection)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml > elements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbElementCollection* default_instance_;
};
// -------------------------------------------------------------------

class AfbElementXml : public ::google::protobuf::Message {
 public:
  AfbElementXml();
  virtual ~AfbElementXml();

  AfbElementXml(const AfbElementXml& from);

  inline AfbElementXml& operator=(const AfbElementXml& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbElementXml& default_instance();

  void Swap(AfbElementXml* other);

  // implements Message ----------------------------------------------

  AfbElementXml* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbElementXml& from);
  void MergeFrom(const AfbElementXml& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Proto.AfbElementXml)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbElementXml* default_instance_;
};
// -------------------------------------------------------------------

class FblElement : public ::google::protobuf::Message {
 public:
  FblElement();
  virtual ~FblElement();

  FblElement(const FblElement& from);

  inline FblElement& operator=(const FblElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblElement& default_instance();

  void Swap(FblElement* other);

  // implements Message ----------------------------------------------

  FblElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblElement& from);
  void MergeFrom(const FblElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required uint32 opcode = 4;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 4;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);

  // optional bool hasRam = 5 [default = false];
  inline bool has_hasram() const;
  inline void clear_hasram();
  static const int kHasRamFieldNumber = 5;
  inline bool hasram() const;
  inline void set_hasram(bool value);

  // optional bool requiredStart = 6 [default = true];
  inline bool has_requiredstart() const;
  inline void clear_requiredstart();
  static const int kRequiredStartFieldNumber = 6;
  inline bool requiredstart() const;
  inline void set_requiredstart(bool value);

  // repeated .Proto.AfbSignal inputs = 11;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 11;
  inline const ::Proto::AfbSignal& inputs(int index) const;
  inline ::Proto::AfbSignal* mutable_inputs(int index);
  inline ::Proto::AfbSignal* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
      mutable_inputs();

  // repeated .Proto.AfbSignal outputs = 12;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 12;
  inline const ::Proto::AfbSignal& outputs(int index) const;
  inline ::Proto::AfbSignal* mutable_outputs(int index);
  inline ::Proto::AfbSignal* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
      mutable_outputs();

  // repeated .Proto.AfbParam params = 13;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 13;
  inline const ::Proto::AfbParam& params(int index) const;
  inline ::Proto::AfbParam* mutable_params(int index);
  inline ::Proto::AfbParam* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
      mutable_params();

  // optional .Proto.wstring description = 14;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 14;
  inline const ::Proto::wstring& description() const;
  inline ::Proto::wstring* mutable_description();
  inline ::Proto::wstring* release_description();
  inline void set_allocated_description(::Proto::wstring* description);

  // @@protoc_insertion_point(class_scope:Proto.FblElement)
 private:
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_hasram();
  inline void clear_has_hasram();
  inline void set_has_requiredstart();
  inline void clear_has_requiredstart();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::google::protobuf::uint32 opcode_;
  bool hasram_;
  bool requiredstart_;
  ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal > inputs_;
  ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal > outputs_;
  ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam > params_;
  ::Proto::wstring* description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblElement* default_instance_;
};
// -------------------------------------------------------------------

class AfbSignal : public ::google::protobuf::Message {
 public:
  AfbSignal();
  virtual ~AfbSignal();

  AfbSignal(const AfbSignal& from);

  inline AfbSignal& operator=(const AfbSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbSignal& default_instance();

  void Swap(AfbSignal* other);

  // implements Message ----------------------------------------------

  AfbSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbSignal& from);
  void MergeFrom(const AfbSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.FblSignalType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Proto::FblSignalType type() const;
  inline void set_type(::Proto::FblSignalType value);

  // optional int32 operandIndex = 3 [default = 0];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 3;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional int32 size = 4 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional .Proto.wstring opName = 5;
  inline bool has_opname() const;
  inline void clear_opname();
  static const int kOpNameFieldNumber = 5;
  inline const ::Proto::wstring& opname() const;
  inline ::Proto::wstring* mutable_opname();
  inline ::Proto::wstring* release_opname();
  inline void set_allocated_opname(::Proto::wstring* opname);

  // optional .Proto.FblDataFormat dataFormat = 6;
  inline bool has_dataformat() const;
  inline void clear_dataformat();
  static const int kDataFormatFieldNumber = 6;
  inline ::Proto::FblDataFormat dataformat() const;
  inline void set_dataformat(::Proto::FblDataFormat value);

  // @@protoc_insertion_point(class_scope:Proto.AfbSignal)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_opname();
  inline void clear_has_opname();
  inline void set_has_dataformat();
  inline void clear_has_dataformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* caption_;
  int type_;
  ::google::protobuf::int32 operandindex_;
  ::Proto::wstring* opname_;
  ::google::protobuf::int32 size_;
  int dataformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbSignal* default_instance_;
};
// -------------------------------------------------------------------

class AfbParam : public ::google::protobuf::Message {
 public:
  AfbParam();
  virtual ~AfbParam();

  AfbParam(const AfbParam& from);

  inline AfbParam& operator=(const AfbParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbParam& default_instance();

  void Swap(AfbParam* other);

  // implements Message ----------------------------------------------

  AfbParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbParam& from);
  void MergeFrom(const AfbParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required bool visible = 7;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 7;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional int32 operandIndex = 8 [default = 0];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 8;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional int32 size = 9 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional bool instantiator = 10 [default = false];
  inline bool has_instantiator() const;
  inline void clear_instantiator();
  static const int kInstantiatorFieldNumber = 10;
  inline bool instantiator() const;
  inline void set_instantiator(bool value);

  // optional bool user = 11 [default = false];
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 11;
  inline bool user() const;
  inline void set_user(bool value);

  // optional .Proto.wstring changedScript = 12;
  inline bool has_changedscript() const;
  inline void clear_changedscript();
  static const int kChangedScriptFieldNumber = 12;
  inline const ::Proto::wstring& changedscript() const;
  inline ::Proto::wstring* mutable_changedscript();
  inline ::Proto::wstring* release_changedscript();
  inline void set_allocated_changedscript(::Proto::wstring* changedscript);

  // optional .Proto.qvariant value = 13;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 13;
  inline const ::Proto::qvariant& value() const;
  inline ::Proto::qvariant* mutable_value();
  inline ::Proto::qvariant* release_value();
  inline void set_allocated_value(::Proto::qvariant* value);

  // optional .Proto.qvariant defaultvalue = 14;
  inline bool has_defaultvalue() const;
  inline void clear_defaultvalue();
  static const int kDefaultvalueFieldNumber = 14;
  inline const ::Proto::qvariant& defaultvalue() const;
  inline ::Proto::qvariant* mutable_defaultvalue();
  inline ::Proto::qvariant* release_defaultvalue();
  inline void set_allocated_defaultvalue(::Proto::qvariant* defaultvalue);

  // optional .Proto.qvariant lowlimit = 15;
  inline bool has_lowlimit() const;
  inline void clear_lowlimit();
  static const int kLowlimitFieldNumber = 15;
  inline const ::Proto::qvariant& lowlimit() const;
  inline ::Proto::qvariant* mutable_lowlimit();
  inline ::Proto::qvariant* release_lowlimit();
  inline void set_allocated_lowlimit(::Proto::qvariant* lowlimit);

  // optional .Proto.qvariant highlimit = 16;
  inline bool has_highlimit() const;
  inline void clear_highlimit();
  static const int kHighlimitFieldNumber = 16;
  inline const ::Proto::qvariant& highlimit() const;
  inline ::Proto::qvariant* mutable_highlimit();
  inline ::Proto::qvariant* release_highlimit();
  inline void set_allocated_highlimit(::Proto::qvariant* highlimit);

  // optional .Proto.wstring opName = 17;
  inline bool has_opname() const;
  inline void clear_opname();
  static const int kOpNameFieldNumber = 17;
  inline const ::Proto::wstring& opname() const;
  inline ::Proto::wstring* mutable_opname();
  inline ::Proto::wstring* release_opname();
  inline void set_allocated_opname(::Proto::wstring* opname);

  // optional .Proto.FblSignalType type = 18;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 18;
  inline ::Proto::FblSignalType type() const;
  inline void set_type(::Proto::FblSignalType value);

  // optional .Proto.FblDataFormat dataFormat = 19;
  inline bool has_dataformat() const;
  inline void clear_dataformat();
  static const int kDataFormatFieldNumber = 19;
  inline ::Proto::FblDataFormat dataformat() const;
  inline void set_dataformat(::Proto::FblDataFormat value);

  // @@protoc_insertion_point(class_scope:Proto.AfbParam)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_instantiator();
  inline void clear_has_instantiator();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_changedscript();
  inline void clear_has_changedscript();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_defaultvalue();
  inline void clear_has_defaultvalue();
  inline void set_has_lowlimit();
  inline void clear_has_lowlimit();
  inline void set_has_highlimit();
  inline void clear_has_highlimit();
  inline void set_has_opname();
  inline void clear_has_opname();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dataformat();
  inline void clear_has_dataformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* caption_;
  ::google::protobuf::int32 operandindex_;
  ::google::protobuf::int32 size_;
  bool visible_;
  bool instantiator_;
  bool user_;
  int type_;
  ::Proto::wstring* changedscript_;
  ::Proto::qvariant* value_;
  ::Proto::qvariant* defaultvalue_;
  ::Proto::qvariant* lowlimit_;
  ::Proto::qvariant* highlimit_;
  ::Proto::wstring* opname_;
  int dataformat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbParam* default_instance_;
};
// -------------------------------------------------------------------

class Schema : public ::google::protobuf::Message {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Schema& default_instance();

  void Swap(Schema* other);

  // implements Message ----------------------------------------------

  Schema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring schemaID = 2;
  inline bool has_schemaid() const;
  inline void clear_schemaid();
  static const int kSchemaIDFieldNumber = 2;
  inline const ::Proto::wstring& schemaid() const;
  inline ::Proto::wstring* mutable_schemaid();
  inline ::Proto::wstring* release_schemaid();
  inline void set_allocated_schemaid(::Proto::wstring* schemaid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required double width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline double width() const;
  inline void set_width(double value);

  // required double height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline double height() const;
  inline void set_height(double value);

  // required .Proto.SchemaUnit unit = 6;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 6;
  inline ::Proto::SchemaUnit unit() const;
  inline void set_unit(::Proto::SchemaUnit value);

  // optional bool excludeFromBuild = 7 [default = false];
  inline bool has_excludefrombuild() const;
  inline void clear_excludefrombuild();
  static const int kExcludeFromBuildFieldNumber = 7;
  inline bool excludefrombuild() const;
  inline void set_excludefrombuild(bool value);

  // repeated .Proto.Envelope layers = 100;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 100;
  inline const ::Proto::Envelope& layers(int index) const;
  inline ::Proto::Envelope* mutable_layers(int index);
  inline ::Proto::Envelope* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_layers();

  // required .Proto.AfbElementCollection afbs = 101;
  inline bool has_afbs() const;
  inline void clear_afbs();
  static const int kAfbsFieldNumber = 101;
  inline const ::Proto::AfbElementCollection& afbs() const;
  inline ::Proto::AfbElementCollection* mutable_afbs();
  inline ::Proto::AfbElementCollection* release_afbs();
  inline void set_allocated_afbs(::Proto::AfbElementCollection* afbs);

  // optional .Proto.LogicSchema logic_schema = 200;
  inline bool has_logic_schema() const;
  inline void clear_logic_schema();
  static const int kLogicSchemaFieldNumber = 200;
  inline const ::Proto::LogicSchema& logic_schema() const;
  inline ::Proto::LogicSchema* mutable_logic_schema();
  inline ::Proto::LogicSchema* release_logic_schema();
  inline void set_allocated_logic_schema(::Proto::LogicSchema* logic_schema);

  // @@protoc_insertion_point(class_scope:Proto.Schema)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_schemaid();
  inline void clear_has_schemaid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_excludefrombuild();
  inline void clear_has_excludefrombuild();
  inline void set_has_afbs();
  inline void clear_has_afbs();
  inline void set_has_logic_schema();
  inline void clear_has_logic_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* schemaid_;
  ::Proto::wstring* caption_;
  double width_;
  double height_;
  int unit_;
  bool excludefrombuild_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > layers_;
  ::Proto::AfbElementCollection* afbs_;
  ::Proto::LogicSchema* logic_schema_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Schema* default_instance_;
};
// -------------------------------------------------------------------

class LogicSchema : public ::google::protobuf::Message {
 public:
  LogicSchema();
  virtual ~LogicSchema();

  LogicSchema(const LogicSchema& from);

  inline LogicSchema& operator=(const LogicSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicSchema& default_instance();

  void Swap(LogicSchema* other);

  // implements Message ----------------------------------------------

  LogicSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicSchema& from);
  void MergeFrom(const LogicSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.wstring equipmentids = 1;
  inline int equipmentids_size() const;
  inline void clear_equipmentids();
  static const int kEquipmentidsFieldNumber = 1;
  inline const ::Proto::wstring& equipmentids(int index) const;
  inline ::Proto::wstring* mutable_equipmentids(int index);
  inline ::Proto::wstring* add_equipmentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
      equipmentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
      mutable_equipmentids();

  // optional int32 counter = 2 [default = 0];
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 2;
  inline ::google::protobuf::int32 counter() const;
  inline void set_counter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.LogicSchema)
 private:
  inline void set_has_counter();
  inline void clear_has_counter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::wstring > equipmentids_;
  ::google::protobuf::int32 counter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static LogicSchema* default_instance_;
};
// -------------------------------------------------------------------

class SchemaLayer : public ::google::protobuf::Message {
 public:
  SchemaLayer();
  virtual ~SchemaLayer();

  SchemaLayer(const SchemaLayer& from);

  inline SchemaLayer& operator=(const SchemaLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaLayer& default_instance();

  void Swap(SchemaLayer* other);

  // implements Message ----------------------------------------------

  SchemaLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaLayer& from);
  void MergeFrom(const SchemaLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::Proto::wstring& name() const;
  inline ::Proto::wstring* mutable_name();
  inline ::Proto::wstring* release_name();
  inline void set_allocated_name(::Proto::wstring* name);

  // required bool compile = 3;
  inline bool has_compile() const;
  inline void clear_compile();
  static const int kCompileFieldNumber = 3;
  inline bool compile() const;
  inline void set_compile(bool value);

  // required bool show = 4;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 4;
  inline bool show() const;
  inline void set_show(bool value);

  // required bool print = 5;
  inline bool has_print() const;
  inline void clear_print();
  static const int kPrintFieldNumber = 5;
  inline bool print() const;
  inline void set_print(bool value);

  // repeated .Proto.Envelope items = 15;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 15;
  inline const ::Proto::Envelope& items(int index) const;
  inline ::Proto::Envelope* mutable_items(int index);
  inline ::Proto::Envelope* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Proto.SchemaLayer)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_compile();
  inline void clear_has_compile();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_print();
  inline void clear_has_print();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* name_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > items_;
  bool compile_;
  bool show_;
  bool print_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaLayer* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItem : public ::google::protobuf::Message {
 public:
  SchemaItem();
  virtual ~SchemaItem();

  SchemaItem(const SchemaItem& from);

  inline SchemaItem& operator=(const SchemaItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItem& default_instance();

  void Swap(SchemaItem* other);

  // implements Message ----------------------------------------------

  SchemaItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItem& from);
  void MergeFrom(const SchemaItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required bool isStatic = 2;
  inline bool has_isstatic() const;
  inline void clear_isstatic();
  static const int kIsStaticFieldNumber = 2;
  inline bool isstatic() const;
  inline void set_isstatic(bool value);

  // required bool isLocked = 3;
  inline bool has_islocked() const;
  inline void clear_islocked();
  static const int kIsLockedFieldNumber = 3;
  inline bool islocked() const;
  inline void set_islocked(bool value);

  // required .Proto.SchemaUnit itemUnit = 4;
  inline bool has_itemunit() const;
  inline void clear_itemunit();
  static const int kItemUnitFieldNumber = 4;
  inline ::Proto::SchemaUnit itemunit() const;
  inline void set_itemunit(::Proto::SchemaUnit value);

  // optional bool acceptClick = 5 [default = false];
  inline bool has_acceptclick() const;
  inline void clear_acceptclick();
  static const int kAcceptClickFieldNumber = 5;
  inline bool acceptclick() const;
  inline void set_acceptclick(bool value);

  // optional .Proto.wstring clickScript = 6;
  inline bool has_clickscript() const;
  inline void clear_clickscript();
  static const int kClickScriptFieldNumber = 6;
  inline const ::Proto::wstring& clickscript() const;
  inline ::Proto::wstring* mutable_clickscript();
  inline ::Proto::wstring* release_clickscript();
  inline void set_allocated_clickscript(::Proto::wstring* clickscript);

  // optional .Proto.PosRectImpl PosRectImpl = 10;
  inline bool has_posrectimpl() const;
  inline void clear_posrectimpl();
  static const int kPosRectImplFieldNumber = 10;
  inline const ::Proto::PosRectImpl& posrectimpl() const;
  inline ::Proto::PosRectImpl* mutable_posrectimpl();
  inline ::Proto::PosRectImpl* release_posrectimpl();
  inline void set_allocated_posrectimpl(::Proto::PosRectImpl* posrectimpl);

  // optional .Proto.PosLineImpl PosLineImpl = 11;
  inline bool has_poslineimpl() const;
  inline void clear_poslineimpl();
  static const int kPosLineImplFieldNumber = 11;
  inline const ::Proto::PosLineImpl& poslineimpl() const;
  inline ::Proto::PosLineImpl* mutable_poslineimpl();
  inline ::Proto::PosLineImpl* release_poslineimpl();
  inline void set_allocated_poslineimpl(::Proto::PosLineImpl* poslineimpl);

  // optional .Proto.PosConnectionImpl PosConnectionImpl = 12;
  inline bool has_posconnectionimpl() const;
  inline void clear_posconnectionimpl();
  static const int kPosConnectionImplFieldNumber = 12;
  inline const ::Proto::PosConnectionImpl& posconnectionimpl() const;
  inline ::Proto::PosConnectionImpl* mutable_posconnectionimpl();
  inline ::Proto::PosConnectionImpl* release_posconnectionimpl();
  inline void set_allocated_posconnectionimpl(::Proto::PosConnectionImpl* posconnectionimpl);

  // optional .Proto.FblItem FblItem = 106;
  inline bool has_fblitem() const;
  inline void clear_fblitem();
  static const int kFblItemFieldNumber = 106;
  inline const ::Proto::FblItem& fblitem() const;
  inline ::Proto::FblItem* mutable_fblitem();
  inline ::Proto::FblItem* release_fblitem();
  inline void set_allocated_fblitem(::Proto::FblItem* fblitem);

  // optional .Proto.FblItemRect FblItemRect = 107;
  inline bool has_fblitemrect() const;
  inline void clear_fblitemrect();
  static const int kFblItemRectFieldNumber = 107;
  inline const ::Proto::FblItemRect& fblitemrect() const;
  inline ::Proto::FblItemRect* mutable_fblitemrect();
  inline ::Proto::FblItemRect* release_fblitemrect();
  inline void set_allocated_fblitemrect(::Proto::FblItemRect* fblitemrect);

  // optional .Proto.FblItemLine FblItemLine = 108;
  inline bool has_fblitemline() const;
  inline void clear_fblitemline();
  static const int kFblItemLineFieldNumber = 108;
  inline const ::Proto::FblItemLine& fblitemline() const;
  inline ::Proto::FblItemLine* mutable_fblitemline();
  inline ::Proto::FblItemLine* release_fblitemline();
  inline void set_allocated_fblitemline(::Proto::FblItemLine* fblitemline);

  // optional .Proto.SchemaItemRect Rect = 116;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 116;
  inline const ::Proto::SchemaItemRect& rect() const;
  inline ::Proto::SchemaItemRect* mutable_rect();
  inline ::Proto::SchemaItemRect* release_rect();
  inline void set_allocated_rect(::Proto::SchemaItemRect* rect);

  // optional .Proto.SchemaItemLine Line = 117;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 117;
  inline const ::Proto::SchemaItemLine& line() const;
  inline ::Proto::SchemaItemLine* mutable_line();
  inline ::Proto::SchemaItemLine* release_line();
  inline void set_allocated_line(::Proto::SchemaItemLine* line);

  // optional .Proto.SchemaItemPath Path = 118;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 118;
  inline const ::Proto::SchemaItemPath& path() const;
  inline ::Proto::SchemaItemPath* mutable_path();
  inline ::Proto::SchemaItemPath* release_path();
  inline void set_allocated_path(::Proto::SchemaItemPath* path);

  // optional .Proto.SchemaItemSignal Signal = 124;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 124;
  inline const ::Proto::SchemaItemSignal& signal() const;
  inline ::Proto::SchemaItemSignal* mutable_signal();
  inline ::Proto::SchemaItemSignal* release_signal();
  inline void set_allocated_signal(::Proto::SchemaItemSignal* signal);

  // optional .Proto.SchemaItemInput InputSignal = 125;
  inline bool has_inputsignal() const;
  inline void clear_inputsignal();
  static const int kInputSignalFieldNumber = 125;
  inline const ::Proto::SchemaItemInput& inputsignal() const;
  inline ::Proto::SchemaItemInput* mutable_inputsignal();
  inline ::Proto::SchemaItemInput* release_inputsignal();
  inline void set_allocated_inputsignal(::Proto::SchemaItemInput* inputsignal);

  // optional .Proto.SchemaItemOutput OutputSignal = 126;
  inline bool has_outputsignal() const;
  inline void clear_outputsignal();
  static const int kOutputSignalFieldNumber = 126;
  inline const ::Proto::SchemaItemOutput& outputsignal() const;
  inline ::Proto::SchemaItemOutput* mutable_outputsignal();
  inline ::Proto::SchemaItemOutput* release_outputsignal();
  inline void set_allocated_outputsignal(::Proto::SchemaItemOutput* outputsignal);

  // optional .Proto.SchemaItemLink Link = 127;
  inline bool has_link() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 127;
  inline const ::Proto::SchemaItemLink& link() const;
  inline ::Proto::SchemaItemLink* mutable_link();
  inline ::Proto::SchemaItemLink* release_link();
  inline void set_allocated_link(::Proto::SchemaItemLink* link);

  // optional .Proto.SchemaItemAfb Afb = 128;
  inline bool has_afb() const;
  inline void clear_afb();
  static const int kAfbFieldNumber = 128;
  inline const ::Proto::SchemaItemAfb& afb() const;
  inline ::Proto::SchemaItemAfb* mutable_afb();
  inline ::Proto::SchemaItemAfb* release_afb();
  inline void set_allocated_afb(::Proto::SchemaItemAfb* afb);

  // optional .Proto.SchemaItemConst ConstItem = 129;
  inline bool has_constitem() const;
  inline void clear_constitem();
  static const int kConstItemFieldNumber = 129;
  inline const ::Proto::SchemaItemConst& constitem() const;
  inline ::Proto::SchemaItemConst* mutable_constitem();
  inline ::Proto::SchemaItemConst* release_constitem();
  inline void set_allocated_constitem(::Proto::SchemaItemConst* constitem);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItem)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_isstatic();
  inline void clear_has_isstatic();
  inline void set_has_islocked();
  inline void clear_has_islocked();
  inline void set_has_itemunit();
  inline void clear_has_itemunit();
  inline void set_has_acceptclick();
  inline void clear_has_acceptclick();
  inline void set_has_clickscript();
  inline void clear_has_clickscript();
  inline void set_has_posrectimpl();
  inline void clear_has_posrectimpl();
  inline void set_has_poslineimpl();
  inline void clear_has_poslineimpl();
  inline void set_has_posconnectionimpl();
  inline void clear_has_posconnectionimpl();
  inline void set_has_fblitem();
  inline void clear_has_fblitem();
  inline void set_has_fblitemrect();
  inline void clear_has_fblitemrect();
  inline void set_has_fblitemline();
  inline void clear_has_fblitemline();
  inline void set_has_rect();
  inline void clear_has_rect();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_inputsignal();
  inline void clear_has_inputsignal();
  inline void set_has_outputsignal();
  inline void clear_has_outputsignal();
  inline void set_has_link();
  inline void clear_has_link();
  inline void set_has_afb();
  inline void clear_has_afb();
  inline void set_has_constitem();
  inline void clear_has_constitem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  bool isstatic_;
  bool islocked_;
  bool acceptclick_;
  int itemunit_;
  ::Proto::wstring* clickscript_;
  ::Proto::PosRectImpl* posrectimpl_;
  ::Proto::PosLineImpl* poslineimpl_;
  ::Proto::PosConnectionImpl* posconnectionimpl_;
  ::Proto::FblItem* fblitem_;
  ::Proto::FblItemRect* fblitemrect_;
  ::Proto::FblItemLine* fblitemline_;
  ::Proto::SchemaItemRect* rect_;
  ::Proto::SchemaItemLine* line_;
  ::Proto::SchemaItemPath* path_;
  ::Proto::SchemaItemSignal* signal_;
  ::Proto::SchemaItemInput* inputsignal_;
  ::Proto::SchemaItemOutput* outputsignal_;
  ::Proto::SchemaItemLink* link_;
  ::Proto::SchemaItemAfb* afb_;
  ::Proto::SchemaItemConst* constitem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItem* default_instance_;
};
// -------------------------------------------------------------------

class PosRectImpl : public ::google::protobuf::Message {
 public:
  PosRectImpl();
  virtual ~PosRectImpl();

  PosRectImpl(const PosRectImpl& from);

  inline PosRectImpl& operator=(const PosRectImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosRectImpl& default_instance();

  void Swap(PosRectImpl* other);

  // implements Message ----------------------------------------------

  PosRectImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosRectImpl& from);
  void MergeFrom(const PosRectImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double leftDocPt = 1;
  inline bool has_leftdocpt() const;
  inline void clear_leftdocpt();
  static const int kLeftDocPtFieldNumber = 1;
  inline double leftdocpt() const;
  inline void set_leftdocpt(double value);

  // required double topDocPt = 2;
  inline bool has_topdocpt() const;
  inline void clear_topdocpt();
  static const int kTopDocPtFieldNumber = 2;
  inline double topdocpt() const;
  inline void set_topdocpt(double value);

  // required double widthDocPt = 3;
  inline bool has_widthdocpt() const;
  inline void clear_widthdocpt();
  static const int kWidthDocPtFieldNumber = 3;
  inline double widthdocpt() const;
  inline void set_widthdocpt(double value);

  // required double heightDocPt = 4;
  inline bool has_heightdocpt() const;
  inline void clear_heightdocpt();
  static const int kHeightDocPtFieldNumber = 4;
  inline double heightdocpt() const;
  inline void set_heightdocpt(double value);

  // @@protoc_insertion_point(class_scope:Proto.PosRectImpl)
 private:
  inline void set_has_leftdocpt();
  inline void clear_has_leftdocpt();
  inline void set_has_topdocpt();
  inline void clear_has_topdocpt();
  inline void set_has_widthdocpt();
  inline void clear_has_widthdocpt();
  inline void set_has_heightdocpt();
  inline void clear_has_heightdocpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double leftdocpt_;
  double topdocpt_;
  double widthdocpt_;
  double heightdocpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosRectImpl* default_instance_;
};
// -------------------------------------------------------------------

class PosLineImpl : public ::google::protobuf::Message {
 public:
  PosLineImpl();
  virtual ~PosLineImpl();

  PosLineImpl(const PosLineImpl& from);

  inline PosLineImpl& operator=(const PosLineImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosLineImpl& default_instance();

  void Swap(PosLineImpl* other);

  // implements Message ----------------------------------------------

  PosLineImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosLineImpl& from);
  void MergeFrom(const PosLineImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double startXDocPt = 1;
  inline bool has_startxdocpt() const;
  inline void clear_startxdocpt();
  static const int kStartXDocPtFieldNumber = 1;
  inline double startxdocpt() const;
  inline void set_startxdocpt(double value);

  // required double startYDocPt = 2;
  inline bool has_startydocpt() const;
  inline void clear_startydocpt();
  static const int kStartYDocPtFieldNumber = 2;
  inline double startydocpt() const;
  inline void set_startydocpt(double value);

  // required double endXDocPt = 3;
  inline bool has_endxdocpt() const;
  inline void clear_endxdocpt();
  static const int kEndXDocPtFieldNumber = 3;
  inline double endxdocpt() const;
  inline void set_endxdocpt(double value);

  // required double endYDocPt = 4;
  inline bool has_endydocpt() const;
  inline void clear_endydocpt();
  static const int kEndYDocPtFieldNumber = 4;
  inline double endydocpt() const;
  inline void set_endydocpt(double value);

  // @@protoc_insertion_point(class_scope:Proto.PosLineImpl)
 private:
  inline void set_has_startxdocpt();
  inline void clear_has_startxdocpt();
  inline void set_has_startydocpt();
  inline void clear_has_startydocpt();
  inline void set_has_endxdocpt();
  inline void clear_has_endxdocpt();
  inline void set_has_endydocpt();
  inline void clear_has_endydocpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double startxdocpt_;
  double startydocpt_;
  double endxdocpt_;
  double endydocpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosLineImpl* default_instance_;
};
// -------------------------------------------------------------------

class PosConnectionImpl : public ::google::protobuf::Message {
 public:
  PosConnectionImpl();
  virtual ~PosConnectionImpl();

  PosConnectionImpl(const PosConnectionImpl& from);

  inline PosConnectionImpl& operator=(const PosConnectionImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosConnectionImpl& default_instance();

  void Swap(PosConnectionImpl* other);

  // implements Message ----------------------------------------------

  PosConnectionImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosConnectionImpl& from);
  void MergeFrom(const PosConnectionImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.SchemaPoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::Proto::SchemaPoint& points(int index) const;
  inline ::Proto::SchemaPoint* mutable_points(int index);
  inline ::Proto::SchemaPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Proto.PosConnectionImpl)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosConnectionImpl* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemRect : public ::google::protobuf::Message {
 public:
  SchemaItemRect();
  virtual ~SchemaItemRect();

  SchemaItemRect(const SchemaItemRect& from);

  inline SchemaItemRect& operator=(const SchemaItemRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemRect& default_instance();

  void Swap(SchemaItemRect* other);

  // implements Message ----------------------------------------------

  SchemaItemRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemRect& from);
  void MergeFrom(const SchemaItemRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // required uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // required .Proto.wstring text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::Proto::wstring& text() const;
  inline ::Proto::wstring* mutable_text();
  inline ::Proto::wstring* release_text();
  inline void set_allocated_text(::Proto::wstring* text);

  // required uint32 textColor = 5;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 5;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // required .Proto.FontParam font = 6;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 6;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // required bool fill = 7;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 7;
  inline bool fill() const;
  inline void set_fill(bool value);

  // optional bool drawrect = 8 [default = true];
  inline bool has_drawrect() const;
  inline void clear_drawrect();
  static const int kDrawrectFieldNumber = 8;
  inline bool drawrect() const;
  inline void set_drawrect(bool value);

  // optional int32 horzAlign = 9 [default = 4];
  inline bool has_horzalign() const;
  inline void clear_horzalign();
  static const int kHorzAlignFieldNumber = 9;
  inline ::google::protobuf::int32 horzalign() const;
  inline void set_horzalign(::google::protobuf::int32 value);

  // optional int32 vertAlign = 10 [default = 128];
  inline bool has_vertalign() const;
  inline void clear_vertalign();
  static const int kVertAlignFieldNumber = 10;
  inline ::google::protobuf::int32 vertalign() const;
  inline void set_vertalign(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemRect)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_drawrect();
  inline void clear_has_drawrect();
  inline void set_has_horzalign();
  inline void clear_has_horzalign();
  inline void set_has_vertalign();
  inline void clear_has_vertalign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::Proto::wstring* text_;
  ::Proto::FontParam* font_;
  ::google::protobuf::uint32 textcolor_;
  bool fill_;
  bool drawrect_;
  ::google::protobuf::int32 horzalign_;
  ::google::protobuf::int32 vertalign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemRect* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemLine : public ::google::protobuf::Message {
 public:
  SchemaItemLine();
  virtual ~SchemaItemLine();

  SchemaItemLine(const SchemaItemLine& from);

  inline SchemaItemLine& operator=(const SchemaItemLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemLine& default_instance();

  void Swap(SchemaItemLine* other);

  // implements Message ----------------------------------------------

  SchemaItemLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemLine& from);
  void MergeFrom(const SchemaItemLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemLine)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemLine* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemPath : public ::google::protobuf::Message {
 public:
  SchemaItemPath();
  virtual ~SchemaItemPath();

  SchemaItemPath(const SchemaItemPath& from);

  inline SchemaItemPath& operator=(const SchemaItemPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemPath& default_instance();

  void Swap(SchemaItemPath* other);

  // implements Message ----------------------------------------------

  SchemaItemPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemPath& from);
  void MergeFrom(const SchemaItemPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemPath)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemPath* default_instance_;
};
// -------------------------------------------------------------------

class FblConnectionPoint : public ::google::protobuf::Message {
 public:
  FblConnectionPoint();
  virtual ~FblConnectionPoint();

  FblConnectionPoint(const FblConnectionPoint& from);

  inline FblConnectionPoint& operator=(const FblConnectionPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblConnectionPoint& default_instance();

  void Swap(FblConnectionPoint* other);

  // implements Message ----------------------------------------------

  FblConnectionPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblConnectionPoint& from);
  void MergeFrom(const FblConnectionPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.SchemaPoint point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::Proto::SchemaPoint& point() const;
  inline ::Proto::SchemaPoint* mutable_point();
  inline ::Proto::SchemaPoint* release_point();
  inline void set_allocated_point(::Proto::SchemaPoint* point);

  // optional .Proto.ConnectionDirrection dirrection = 2;
  inline bool has_dirrection() const;
  inline void clear_dirrection();
  static const int kDirrectionFieldNumber = 2;
  inline ::Proto::ConnectionDirrection dirrection() const;
  inline void set_dirrection(::Proto::ConnectionDirrection value);

  // optional .Proto.Uuid uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // optional int32 operandIndex = 4 [default = -1];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 4;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional string caption = 5 [default = ""];
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 5;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // @@protoc_insertion_point(class_scope:Proto.FblConnectionPoint)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_dirrection();
  inline void clear_has_dirrection();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_caption();
  inline void clear_has_caption();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::SchemaPoint* point_;
  ::Proto::Uuid* uuid_;
  int dirrection_;
  ::google::protobuf::int32 operandindex_;
  ::std::string* caption_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblConnectionPoint* default_instance_;
};
// -------------------------------------------------------------------

class FblItem : public ::google::protobuf::Message {
 public:
  FblItem();
  virtual ~FblItem();

  FblItem(const FblItem& from);

  inline FblItem& operator=(const FblItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItem& default_instance();

  void Swap(FblItem* other);

  // implements Message ----------------------------------------------

  FblItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItem& from);
  void MergeFrom(const FblItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.FblConnectionPoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::Proto::FblConnectionPoint& points(int index) const;
  inline ::Proto::FblConnectionPoint* mutable_points(int index);
  inline ::Proto::FblConnectionPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Proto.FblItem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItem* default_instance_;
};
// -------------------------------------------------------------------

class FblItemRect : public ::google::protobuf::Message {
 public:
  FblItemRect();
  virtual ~FblItemRect();

  FblItemRect(const FblItemRect& from);

  inline FblItemRect& operator=(const FblItemRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItemRect& default_instance();

  void Swap(FblItemRect* other);

  // implements Message ----------------------------------------------

  FblItemRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItemRect& from);
  void MergeFrom(const FblItemRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // required uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // required uint32 textColor = 4;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 4;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // required .Proto.FontParam font = 5;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 5;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // @@protoc_insertion_point(class_scope:Proto.FblItemRect)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::Proto::FontParam* font_;
  ::google::protobuf::uint32 textcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItemRect* default_instance_;
};
// -------------------------------------------------------------------

class FblItemLine : public ::google::protobuf::Message {
 public:
  FblItemLine();
  virtual ~FblItemLine();

  FblItemLine(const FblItemLine& from);

  inline FblItemLine& operator=(const FblItemLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItemLine& default_instance();

  void Swap(FblItemLine* other);

  // implements Message ----------------------------------------------

  FblItemLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItemLine& from);
  void MergeFrom(const FblItemLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.FblItemLine)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItemLine* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemSignal : public ::google::protobuf::Message {
 public:
  SchemaItemSignal();
  virtual ~SchemaItemSignal();

  SchemaItemSignal(const SchemaItemSignal& from);

  inline SchemaItemSignal& operator=(const SchemaItemSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemSignal& default_instance();

  void Swap(SchemaItemSignal* other);

  // implements Message ----------------------------------------------

  SchemaItemSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemSignal& from);
  void MergeFrom(const SchemaItemSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.wstring appSignalIDs = 1;
  inline int appsignalids_size() const;
  inline void clear_appsignalids();
  static const int kAppSignalIDsFieldNumber = 1;
  inline const ::Proto::wstring& appsignalids(int index) const;
  inline ::Proto::wstring* mutable_appsignalids(int index);
  inline ::Proto::wstring* add_appsignalids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
      appsignalids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
      mutable_appsignalids();

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemSignal)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::wstring > appsignalids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemSignal* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemInput : public ::google::protobuf::Message {
 public:
  SchemaItemInput();
  virtual ~SchemaItemInput();

  SchemaItemInput(const SchemaItemInput& from);

  inline SchemaItemInput& operator=(const SchemaItemInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemInput& default_instance();

  void Swap(SchemaItemInput* other);

  // implements Message ----------------------------------------------

  SchemaItemInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemInput& from);
  void MergeFrom(const SchemaItemInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemInput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemInput* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemOutput : public ::google::protobuf::Message {
 public:
  SchemaItemOutput();
  virtual ~SchemaItemOutput();

  SchemaItemOutput(const SchemaItemOutput& from);

  inline SchemaItemOutput& operator=(const SchemaItemOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemOutput& default_instance();

  void Swap(SchemaItemOutput* other);

  // implements Message ----------------------------------------------

  SchemaItemOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemOutput& from);
  void MergeFrom(const SchemaItemOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemOutput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemOutput* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemLink : public ::google::protobuf::Message {
 public:
  SchemaItemLink();
  virtual ~SchemaItemLink();

  SchemaItemLink(const SchemaItemLink& from);

  inline SchemaItemLink& operator=(const SchemaItemLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemLink& default_instance();

  void Swap(SchemaItemLink* other);

  // implements Message ----------------------------------------------

  SchemaItemLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemLink& from);
  void MergeFrom(const SchemaItemLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemLink)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemLink* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemAfb : public ::google::protobuf::Message {
 public:
  SchemaItemAfb();
  virtual ~SchemaItemAfb();

  SchemaItemAfb(const SchemaItemAfb& from);

  inline SchemaItemAfb& operator=(const SchemaItemAfb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemAfb& default_instance();

  void Swap(SchemaItemAfb* other);

  // implements Message ----------------------------------------------

  SchemaItemAfb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemAfb& from);
  void MergeFrom(const SchemaItemAfb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.AfbParam params = 2;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::Proto::AfbParam& params(int index) const;
  inline ::Proto::AfbParam* mutable_params(int index);
  inline ::Proto::AfbParam* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
      mutable_params();

  // optional .Proto.wstring afbStrid = 3;
  inline bool has_afbstrid() const;
  inline void clear_afbstrid();
  static const int kAfbStridFieldNumber = 3;
  inline const ::Proto::wstring& afbstrid() const;
  inline ::Proto::wstring* mutable_afbstrid();
  inline ::Proto::wstring* release_afbstrid();
  inline void set_allocated_afbstrid(::Proto::wstring* afbstrid);

  // optional int32 precision = 4 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // optional .Proto.AfbElementXml afbelement = 5;
  inline bool has_afbelement() const;
  inline void clear_afbelement();
  static const int kAfbelementFieldNumber = 5;
  inline const ::Proto::AfbElementXml& afbelement() const;
  inline ::Proto::AfbElementXml* mutable_afbelement();
  inline ::Proto::AfbElementXml* release_afbelement();
  inline void set_allocated_afbelement(::Proto::AfbElementXml* afbelement);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemAfb)
 private:
  inline void set_has_afbstrid();
  inline void clear_has_afbstrid();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_afbelement();
  inline void clear_has_afbelement();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam > params_;
  ::Proto::wstring* afbstrid_;
  ::Proto::AfbElementXml* afbelement_;
  ::google::protobuf::int32 precision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemAfb* default_instance_;
};
// -------------------------------------------------------------------

class SchemaItemConst : public ::google::protobuf::Message {
 public:
  SchemaItemConst();
  virtual ~SchemaItemConst();

  SchemaItemConst(const SchemaItemConst& from);

  inline SchemaItemConst& operator=(const SchemaItemConst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaItemConst& default_instance();

  void Swap(SchemaItemConst* other);

  // implements Message ----------------------------------------------

  SchemaItemConst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemaItemConst& from);
  void MergeFrom(const SchemaItemConst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 intValue = 2 [default = 0];
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional double floatValue = 3 [default = 0];
  inline bool has_floatvalue() const;
  inline void clear_floatvalue();
  static const int kFloatValueFieldNumber = 3;
  inline double floatvalue() const;
  inline void set_floatvalue(double value);

  // optional int32 precision = 4 [default = 2];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemaItemConst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_floatvalue();
  inline void clear_has_floatvalue();
  inline void set_has_precision();
  inline void clear_has_precision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 intvalue_;
  double floatvalue_;
  ::google::protobuf::int32 precision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemaItemConst* default_instance_;
};
// -------------------------------------------------------------------

class DeviceObject : public ::google::protobuf::Message {
 public:
  DeviceObject();
  virtual ~DeviceObject();

  DeviceObject(const DeviceObject& from);

  inline DeviceObject& operator=(const DeviceObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceObject& default_instance();

  void Swap(DeviceObject* other);

  // implements Message ----------------------------------------------

  DeviceObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceObject& from);
  void MergeFrom(const DeviceObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring equipmentId = 2;
  inline bool has_equipmentid() const;
  inline void clear_equipmentid();
  static const int kEquipmentIdFieldNumber = 2;
  inline const ::Proto::wstring& equipmentid() const;
  inline ::Proto::wstring* mutable_equipmentid();
  inline ::Proto::wstring* release_equipmentid();
  inline void set_allocated_equipmentid(::Proto::wstring* equipmentid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // optional .Proto.wstring childRestriction = 4;
  inline bool has_childrestriction() const;
  inline void clear_childrestriction();
  static const int kChildRestrictionFieldNumber = 4;
  inline const ::Proto::wstring& childrestriction() const;
  inline ::Proto::wstring* mutable_childrestriction();
  inline ::Proto::wstring* release_childrestriction();
  inline void set_allocated_childrestriction(::Proto::wstring* childrestriction);

  // optional int32 place = 5 [default = 0];
  inline bool has_place() const;
  inline void clear_place();
  static const int kPlaceFieldNumber = 5;
  inline ::google::protobuf::int32 place() const;
  inline void set_place(::google::protobuf::int32 value);

  // optional string specific_properties_struct = 6;
  inline bool has_specific_properties_struct() const;
  inline void clear_specific_properties_struct();
  static const int kSpecificPropertiesStructFieldNumber = 6;
  inline const ::std::string& specific_properties_struct() const;
  inline void set_specific_properties_struct(const ::std::string& value);
  inline void set_specific_properties_struct(const char* value);
  inline void set_specific_properties_struct(const char* value, size_t size);
  inline ::std::string* mutable_specific_properties_struct();
  inline ::std::string* release_specific_properties_struct();
  inline void set_allocated_specific_properties_struct(::std::string* specific_properties_struct);

  // repeated .Proto.Property properties = 7;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 7;
  inline const ::Proto::Property& properties(int index) const;
  inline ::Proto::Property* mutable_properties(int index);
  inline ::Proto::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Property >*
      mutable_properties();

  // optional bool preset = 32 [default = false];
  inline bool has_preset() const;
  inline void clear_preset();
  static const int kPresetFieldNumber = 32;
  inline bool preset() const;
  inline void set_preset(bool value);

  // optional bool presetRoot = 33 [default = false];
  inline bool has_presetroot() const;
  inline void clear_presetroot();
  static const int kPresetRootFieldNumber = 33;
  inline bool presetroot() const;
  inline void set_presetroot(bool value);

  // optional .Proto.wstring presetName = 34;
  inline bool has_presetname() const;
  inline void clear_presetname();
  static const int kPresetNameFieldNumber = 34;
  inline const ::Proto::wstring& presetname() const;
  inline ::Proto::wstring* mutable_presetname();
  inline ::Proto::wstring* release_presetname();
  inline void set_allocated_presetname(::Proto::wstring* presetname);

  // optional .Proto.Uuid presetObjectUuid = 35;
  inline bool has_presetobjectuuid() const;
  inline void clear_presetobjectuuid();
  static const int kPresetObjectUuidFieldNumber = 35;
  inline const ::Proto::Uuid& presetobjectuuid() const;
  inline ::Proto::Uuid* mutable_presetobjectuuid();
  inline ::Proto::Uuid* release_presetobjectuuid();
  inline void set_allocated_presetobjectuuid(::Proto::Uuid* presetobjectuuid);

  // optional .Proto.DeviceRoot Root = 100;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 100;
  inline const ::Proto::DeviceRoot& root() const;
  inline ::Proto::DeviceRoot* mutable_root();
  inline ::Proto::DeviceRoot* release_root();
  inline void set_allocated_root(::Proto::DeviceRoot* root);

  // optional .Proto.DeviceSystem System = 101;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 101;
  inline const ::Proto::DeviceSystem& system() const;
  inline ::Proto::DeviceSystem* mutable_system();
  inline ::Proto::DeviceSystem* release_system();
  inline void set_allocated_system(::Proto::DeviceSystem* system);

  // optional .Proto.DeviceRack Rack = 102;
  inline bool has_rack() const;
  inline void clear_rack();
  static const int kRackFieldNumber = 102;
  inline const ::Proto::DeviceRack& rack() const;
  inline ::Proto::DeviceRack* mutable_rack();
  inline ::Proto::DeviceRack* release_rack();
  inline void set_allocated_rack(::Proto::DeviceRack* rack);

  // optional .Proto.DeviceChassis Chassis = 103;
  inline bool has_chassis() const;
  inline void clear_chassis();
  static const int kChassisFieldNumber = 103;
  inline const ::Proto::DeviceChassis& chassis() const;
  inline ::Proto::DeviceChassis* mutable_chassis();
  inline ::Proto::DeviceChassis* release_chassis();
  inline void set_allocated_chassis(::Proto::DeviceChassis* chassis);

  // optional .Proto.DeviceModule Module = 104;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 104;
  inline const ::Proto::DeviceModule& module() const;
  inline ::Proto::DeviceModule* mutable_module();
  inline ::Proto::DeviceModule* release_module();
  inline void set_allocated_module(::Proto::DeviceModule* module);

  // optional .Proto.DeviceController Controller = 105;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 105;
  inline const ::Proto::DeviceController& controller() const;
  inline ::Proto::DeviceController* mutable_controller();
  inline ::Proto::DeviceController* release_controller();
  inline void set_allocated_controller(::Proto::DeviceController* controller);

  // optional .Proto.DeviceSignal Signal = 106;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 106;
  inline const ::Proto::DeviceSignal& signal() const;
  inline ::Proto::DeviceSignal* mutable_signal();
  inline ::Proto::DeviceSignal* release_signal();
  inline void set_allocated_signal(::Proto::DeviceSignal* signal);

  // optional .Proto.Workstation Workstation = 107;
  inline bool has_workstation() const;
  inline void clear_workstation();
  static const int kWorkstationFieldNumber = 107;
  inline const ::Proto::Workstation& workstation() const;
  inline ::Proto::Workstation* mutable_workstation();
  inline ::Proto::Workstation* release_workstation();
  inline void set_allocated_workstation(::Proto::Workstation* workstation);

  // optional .Proto.Software Software = 108;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 108;
  inline const ::Proto::Software& software() const;
  inline ::Proto::Software* mutable_software();
  inline ::Proto::Software* release_software();
  inline void set_allocated_software(::Proto::Software* software);

  // @@protoc_insertion_point(class_scope:Proto.DeviceObject)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_equipmentid();
  inline void clear_has_equipmentid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_childrestriction();
  inline void clear_has_childrestriction();
  inline void set_has_place();
  inline void clear_has_place();
  inline void set_has_specific_properties_struct();
  inline void clear_has_specific_properties_struct();
  inline void set_has_preset();
  inline void clear_has_preset();
  inline void set_has_presetroot();
  inline void clear_has_presetroot();
  inline void set_has_presetname();
  inline void clear_has_presetname();
  inline void set_has_presetobjectuuid();
  inline void clear_has_presetobjectuuid();
  inline void set_has_root();
  inline void clear_has_root();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_rack();
  inline void clear_has_rack();
  inline void set_has_chassis();
  inline void clear_has_chassis();
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_workstation();
  inline void clear_has_workstation();
  inline void set_has_software();
  inline void clear_has_software();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* equipmentid_;
  ::Proto::wstring* caption_;
  ::Proto::wstring* childrestriction_;
  ::std::string* specific_properties_struct_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Property > properties_;
  ::google::protobuf::int32 place_;
  bool preset_;
  bool presetroot_;
  ::Proto::wstring* presetname_;
  ::Proto::Uuid* presetobjectuuid_;
  ::Proto::DeviceRoot* root_;
  ::Proto::DeviceSystem* system_;
  ::Proto::DeviceRack* rack_;
  ::Proto::DeviceChassis* chassis_;
  ::Proto::DeviceModule* module_;
  ::Proto::DeviceController* controller_;
  ::Proto::DeviceSignal* signal_;
  ::Proto::Workstation* workstation_;
  ::Proto::Software* software_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceObject* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRoot : public ::google::protobuf::Message {
 public:
  DeviceRoot();
  virtual ~DeviceRoot();

  DeviceRoot(const DeviceRoot& from);

  inline DeviceRoot& operator=(const DeviceRoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceRoot& default_instance();

  void Swap(DeviceRoot* other);

  // implements Message ----------------------------------------------

  DeviceRoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceRoot& from);
  void MergeFrom(const DeviceRoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceRoot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceRoot* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSystem : public ::google::protobuf::Message {
 public:
  DeviceSystem();
  virtual ~DeviceSystem();

  DeviceSystem(const DeviceSystem& from);

  inline DeviceSystem& operator=(const DeviceSystem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSystem& default_instance();

  void Swap(DeviceSystem* other);

  // implements Message ----------------------------------------------

  DeviceSystem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSystem& from);
  void MergeFrom(const DeviceSystem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceSystem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceSystem* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRack : public ::google::protobuf::Message {
 public:
  DeviceRack();
  virtual ~DeviceRack();

  DeviceRack(const DeviceRack& from);

  inline DeviceRack& operator=(const DeviceRack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceRack& default_instance();

  void Swap(DeviceRack* other);

  // implements Message ----------------------------------------------

  DeviceRack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceRack& from);
  void MergeFrom(const DeviceRack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceRack)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceRack* default_instance_;
};
// -------------------------------------------------------------------

class DeviceChassis : public ::google::protobuf::Message {
 public:
  DeviceChassis();
  virtual ~DeviceChassis();

  DeviceChassis(const DeviceChassis& from);

  inline DeviceChassis& operator=(const DeviceChassis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceChassis& default_instance();

  void Swap(DeviceChassis* other);

  // implements Message ----------------------------------------------

  DeviceChassis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceChassis& from);
  void MergeFrom(const DeviceChassis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DeviceChassis)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceChassis* default_instance_;
};
// -------------------------------------------------------------------

class DeviceModule : public ::google::protobuf::Message {
 public:
  DeviceModule();
  virtual ~DeviceModule();

  DeviceModule(const DeviceModule& from);

  inline DeviceModule& operator=(const DeviceModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceModule& default_instance();

  void Swap(DeviceModule* other);

  // implements Message ----------------------------------------------

  DeviceModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceModule& from);
  void MergeFrom(const DeviceModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DeviceModule)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceModule* default_instance_;
};
// -------------------------------------------------------------------

class DeviceController : public ::google::protobuf::Message {
 public:
  DeviceController();
  virtual ~DeviceController();

  DeviceController(const DeviceController& from);

  inline DeviceController& operator=(const DeviceController& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceController& default_instance();

  void Swap(DeviceController* other);

  // implements Message ----------------------------------------------

  DeviceController* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceController& from);
  void MergeFrom(const DeviceController& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceController)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceController* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSignal : public ::google::protobuf::Message {
 public:
  DeviceSignal();
  virtual ~DeviceSignal();

  DeviceSignal(const DeviceSignal& from);

  inline DeviceSignal& operator=(const DeviceSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSignal& default_instance();

  void Swap(DeviceSignal* other);

  // implements Message ----------------------------------------------

  DeviceSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSignal& from);
  void MergeFrom(const DeviceSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 obsoletetype = 1 [default = 0];
  inline bool has_obsoletetype() const;
  inline void clear_obsoletetype();
  static const int kObsoletetypeFieldNumber = 1;
  inline ::google::protobuf::int32 obsoletetype() const;
  inline void set_obsoletetype(::google::protobuf::int32 value);

  // optional int32 byteOrder = 2 [default = 0];
  inline bool has_byteorder() const;
  inline void clear_byteorder();
  static const int kByteOrderFieldNumber = 2;
  inline ::google::protobuf::int32 byteorder() const;
  inline void set_byteorder(::google::protobuf::int32 value);

  // optional int32 format = 3 [default = 0];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 3;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);

  // optional int32 size = 4 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int32 validityOffset = 5 [default = 0];
  inline bool has_validityoffset() const;
  inline void clear_validityoffset();
  static const int kValidityOffsetFieldNumber = 5;
  inline ::google::protobuf::int32 validityoffset() const;
  inline void set_validityoffset(::google::protobuf::int32 value);

  // optional int32 validityBit = 6 [default = 0];
  inline bool has_validitybit() const;
  inline void clear_validitybit();
  static const int kValidityBitFieldNumber = 6;
  inline ::google::protobuf::int32 validitybit() const;
  inline void set_validitybit(::google::protobuf::int32 value);

  // optional int32 valueOffset = 7 [default = 0];
  inline bool has_valueoffset() const;
  inline void clear_valueoffset();
  static const int kValueOffsetFieldNumber = 7;
  inline ::google::protobuf::int32 valueoffset() const;
  inline void set_valueoffset(::google::protobuf::int32 value);

  // optional int32 valueBit = 8 [default = 0];
  inline bool has_valuebit() const;
  inline void clear_valuebit();
  static const int kValueBitFieldNumber = 8;
  inline ::google::protobuf::int32 valuebit() const;
  inline void set_valuebit(::google::protobuf::int32 value);

  // optional int32 type = 9 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 function = 10 [default = 0];
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 10;
  inline ::google::protobuf::int32 function() const;
  inline void set_function(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DeviceSignal)
 private:
  inline void set_has_obsoletetype();
  inline void clear_has_obsoletetype();
  inline void set_has_byteorder();
  inline void clear_has_byteorder();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_validityoffset();
  inline void clear_has_validityoffset();
  inline void set_has_validitybit();
  inline void clear_has_validitybit();
  inline void set_has_valueoffset();
  inline void clear_has_valueoffset();
  inline void set_has_valuebit();
  inline void clear_has_valuebit();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_function();
  inline void clear_has_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 obsoletetype_;
  ::google::protobuf::int32 byteorder_;
  ::google::protobuf::int32 format_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 validityoffset_;
  ::google::protobuf::int32 validitybit_;
  ::google::protobuf::int32 valueoffset_;
  ::google::protobuf::int32 valuebit_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 function_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceSignal* default_instance_;
};
// -------------------------------------------------------------------

class Workstation : public ::google::protobuf::Message {
 public:
  Workstation();
  virtual ~Workstation();

  Workstation(const Workstation& from);

  inline Workstation& operator=(const Workstation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Workstation& default_instance();

  void Swap(Workstation* other);

  // implements Message ----------------------------------------------

  Workstation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Workstation& from);
  void MergeFrom(const Workstation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Workstation)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Workstation* default_instance_;
};
// -------------------------------------------------------------------

class Software : public ::google::protobuf::Message {
 public:
  Software();
  virtual ~Software();

  Software(const Software& from);

  inline Software& operator=(const Software& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Software& default_instance();

  void Swap(Software* other);

  // implements Message ----------------------------------------------

  Software* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Software& from);
  void MergeFrom(const Software& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Software)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Software* default_instance_;
};
// -------------------------------------------------------------------

class ModuleConfiguration : public ::google::protobuf::Message {
 public:
  ModuleConfiguration();
  virtual ~ModuleConfiguration();

  ModuleConfiguration(const ModuleConfiguration& from);

  inline ModuleConfiguration& operator=(const ModuleConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleConfiguration& default_instance();

  void Swap(ModuleConfiguration* other);

  // implements Message ----------------------------------------------

  ModuleConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleConfiguration& from);
  void MergeFrom(const ModuleConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string struct_description = 1;
  inline bool has_struct_description() const;
  inline void clear_struct_description();
  static const int kStructDescriptionFieldNumber = 1;
  inline const ::std::string& struct_description() const;
  inline void set_struct_description(const ::std::string& value);
  inline void set_struct_description(const char* value);
  inline void set_struct_description(const char* value, size_t size);
  inline ::std::string* mutable_struct_description();
  inline ::std::string* release_struct_description();
  inline void set_allocated_struct_description(::std::string* struct_description);

  // repeated .Proto.ModuleConfigurationValue values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::Proto::ModuleConfigurationValue& values(int index) const;
  inline ::Proto::ModuleConfigurationValue* mutable_values(int index);
  inline ::Proto::ModuleConfigurationValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >*
      mutable_values();

  // optional string name = 3 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Proto.ModuleConfiguration)
 private:
  inline void set_has_struct_description();
  inline void clear_has_struct_description();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* struct_description_;
  ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue > values_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static ModuleConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class ModuleConfigurationValue : public ::google::protobuf::Message {
 public:
  ModuleConfigurationValue();
  virtual ~ModuleConfigurationValue();

  ModuleConfigurationValue(const ModuleConfigurationValue& from);

  inline ModuleConfigurationValue& operator=(const ModuleConfigurationValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleConfigurationValue& default_instance();

  void Swap(ModuleConfigurationValue* other);

  // implements Message ----------------------------------------------

  ModuleConfigurationValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleConfigurationValue& from);
  void MergeFrom(const ModuleConfigurationValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Proto.ModuleConfigurationValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static ModuleConfigurationValue* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  void Swap(Property* other);

  // implements Message ----------------------------------------------

  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Proto.Property)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class Address16 : public ::google::protobuf::Message {
 public:
  Address16();
  virtual ~Address16();

  Address16(const Address16& from);

  inline Address16& operator=(const Address16& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address16& default_instance();

  void Swap(Address16* other);

  // implements Message ----------------------------------------------

  Address16* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address16& from);
  void MergeFrom(const Address16& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 offset = 1 [default = -1];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // required int32 bit = 2 [default = -1];
  inline bool has_bit() const;
  inline void clear_bit();
  static const int kBitFieldNumber = 2;
  inline ::google::protobuf::int32 bit() const;
  inline void set_bit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Address16)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_bit();
  inline void clear_has_bit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 bit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Address16* default_instance_;
};
// -------------------------------------------------------------------

class AppSignal : public ::google::protobuf::Message {
 public:
  AppSignal();
  virtual ~AppSignal();

  AppSignal(const AppSignal& from);

  inline AppSignal& operator=(const AppSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppSignal& default_instance();

  void Swap(AppSignal* other);

  // implements Message ----------------------------------------------

  AppSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppSignal& from);
  void MergeFrom(const AppSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 signalGroupID = 2;
  inline bool has_signalgroupid() const;
  inline void clear_signalgroupid();
  static const int kSignalGroupIDFieldNumber = 2;
  inline ::google::protobuf::int32 signalgroupid() const;
  inline void set_signalgroupid(::google::protobuf::int32 value);

  // optional int32 signalInstanceID = 3;
  inline bool has_signalinstanceid() const;
  inline void clear_signalinstanceid();
  static const int kSignalInstanceIDFieldNumber = 3;
  inline ::google::protobuf::int32 signalinstanceid() const;
  inline void set_signalinstanceid(::google::protobuf::int32 value);

  // optional int32 changesetID = 4;
  inline bool has_changesetid() const;
  inline void clear_changesetid();
  static const int kChangesetIDFieldNumber = 4;
  inline ::google::protobuf::int32 changesetid() const;
  inline void set_changesetid(::google::protobuf::int32 value);

  // optional bool checkedOut = 5;
  inline bool has_checkedout() const;
  inline void clear_checkedout();
  static const int kCheckedOutFieldNumber = 5;
  inline bool checkedout() const;
  inline void set_checkedout(bool value);

  // optional int32 userID = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 6;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 subsystemChannel = 7;
  inline bool has_subsystemchannel() const;
  inline void clear_subsystemchannel();
  static const int kSubsystemChannelFieldNumber = 7;
  inline ::google::protobuf::int32 subsystemchannel() const;
  inline void set_subsystemchannel(::google::protobuf::int32 value);

  // optional int32 type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int64 created = 9;
  inline bool has_created() const;
  inline void clear_created();
  static const int kCreatedFieldNumber = 9;
  inline ::google::protobuf::int64 created() const;
  inline void set_created(::google::protobuf::int64 value);

  // optional bool deleted = 10;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 10;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // optional int64 instanceCreated = 11;
  inline bool has_instancecreated() const;
  inline void clear_instancecreated();
  static const int kInstanceCreatedFieldNumber = 11;
  inline ::google::protobuf::int64 instancecreated() const;
  inline void set_instancecreated(::google::protobuf::int64 value);

  // optional int32 instanceAction = 12;
  inline bool has_instanceaction() const;
  inline void clear_instanceaction();
  static const int kInstanceActionFieldNumber = 12;
  inline ::google::protobuf::int32 instanceaction() const;
  inline void set_instanceaction(::google::protobuf::int32 value);

  // optional string appSignalID = 13;
  inline bool has_appsignalid() const;
  inline void clear_appsignalid();
  static const int kAppSignalIDFieldNumber = 13;
  inline const ::std::string& appsignalid() const;
  inline void set_appsignalid(const ::std::string& value);
  inline void set_appsignalid(const char* value);
  inline void set_appsignalid(const char* value, size_t size);
  inline ::std::string* mutable_appsignalid();
  inline ::std::string* release_appsignalid();
  inline void set_allocated_appsignalid(::std::string* appsignalid);

  // optional string customAppSignalID = 14;
  inline bool has_customappsignalid() const;
  inline void clear_customappsignalid();
  static const int kCustomAppSignalIDFieldNumber = 14;
  inline const ::std::string& customappsignalid() const;
  inline void set_customappsignalid(const ::std::string& value);
  inline void set_customappsignalid(const char* value);
  inline void set_customappsignalid(const char* value, size_t size);
  inline ::std::string* mutable_customappsignalid();
  inline ::std::string* release_customappsignalid();
  inline void set_allocated_customappsignalid(::std::string* customappsignalid);

  // optional string caption = 15;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 15;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional int32 dataFormat = 16;
  inline bool has_dataformat() const;
  inline void clear_dataformat();
  static const int kDataFormatFieldNumber = 16;
  inline ::google::protobuf::int32 dataformat() const;
  inline void set_dataformat(::google::protobuf::int32 value);

  // optional int32 dataSize = 17;
  inline bool has_datasize() const;
  inline void clear_datasize();
  static const int kDataSizeFieldNumber = 17;
  inline ::google::protobuf::int32 datasize() const;
  inline void set_datasize(::google::protobuf::int32 value);

  // optional int32 lowADC = 18;
  inline bool has_lowadc() const;
  inline void clear_lowadc();
  static const int kLowADCFieldNumber = 18;
  inline ::google::protobuf::int32 lowadc() const;
  inline void set_lowadc(::google::protobuf::int32 value);

  // optional int32 highADC = 19;
  inline bool has_highadc() const;
  inline void clear_highadc();
  static const int kHighADCFieldNumber = 19;
  inline ::google::protobuf::int32 highadc() const;
  inline void set_highadc(::google::protobuf::int32 value);

  // optional double lowEngeneeringUnits = 20;
  inline bool has_lowengeneeringunits() const;
  inline void clear_lowengeneeringunits();
  static const int kLowEngeneeringUnitsFieldNumber = 20;
  inline double lowengeneeringunits() const;
  inline void set_lowengeneeringunits(double value);

  // optional double highEngeneeringUnits = 21;
  inline bool has_highengeneeringunits() const;
  inline void clear_highengeneeringunits();
  static const int kHighEngeneeringUnitsFieldNumber = 21;
  inline double highengeneeringunits() const;
  inline void set_highengeneeringunits(double value);

  // optional int32 unitID = 22;
  inline bool has_unitid() const;
  inline void clear_unitid();
  static const int kUnitIDFieldNumber = 22;
  inline ::google::protobuf::int32 unitid() const;
  inline void set_unitid(::google::protobuf::int32 value);

  // optional double adjustment = 23;
  inline bool has_adjustment() const;
  inline void clear_adjustment();
  static const int kAdjustmentFieldNumber = 23;
  inline double adjustment() const;
  inline void set_adjustment(double value);

  // optional double lowValidRange = 24;
  inline bool has_lowvalidrange() const;
  inline void clear_lowvalidrange();
  static const int kLowValidRangeFieldNumber = 24;
  inline double lowvalidrange() const;
  inline void set_lowvalidrange(double value);

  // optional double highValidRange = 25;
  inline bool has_highvalidrange() const;
  inline void clear_highvalidrange();
  static const int kHighValidRangeFieldNumber = 25;
  inline double highvalidrange() const;
  inline void set_highvalidrange(double value);

  // optional double unbalanceLimit = 26;
  inline bool has_unbalancelimit() const;
  inline void clear_unbalancelimit();
  static const int kUnbalanceLimitFieldNumber = 26;
  inline double unbalancelimit() const;
  inline void set_unbalancelimit(double value);

  // optional double inputLowLimit = 27;
  inline bool has_inputlowlimit() const;
  inline void clear_inputlowlimit();
  static const int kInputLowLimitFieldNumber = 27;
  inline double inputlowlimit() const;
  inline void set_inputlowlimit(double value);

  // optional double inputHighLimit = 28;
  inline bool has_inputhighlimit() const;
  inline void clear_inputhighlimit();
  static const int kInputHighLimitFieldNumber = 28;
  inline double inputhighlimit() const;
  inline void set_inputhighlimit(double value);

  // optional int32 inputUnitID = 29;
  inline bool has_inputunitid() const;
  inline void clear_inputunitid();
  static const int kInputUnitIDFieldNumber = 29;
  inline ::google::protobuf::int32 inputunitid() const;
  inline void set_inputunitid(::google::protobuf::int32 value);

  // optional int32 inputSensorID = 30;
  inline bool has_inputsensorid() const;
  inline void clear_inputsensorid();
  static const int kInputSensorIDFieldNumber = 30;
  inline ::google::protobuf::int32 inputsensorid() const;
  inline void set_inputsensorid(::google::protobuf::int32 value);

  // optional double outputLowLimit = 31;
  inline bool has_outputlowlimit() const;
  inline void clear_outputlowlimit();
  static const int kOutputLowLimitFieldNumber = 31;
  inline double outputlowlimit() const;
  inline void set_outputlowlimit(double value);

  // optional double outputHighLimit = 32;
  inline bool has_outputhighlimit() const;
  inline void clear_outputhighlimit();
  static const int kOutputHighLimitFieldNumber = 32;
  inline double outputhighlimit() const;
  inline void set_outputhighlimit(double value);

  // optional int32 outputUnitID = 33;
  inline bool has_outputunitid() const;
  inline void clear_outputunitid();
  static const int kOutputUnitIDFieldNumber = 33;
  inline ::google::protobuf::int32 outputunitid() const;
  inline void set_outputunitid(::google::protobuf::int32 value);

  // optional int32 outputMode = 34;
  inline bool has_outputmode() const;
  inline void clear_outputmode();
  static const int kOutputModeFieldNumber = 34;
  inline ::google::protobuf::int32 outputmode() const;
  inline void set_outputmode(::google::protobuf::int32 value);

  // optional int32 outputSensorID = 35;
  inline bool has_outputsensorid() const;
  inline void clear_outputsensorid();
  static const int kOutputSensorIDFieldNumber = 35;
  inline ::google::protobuf::int32 outputsensorid() const;
  inline void set_outputsensorid(::google::protobuf::int32 value);

  // optional bool acquire = 36;
  inline bool has_acquire() const;
  inline void clear_acquire();
  static const int kAcquireFieldNumber = 36;
  inline bool acquire() const;
  inline void set_acquire(bool value);

  // optional bool calculated = 37;
  inline bool has_calculated() const;
  inline void clear_calculated();
  static const int kCalculatedFieldNumber = 37;
  inline bool calculated() const;
  inline void set_calculated(bool value);

  // optional int32 normalState = 38;
  inline bool has_normalstate() const;
  inline void clear_normalstate();
  static const int kNormalStateFieldNumber = 38;
  inline ::google::protobuf::int32 normalstate() const;
  inline void set_normalstate(::google::protobuf::int32 value);

  // optional int32 decimalPlaces = 39;
  inline bool has_decimalplaces() const;
  inline void clear_decimalplaces();
  static const int kDecimalPlacesFieldNumber = 39;
  inline ::google::protobuf::int32 decimalplaces() const;
  inline void set_decimalplaces(::google::protobuf::int32 value);

  // optional double aperture = 40;
  inline bool has_aperture() const;
  inline void clear_aperture();
  static const int kApertureFieldNumber = 40;
  inline double aperture() const;
  inline void set_aperture(double value);

  // optional int32 inOutType = 41;
  inline bool has_inouttype() const;
  inline void clear_inouttype();
  static const int kInOutTypeFieldNumber = 41;
  inline ::google::protobuf::int32 inouttype() const;
  inline void set_inouttype(::google::protobuf::int32 value);

  // optional string equipmentID = 42;
  inline bool has_equipmentid() const;
  inline void clear_equipmentid();
  static const int kEquipmentIDFieldNumber = 42;
  inline const ::std::string& equipmentid() const;
  inline void set_equipmentid(const ::std::string& value);
  inline void set_equipmentid(const char* value);
  inline void set_equipmentid(const char* value, size_t size);
  inline ::std::string* mutable_equipmentid();
  inline ::std::string* release_equipmentid();
  inline void set_allocated_equipmentid(::std::string* equipmentid);

  // optional double filteringTime = 43;
  inline bool has_filteringtime() const;
  inline void clear_filteringtime();
  static const int kFilteringTimeFieldNumber = 43;
  inline double filteringtime() const;
  inline void set_filteringtime(double value);

  // optional double spreadTolerance = 44;
  inline bool has_spreadtolerance() const;
  inline void clear_spreadtolerance();
  static const int kSpreadToleranceFieldNumber = 44;
  inline double spreadtolerance() const;
  inline void set_spreadtolerance(double value);

  // optional int32 byteOrder = 45;
  inline bool has_byteorder() const;
  inline void clear_byteorder();
  static const int kByteOrderFieldNumber = 45;
  inline ::google::protobuf::int32 byteorder() const;
  inline void set_byteorder(::google::protobuf::int32 value);

  // optional bool enableTuning = 46;
  inline bool has_enabletuning() const;
  inline void clear_enabletuning();
  static const int kEnableTuningFieldNumber = 46;
  inline bool enabletuning() const;
  inline void set_enabletuning(bool value);

  // optional double tuningDefaultValue = 47;
  inline bool has_tuningdefaultvalue() const;
  inline void clear_tuningdefaultvalue();
  static const int kTuningDefaultValueFieldNumber = 47;
  inline double tuningdefaultvalue() const;
  inline void set_tuningdefaultvalue(double value);

  // optional uint64 hash = 48;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 48;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // optional int32 regValueAddrOffset = 200;
  inline bool has_regvalueaddroffset() const;
  inline void clear_regvalueaddroffset();
  static const int kRegValueAddrOffsetFieldNumber = 200;
  inline ::google::protobuf::int32 regvalueaddroffset() const;
  inline void set_regvalueaddroffset(::google::protobuf::int32 value);

  // optional int32 regValueAddrBit = 201;
  inline bool has_regvalueaddrbit() const;
  inline void clear_regvalueaddrbit();
  static const int kRegValueAddrBitFieldNumber = 201;
  inline ::google::protobuf::int32 regvalueaddrbit() const;
  inline void set_regvalueaddrbit(::google::protobuf::int32 value);

  // optional int32 regValidityAddrOffset = 202;
  inline bool has_regvalidityaddroffset() const;
  inline void clear_regvalidityaddroffset();
  static const int kRegValidityAddrOffsetFieldNumber = 202;
  inline ::google::protobuf::int32 regvalidityaddroffset() const;
  inline void set_regvalidityaddroffset(::google::protobuf::int32 value);

  // optional int32 regValidityAddrBit = 203;
  inline bool has_regvalidityaddrbit() const;
  inline void clear_regvalidityaddrbit();
  static const int kRegValidityAddrBitFieldNumber = 203;
  inline ::google::protobuf::int32 regvalidityaddrbit() const;
  inline void set_regvalidityaddrbit(::google::protobuf::int32 value);

  // optional int32 ioBufferAddrOffset = 204;
  inline bool has_iobufferaddroffset() const;
  inline void clear_iobufferaddroffset();
  static const int kIoBufferAddrOffsetFieldNumber = 204;
  inline ::google::protobuf::int32 iobufferaddroffset() const;
  inline void set_iobufferaddroffset(::google::protobuf::int32 value);

  // optional int32 ioBufferAddrBit = 205;
  inline bool has_iobufferaddrbit() const;
  inline void clear_iobufferaddrbit();
  static const int kIoBufferAddrBitFieldNumber = 205;
  inline ::google::protobuf::int32 iobufferaddrbit() const;
  inline void set_iobufferaddrbit(::google::protobuf::int32 value);

  // optional int32 ramAddrOffset = 206;
  inline bool has_ramaddroffset() const;
  inline void clear_ramaddroffset();
  static const int kRamAddrOffsetFieldNumber = 206;
  inline ::google::protobuf::int32 ramaddroffset() const;
  inline void set_ramaddroffset(::google::protobuf::int32 value);

  // optional int32 ramAddrBit = 207;
  inline bool has_ramaddrbit() const;
  inline void clear_ramaddrbit();
  static const int kRamAddrBitFieldNumber = 207;
  inline ::google::protobuf::int32 ramaddrbit() const;
  inline void set_ramaddrbit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.AppSignal)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_signalgroupid();
  inline void clear_has_signalgroupid();
  inline void set_has_signalinstanceid();
  inline void clear_has_signalinstanceid();
  inline void set_has_changesetid();
  inline void clear_has_changesetid();
  inline void set_has_checkedout();
  inline void clear_has_checkedout();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_subsystemchannel();
  inline void clear_has_subsystemchannel();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_created();
  inline void clear_has_created();
  inline void set_has_deleted();
  inline void clear_has_deleted();
  inline void set_has_instancecreated();
  inline void clear_has_instancecreated();
  inline void set_has_instanceaction();
  inline void clear_has_instanceaction();
  inline void set_has_appsignalid();
  inline void clear_has_appsignalid();
  inline void set_has_customappsignalid();
  inline void clear_has_customappsignalid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_dataformat();
  inline void clear_has_dataformat();
  inline void set_has_datasize();
  inline void clear_has_datasize();
  inline void set_has_lowadc();
  inline void clear_has_lowadc();
  inline void set_has_highadc();
  inline void clear_has_highadc();
  inline void set_has_lowengeneeringunits();
  inline void clear_has_lowengeneeringunits();
  inline void set_has_highengeneeringunits();
  inline void clear_has_highengeneeringunits();
  inline void set_has_unitid();
  inline void clear_has_unitid();
  inline void set_has_adjustment();
  inline void clear_has_adjustment();
  inline void set_has_lowvalidrange();
  inline void clear_has_lowvalidrange();
  inline void set_has_highvalidrange();
  inline void clear_has_highvalidrange();
  inline void set_has_unbalancelimit();
  inline void clear_has_unbalancelimit();
  inline void set_has_inputlowlimit();
  inline void clear_has_inputlowlimit();
  inline void set_has_inputhighlimit();
  inline void clear_has_inputhighlimit();
  inline void set_has_inputunitid();
  inline void clear_has_inputunitid();
  inline void set_has_inputsensorid();
  inline void clear_has_inputsensorid();
  inline void set_has_outputlowlimit();
  inline void clear_has_outputlowlimit();
  inline void set_has_outputhighlimit();
  inline void clear_has_outputhighlimit();
  inline void set_has_outputunitid();
  inline void clear_has_outputunitid();
  inline void set_has_outputmode();
  inline void clear_has_outputmode();
  inline void set_has_outputsensorid();
  inline void clear_has_outputsensorid();
  inline void set_has_acquire();
  inline void clear_has_acquire();
  inline void set_has_calculated();
  inline void clear_has_calculated();
  inline void set_has_normalstate();
  inline void clear_has_normalstate();
  inline void set_has_decimalplaces();
  inline void clear_has_decimalplaces();
  inline void set_has_aperture();
  inline void clear_has_aperture();
  inline void set_has_inouttype();
  inline void clear_has_inouttype();
  inline void set_has_equipmentid();
  inline void clear_has_equipmentid();
  inline void set_has_filteringtime();
  inline void clear_has_filteringtime();
  inline void set_has_spreadtolerance();
  inline void clear_has_spreadtolerance();
  inline void set_has_byteorder();
  inline void clear_has_byteorder();
  inline void set_has_enabletuning();
  inline void clear_has_enabletuning();
  inline void set_has_tuningdefaultvalue();
  inline void clear_has_tuningdefaultvalue();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_regvalueaddroffset();
  inline void clear_has_regvalueaddroffset();
  inline void set_has_regvalueaddrbit();
  inline void clear_has_regvalueaddrbit();
  inline void set_has_regvalidityaddroffset();
  inline void clear_has_regvalidityaddroffset();
  inline void set_has_regvalidityaddrbit();
  inline void clear_has_regvalidityaddrbit();
  inline void set_has_iobufferaddroffset();
  inline void clear_has_iobufferaddroffset();
  inline void set_has_iobufferaddrbit();
  inline void clear_has_iobufferaddrbit();
  inline void set_has_ramaddroffset();
  inline void clear_has_ramaddroffset();
  inline void set_has_ramaddrbit();
  inline void clear_has_ramaddrbit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 signalgroupid_;
  ::google::protobuf::int32 signalinstanceid_;
  ::google::protobuf::int32 changesetid_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 subsystemchannel_;
  ::google::protobuf::int64 created_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 instanceaction_;
  ::google::protobuf::int64 instancecreated_;
  ::std::string* appsignalid_;
  ::std::string* customappsignalid_;
  ::std::string* caption_;
  ::google::protobuf::int32 dataformat_;
  ::google::protobuf::int32 datasize_;
  ::google::protobuf::int32 lowadc_;
  ::google::protobuf::int32 highadc_;
  double lowengeneeringunits_;
  double highengeneeringunits_;
  bool checkedout_;
  bool deleted_;
  bool acquire_;
  bool calculated_;
  ::google::protobuf::int32 unitid_;
  double adjustment_;
  double lowvalidrange_;
  double highvalidrange_;
  double unbalancelimit_;
  double inputlowlimit_;
  double inputhighlimit_;
  ::google::protobuf::int32 inputunitid_;
  ::google::protobuf::int32 inputsensorid_;
  double outputlowlimit_;
  double outputhighlimit_;
  ::google::protobuf::int32 outputunitid_;
  ::google::protobuf::int32 outputmode_;
  ::google::protobuf::int32 outputsensorid_;
  ::google::protobuf::int32 normalstate_;
  double aperture_;
  ::google::protobuf::int32 decimalplaces_;
  ::google::protobuf::int32 inouttype_;
  ::std::string* equipmentid_;
  double filteringtime_;
  double spreadtolerance_;
  ::google::protobuf::int32 byteorder_;
  bool enabletuning_;
  double tuningdefaultvalue_;
  ::google::protobuf::uint64 hash_;
  ::google::protobuf::int32 regvalueaddroffset_;
  ::google::protobuf::int32 regvalueaddrbit_;
  ::google::protobuf::int32 regvalidityaddroffset_;
  ::google::protobuf::int32 regvalidityaddrbit_;
  ::google::protobuf::int32 iobufferaddroffset_;
  ::google::protobuf::int32 iobufferaddrbit_;
  ::google::protobuf::int32 ramaddroffset_;
  ::google::protobuf::int32 ramaddrbit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(56 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AppSignal* default_instance_;
};
// -------------------------------------------------------------------

class AppSignalState : public ::google::protobuf::Message {
 public:
  AppSignalState();
  virtual ~AppSignalState();

  AppSignalState(const AppSignalState& from);

  inline AppSignalState& operator=(const AppSignalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppSignalState& default_instance();

  void Swap(AppSignalState* other);

  // implements Message ----------------------------------------------

  AppSignalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppSignalState& from);
  void MergeFrom(const AppSignalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline ::google::protobuf::uint64 hash() const;
  inline void set_hash(::google::protobuf::uint64 value);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // optional uint32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional sint64 systemTime = 4;
  inline bool has_systemtime() const;
  inline void clear_systemtime();
  static const int kSystemTimeFieldNumber = 4;
  inline ::google::protobuf::int64 systemtime() const;
  inline void set_systemtime(::google::protobuf::int64 value);

  // optional sint64 localTime = 5;
  inline bool has_localtime() const;
  inline void clear_localtime();
  static const int kLocalTimeFieldNumber = 5;
  inline ::google::protobuf::int64 localtime() const;
  inline void set_localtime(::google::protobuf::int64 value);

  // optional sint64 plantTime = 6;
  inline bool has_planttime() const;
  inline void clear_planttime();
  static const int kPlantTimeFieldNumber = 6;
  inline ::google::protobuf::int64 planttime() const;
  inline void set_planttime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Proto.AppSignalState)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_systemtime();
  inline void clear_has_systemtime();
  inline void set_has_localtime();
  inline void clear_has_localtime();
  inline void set_has_planttime();
  inline void clear_has_planttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 hash_;
  double value_;
  ::google::protobuf::int64 systemtime_;
  ::google::protobuf::int64 localtime_;
  ::google::protobuf::int64 planttime_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AppSignalState* default_instance_;
};
// ===================================================================


// ===================================================================

// Uuid

// required bytes uuid = 1;
inline bool Uuid::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uuid::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uuid::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uuid::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Uuid::uuid() const {
  return *uuid_;
}
inline void Uuid::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Uuid::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Uuid::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Uuid::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Uuid::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Uuid::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// qvariant

// required int32 type = 1;
inline bool qvariant::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void qvariant::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void qvariant::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void qvariant::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 qvariant::type() const {
  return type_;
}
inline void qvariant::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 intValue = 2 [default = 0];
inline bool qvariant::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qvariant::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void qvariant::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void qvariant::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 qvariant::intvalue() const {
  return intvalue_;
}
inline void qvariant::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional uint32 uintValue = 3 [default = 0];
inline bool qvariant::has_uintvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qvariant::set_has_uintvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void qvariant::clear_has_uintvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void qvariant::clear_uintvalue() {
  uintvalue_ = 0u;
  clear_has_uintvalue();
}
inline ::google::protobuf::uint32 qvariant::uintvalue() const {
  return uintvalue_;
}
inline void qvariant::set_uintvalue(::google::protobuf::uint32 value) {
  set_has_uintvalue();
  uintvalue_ = value;
}

// optional double doubleValue = 4 [default = 0];
inline bool qvariant::has_doublevalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qvariant::set_has_doublevalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void qvariant::clear_has_doublevalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void qvariant::clear_doublevalue() {
  doublevalue_ = 0;
  clear_has_doublevalue();
}
inline double qvariant::doublevalue() const {
  return doublevalue_;
}
inline void qvariant::set_doublevalue(double value) {
  set_has_doublevalue();
  doublevalue_ = value;
}

// optional bool boolValue = 5 [default = false];
inline bool qvariant::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void qvariant::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void qvariant::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void qvariant::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool qvariant::boolvalue() const {
  return boolvalue_;
}
inline void qvariant::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// -------------------------------------------------------------------

// wstring

// required bytes text = 1;
inline bool wstring::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wstring::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wstring::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wstring::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& wstring::text() const {
  return *text_;
}
inline void wstring::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void wstring::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void wstring::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wstring::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* wstring::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void wstring::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FontParam

// required .Proto.wstring name = 1;
inline bool FontParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FontParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FontParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FontParam::clear_name() {
  if (name_ != NULL) name_->::Proto::wstring::Clear();
  clear_has_name();
}
inline const ::Proto::wstring& FontParam::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::Proto::wstring* FontParam::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::Proto::wstring;
  return name_;
}
inline ::Proto::wstring* FontParam::release_name() {
  clear_has_name();
  ::Proto::wstring* temp = name_;
  name_ = NULL;
  return temp;
}
inline void FontParam::set_allocated_name(::Proto::wstring* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// required double size = 2;
inline bool FontParam::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FontParam::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FontParam::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FontParam::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double FontParam::size() const {
  return size_;
}
inline void FontParam::set_size(double value) {
  set_has_size();
  size_ = value;
}

// required bool bold = 3;
inline bool FontParam::has_bold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FontParam::set_has_bold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FontParam::clear_has_bold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FontParam::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool FontParam::bold() const {
  return bold_;
}
inline void FontParam::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
}

// required bool italic = 4;
inline bool FontParam::has_italic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FontParam::set_has_italic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FontParam::clear_has_italic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FontParam::clear_italic() {
  italic_ = false;
  clear_has_italic();
}
inline bool FontParam::italic() const {
  return italic_;
}
inline void FontParam::set_italic(bool value) {
  set_has_italic();
  italic_ = value;
}

// -------------------------------------------------------------------

// SchemaPoint

// required double x = 1;
inline bool SchemaPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SchemaPoint::x() const {
  return x_;
}
inline void SchemaPoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool SchemaPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SchemaPoint::y() const {
  return y_;
}
inline void SchemaPoint::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Envelope

// required uint32 classnamehash = 1;
inline bool Envelope::has_classnamehash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_classnamehash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_classnamehash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_classnamehash() {
  classnamehash_ = 0u;
  clear_has_classnamehash();
}
inline ::google::protobuf::uint32 Envelope::classnamehash() const {
  return classnamehash_;
}
inline void Envelope::set_classnamehash(::google::protobuf::uint32 value) {
  set_has_classnamehash();
  classnamehash_ = value;
}

// optional .Proto.SchemaItem schemaitem = 6;
inline bool Envelope::has_schemaitem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_schemaitem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_schemaitem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_schemaitem() {
  if (schemaitem_ != NULL) schemaitem_->::Proto::SchemaItem::Clear();
  clear_has_schemaitem();
}
inline const ::Proto::SchemaItem& Envelope::schemaitem() const {
  return schemaitem_ != NULL ? *schemaitem_ : *default_instance_->schemaitem_;
}
inline ::Proto::SchemaItem* Envelope::mutable_schemaitem() {
  set_has_schemaitem();
  if (schemaitem_ == NULL) schemaitem_ = new ::Proto::SchemaItem;
  return schemaitem_;
}
inline ::Proto::SchemaItem* Envelope::release_schemaitem() {
  clear_has_schemaitem();
  ::Proto::SchemaItem* temp = schemaitem_;
  schemaitem_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemaitem(::Proto::SchemaItem* schemaitem) {
  delete schemaitem_;
  schemaitem_ = schemaitem;
  if (schemaitem) {
    set_has_schemaitem();
  } else {
    clear_has_schemaitem();
  }
}

// optional .Proto.DeviceObject deviceobject = 7;
inline bool Envelope::has_deviceobject() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_deviceobject() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_deviceobject() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_deviceobject() {
  if (deviceobject_ != NULL) deviceobject_->::Proto::DeviceObject::Clear();
  clear_has_deviceobject();
}
inline const ::Proto::DeviceObject& Envelope::deviceobject() const {
  return deviceobject_ != NULL ? *deviceobject_ : *default_instance_->deviceobject_;
}
inline ::Proto::DeviceObject* Envelope::mutable_deviceobject() {
  set_has_deviceobject();
  if (deviceobject_ == NULL) deviceobject_ = new ::Proto::DeviceObject;
  return deviceobject_;
}
inline ::Proto::DeviceObject* Envelope::release_deviceobject() {
  clear_has_deviceobject();
  ::Proto::DeviceObject* temp = deviceobject_;
  deviceobject_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_deviceobject(::Proto::DeviceObject* deviceobject) {
  delete deviceobject_;
  deviceobject_ = deviceobject;
  if (deviceobject) {
    set_has_deviceobject();
  } else {
    clear_has_deviceobject();
  }
}

// optional .Proto.Schema schema = 100;
inline bool Envelope::has_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_schema() {
  if (schema_ != NULL) schema_->::Proto::Schema::Clear();
  clear_has_schema();
}
inline const ::Proto::Schema& Envelope::schema() const {
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::Proto::Schema* Envelope::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::Proto::Schema;
  return schema_;
}
inline ::Proto::Schema* Envelope::release_schema() {
  clear_has_schema();
  ::Proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schema(::Proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
}

// optional .Proto.SchemaLayer schemalayer = 101;
inline bool Envelope::has_schemalayer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Envelope::set_has_schemalayer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Envelope::clear_has_schemalayer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Envelope::clear_schemalayer() {
  if (schemalayer_ != NULL) schemalayer_->::Proto::SchemaLayer::Clear();
  clear_has_schemalayer();
}
inline const ::Proto::SchemaLayer& Envelope::schemalayer() const {
  return schemalayer_ != NULL ? *schemalayer_ : *default_instance_->schemalayer_;
}
inline ::Proto::SchemaLayer* Envelope::mutable_schemalayer() {
  set_has_schemalayer();
  if (schemalayer_ == NULL) schemalayer_ = new ::Proto::SchemaLayer;
  return schemalayer_;
}
inline ::Proto::SchemaLayer* Envelope::release_schemalayer() {
  clear_has_schemalayer();
  ::Proto::SchemaLayer* temp = schemalayer_;
  schemalayer_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemalayer(::Proto::SchemaLayer* schemalayer) {
  delete schemalayer_;
  schemalayer_ = schemalayer;
  if (schemalayer) {
    set_has_schemalayer();
  } else {
    clear_has_schemalayer();
  }
}

// optional .Proto.FblElement fblelement = 102;
inline bool Envelope::has_fblelement() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Envelope::set_has_fblelement() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Envelope::clear_has_fblelement() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Envelope::clear_fblelement() {
  if (fblelement_ != NULL) fblelement_->::Proto::FblElement::Clear();
  clear_has_fblelement();
}
inline const ::Proto::FblElement& Envelope::fblelement() const {
  return fblelement_ != NULL ? *fblelement_ : *default_instance_->fblelement_;
}
inline ::Proto::FblElement* Envelope::mutable_fblelement() {
  set_has_fblelement();
  if (fblelement_ == NULL) fblelement_ = new ::Proto::FblElement;
  return fblelement_;
}
inline ::Proto::FblElement* Envelope::release_fblelement() {
  clear_has_fblelement();
  ::Proto::FblElement* temp = fblelement_;
  fblelement_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_fblelement(::Proto::FblElement* fblelement) {
  delete fblelement_;
  fblelement_ = fblelement;
  if (fblelement) {
    set_has_fblelement();
  } else {
    clear_has_fblelement();
  }
}

// optional .Proto.Configuration configuration = 103;
inline bool Envelope::has_configuration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Envelope::set_has_configuration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Envelope::clear_has_configuration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Envelope::clear_configuration() {
  if (configuration_ != NULL) configuration_->::Proto::Configuration::Clear();
  clear_has_configuration();
}
inline const ::Proto::Configuration& Envelope::configuration() const {
  return configuration_ != NULL ? *configuration_ : *default_instance_->configuration_;
}
inline ::Proto::Configuration* Envelope::mutable_configuration() {
  set_has_configuration();
  if (configuration_ == NULL) configuration_ = new ::Proto::Configuration;
  return configuration_;
}
inline ::Proto::Configuration* Envelope::release_configuration() {
  clear_has_configuration();
  ::Proto::Configuration* temp = configuration_;
  configuration_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_configuration(::Proto::Configuration* configuration) {
  delete configuration_;
  configuration_ = configuration;
  if (configuration) {
    set_has_configuration();
  } else {
    clear_has_configuration();
  }
}

// -------------------------------------------------------------------

// EnvelopeSet

// repeated .Proto.Envelope schemaItems = 1;
inline int EnvelopeSet::schemaitems_size() const {
  return schemaitems_.size();
}
inline void EnvelopeSet::clear_schemaitems() {
  schemaitems_.Clear();
}
inline const ::Proto::Envelope& EnvelopeSet::schemaitems(int index) const {
  return schemaitems_.Get(index);
}
inline ::Proto::Envelope* EnvelopeSet::mutable_schemaitems(int index) {
  return schemaitems_.Mutable(index);
}
inline ::Proto::Envelope* EnvelopeSet::add_schemaitems() {
  return schemaitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
EnvelopeSet::schemaitems() const {
  return schemaitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
EnvelopeSet::mutable_schemaitems() {
  return &schemaitems_;
}

// -------------------------------------------------------------------

// Configuration

// required .Proto.Uuid uuid = 1;
inline bool Configuration::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Configuration::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Configuration::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Configuration::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring strID = 2;
inline bool Configuration::has_strid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_strid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_strid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& Configuration::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* Configuration::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* Configuration::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool Configuration::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& Configuration::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* Configuration::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* Configuration::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.wstring variables = 4;
inline bool Configuration::has_variables() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_variables() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_variables() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_variables() {
  if (variables_ != NULL) variables_->::Proto::wstring::Clear();
  clear_has_variables();
}
inline const ::Proto::wstring& Configuration::variables() const {
  return variables_ != NULL ? *variables_ : *default_instance_->variables_;
}
inline ::Proto::wstring* Configuration::mutable_variables() {
  set_has_variables();
  if (variables_ == NULL) variables_ = new ::Proto::wstring;
  return variables_;
}
inline ::Proto::wstring* Configuration::release_variables() {
  clear_has_variables();
  ::Proto::wstring* temp = variables_;
  variables_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_variables(::Proto::wstring* variables) {
  delete variables_;
  variables_ = variables;
  if (variables) {
    set_has_variables();
  } else {
    clear_has_variables();
  }
}

// required .Proto.wstring globals = 5;
inline bool Configuration::has_globals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_globals() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_globals() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_globals() {
  if (globals_ != NULL) globals_->::Proto::wstring::Clear();
  clear_has_globals();
}
inline const ::Proto::wstring& Configuration::globals() const {
  return globals_ != NULL ? *globals_ : *default_instance_->globals_;
}
inline ::Proto::wstring* Configuration::mutable_globals() {
  set_has_globals();
  if (globals_ == NULL) globals_ = new ::Proto::wstring;
  return globals_;
}
inline ::Proto::wstring* Configuration::release_globals() {
  clear_has_globals();
  ::Proto::wstring* temp = globals_;
  globals_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_globals(::Proto::wstring* globals) {
  delete globals_;
  globals_ = globals;
  if (globals) {
    set_has_globals();
  } else {
    clear_has_globals();
  }
}

// repeated .Proto.Uuid schemasIDs = 100;
inline int Configuration::schemasids_size() const {
  return schemasids_.size();
}
inline void Configuration::clear_schemasids() {
  schemasids_.Clear();
}
inline const ::Proto::Uuid& Configuration::schemasids(int index) const {
  return schemasids_.Get(index);
}
inline ::Proto::Uuid* Configuration::mutable_schemasids(int index) {
  return schemasids_.Mutable(index);
}
inline ::Proto::Uuid* Configuration::add_schemasids() {
  return schemasids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
Configuration::schemasids() const {
  return schemasids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
Configuration::mutable_schemasids() {
  return &schemasids_;
}

// repeated .Proto.Envelope schemas = 101;
inline int Configuration::schemas_size() const {
  return schemas_.size();
}
inline void Configuration::clear_schemas() {
  schemas_.Clear();
}
inline const ::Proto::Envelope& Configuration::schemas(int index) const {
  return schemas_.Get(index);
}
inline ::Proto::Envelope* Configuration::mutable_schemas(int index) {
  return schemas_.Mutable(index);
}
inline ::Proto::Envelope* Configuration::add_schemas() {
  return schemas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
Configuration::schemas() const {
  return schemas_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
Configuration::mutable_schemas() {
  return &schemas_;
}

// -------------------------------------------------------------------

// AfbElementCollection

// repeated .Proto.AfbElementXml elements = 1;
inline int AfbElementCollection::elements_size() const {
  return elements_.size();
}
inline void AfbElementCollection::clear_elements() {
  elements_.Clear();
}
inline const ::Proto::AfbElementXml& AfbElementCollection::elements(int index) const {
  return elements_.Get(index);
}
inline ::Proto::AfbElementXml* AfbElementCollection::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::Proto::AfbElementXml* AfbElementCollection::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >&
AfbElementCollection::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >*
AfbElementCollection::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// AfbElementXml

// required bytes data = 1;
inline bool AfbElementXml::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbElementXml::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbElementXml::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbElementXml::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AfbElementXml::data() const {
  return *data_;
}
inline void AfbElementXml::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AfbElementXml::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AfbElementXml::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AfbElementXml::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AfbElementXml::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AfbElementXml::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FblElement

// required .Proto.wstring strID = 2;
inline bool FblElement::has_strid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblElement::set_has_strid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblElement::clear_has_strid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblElement::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& FblElement::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* FblElement::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* FblElement::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool FblElement::has_caption() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblElement::set_has_caption() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblElement::clear_has_caption() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblElement::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& FblElement::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* FblElement::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* FblElement::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required uint32 opcode = 4;
inline bool FblElement::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblElement::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblElement::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblElement::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 FblElement::opcode() const {
  return opcode_;
}
inline void FblElement::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
}

// optional bool hasRam = 5 [default = false];
inline bool FblElement::has_hasram() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblElement::set_has_hasram() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblElement::clear_has_hasram() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblElement::clear_hasram() {
  hasram_ = false;
  clear_has_hasram();
}
inline bool FblElement::hasram() const {
  return hasram_;
}
inline void FblElement::set_hasram(bool value) {
  set_has_hasram();
  hasram_ = value;
}

// optional bool requiredStart = 6 [default = true];
inline bool FblElement::has_requiredstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblElement::set_has_requiredstart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblElement::clear_has_requiredstart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblElement::clear_requiredstart() {
  requiredstart_ = true;
  clear_has_requiredstart();
}
inline bool FblElement::requiredstart() const {
  return requiredstart_;
}
inline void FblElement::set_requiredstart(bool value) {
  set_has_requiredstart();
  requiredstart_ = value;
}

// repeated .Proto.AfbSignal inputs = 11;
inline int FblElement::inputs_size() const {
  return inputs_.size();
}
inline void FblElement::clear_inputs() {
  inputs_.Clear();
}
inline const ::Proto::AfbSignal& FblElement::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::Proto::AfbSignal* FblElement::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::Proto::AfbSignal* FblElement::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
FblElement::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
FblElement::mutable_inputs() {
  return &inputs_;
}

// repeated .Proto.AfbSignal outputs = 12;
inline int FblElement::outputs_size() const {
  return outputs_.size();
}
inline void FblElement::clear_outputs() {
  outputs_.Clear();
}
inline const ::Proto::AfbSignal& FblElement::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::Proto::AfbSignal* FblElement::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::Proto::AfbSignal* FblElement::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >&
FblElement::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbSignal >*
FblElement::mutable_outputs() {
  return &outputs_;
}

// repeated .Proto.AfbParam params = 13;
inline int FblElement::params_size() const {
  return params_.size();
}
inline void FblElement::clear_params() {
  params_.Clear();
}
inline const ::Proto::AfbParam& FblElement::params(int index) const {
  return params_.Get(index);
}
inline ::Proto::AfbParam* FblElement::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Proto::AfbParam* FblElement::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
FblElement::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
FblElement::mutable_params() {
  return &params_;
}

// optional .Proto.wstring description = 14;
inline bool FblElement::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FblElement::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FblElement::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FblElement::clear_description() {
  if (description_ != NULL) description_->::Proto::wstring::Clear();
  clear_has_description();
}
inline const ::Proto::wstring& FblElement::description() const {
  return description_ != NULL ? *description_ : *default_instance_->description_;
}
inline ::Proto::wstring* FblElement::mutable_description() {
  set_has_description();
  if (description_ == NULL) description_ = new ::Proto::wstring;
  return description_;
}
inline ::Proto::wstring* FblElement::release_description() {
  clear_has_description();
  ::Proto::wstring* temp = description_;
  description_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_description(::Proto::wstring* description) {
  delete description_;
  description_ = description;
  if (description) {
    set_has_description();
  } else {
    clear_has_description();
  }
}

// -------------------------------------------------------------------

// AfbSignal

// required .Proto.wstring caption = 1;
inline bool AfbSignal::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbSignal::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbSignal::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbSignal::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& AfbSignal::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* AfbSignal::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* AfbSignal::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void AfbSignal::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.FblSignalType type = 2;
inline bool AfbSignal::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AfbSignal::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AfbSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AfbSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto::FblSignalType AfbSignal::type() const {
  return static_cast< ::Proto::FblSignalType >(type_);
}
inline void AfbSignal::set_type(::Proto::FblSignalType value) {
  assert(::Proto::FblSignalType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 operandIndex = 3 [default = 0];
inline bool AfbSignal::has_operandindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AfbSignal::set_has_operandindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AfbSignal::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AfbSignal::clear_operandindex() {
  operandindex_ = 0;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 AfbSignal::operandindex() const {
  return operandindex_;
}
inline void AfbSignal::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional int32 size = 4 [default = 0];
inline bool AfbSignal::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AfbSignal::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AfbSignal::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AfbSignal::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 AfbSignal::size() const {
  return size_;
}
inline void AfbSignal::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional .Proto.wstring opName = 5;
inline bool AfbSignal::has_opname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AfbSignal::set_has_opname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AfbSignal::clear_has_opname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AfbSignal::clear_opname() {
  if (opname_ != NULL) opname_->::Proto::wstring::Clear();
  clear_has_opname();
}
inline const ::Proto::wstring& AfbSignal::opname() const {
  return opname_ != NULL ? *opname_ : *default_instance_->opname_;
}
inline ::Proto::wstring* AfbSignal::mutable_opname() {
  set_has_opname();
  if (opname_ == NULL) opname_ = new ::Proto::wstring;
  return opname_;
}
inline ::Proto::wstring* AfbSignal::release_opname() {
  clear_has_opname();
  ::Proto::wstring* temp = opname_;
  opname_ = NULL;
  return temp;
}
inline void AfbSignal::set_allocated_opname(::Proto::wstring* opname) {
  delete opname_;
  opname_ = opname;
  if (opname) {
    set_has_opname();
  } else {
    clear_has_opname();
  }
}

// optional .Proto.FblDataFormat dataFormat = 6;
inline bool AfbSignal::has_dataformat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AfbSignal::set_has_dataformat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AfbSignal::clear_has_dataformat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AfbSignal::clear_dataformat() {
  dataformat_ = 0;
  clear_has_dataformat();
}
inline ::Proto::FblDataFormat AfbSignal::dataformat() const {
  return static_cast< ::Proto::FblDataFormat >(dataformat_);
}
inline void AfbSignal::set_dataformat(::Proto::FblDataFormat value) {
  assert(::Proto::FblDataFormat_IsValid(value));
  set_has_dataformat();
  dataformat_ = value;
}

// -------------------------------------------------------------------

// AfbParam

// required .Proto.wstring caption = 1;
inline bool AfbParam::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbParam::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbParam::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbParam::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& AfbParam::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* AfbParam::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* AfbParam::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required bool visible = 7;
inline bool AfbParam::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AfbParam::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AfbParam::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AfbParam::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool AfbParam::visible() const {
  return visible_;
}
inline void AfbParam::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional int32 operandIndex = 8 [default = 0];
inline bool AfbParam::has_operandindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AfbParam::set_has_operandindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AfbParam::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AfbParam::clear_operandindex() {
  operandindex_ = 0;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 AfbParam::operandindex() const {
  return operandindex_;
}
inline void AfbParam::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional int32 size = 9 [default = 0];
inline bool AfbParam::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AfbParam::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AfbParam::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AfbParam::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 AfbParam::size() const {
  return size_;
}
inline void AfbParam::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional bool instantiator = 10 [default = false];
inline bool AfbParam::has_instantiator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AfbParam::set_has_instantiator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AfbParam::clear_has_instantiator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AfbParam::clear_instantiator() {
  instantiator_ = false;
  clear_has_instantiator();
}
inline bool AfbParam::instantiator() const {
  return instantiator_;
}
inline void AfbParam::set_instantiator(bool value) {
  set_has_instantiator();
  instantiator_ = value;
}

// optional bool user = 11 [default = false];
inline bool AfbParam::has_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AfbParam::set_has_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AfbParam::clear_has_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AfbParam::clear_user() {
  user_ = false;
  clear_has_user();
}
inline bool AfbParam::user() const {
  return user_;
}
inline void AfbParam::set_user(bool value) {
  set_has_user();
  user_ = value;
}

// optional .Proto.wstring changedScript = 12;
inline bool AfbParam::has_changedscript() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AfbParam::set_has_changedscript() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AfbParam::clear_has_changedscript() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AfbParam::clear_changedscript() {
  if (changedscript_ != NULL) changedscript_->::Proto::wstring::Clear();
  clear_has_changedscript();
}
inline const ::Proto::wstring& AfbParam::changedscript() const {
  return changedscript_ != NULL ? *changedscript_ : *default_instance_->changedscript_;
}
inline ::Proto::wstring* AfbParam::mutable_changedscript() {
  set_has_changedscript();
  if (changedscript_ == NULL) changedscript_ = new ::Proto::wstring;
  return changedscript_;
}
inline ::Proto::wstring* AfbParam::release_changedscript() {
  clear_has_changedscript();
  ::Proto::wstring* temp = changedscript_;
  changedscript_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_changedscript(::Proto::wstring* changedscript) {
  delete changedscript_;
  changedscript_ = changedscript;
  if (changedscript) {
    set_has_changedscript();
  } else {
    clear_has_changedscript();
  }
}

// optional .Proto.qvariant value = 13;
inline bool AfbParam::has_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AfbParam::set_has_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AfbParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AfbParam::clear_value() {
  if (value_ != NULL) value_->::Proto::qvariant::Clear();
  clear_has_value();
}
inline const ::Proto::qvariant& AfbParam::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Proto::qvariant* AfbParam::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Proto::qvariant;
  return value_;
}
inline ::Proto::qvariant* AfbParam::release_value() {
  clear_has_value();
  ::Proto::qvariant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_value(::Proto::qvariant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional .Proto.qvariant defaultvalue = 14;
inline bool AfbParam::has_defaultvalue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AfbParam::set_has_defaultvalue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AfbParam::clear_has_defaultvalue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AfbParam::clear_defaultvalue() {
  if (defaultvalue_ != NULL) defaultvalue_->::Proto::qvariant::Clear();
  clear_has_defaultvalue();
}
inline const ::Proto::qvariant& AfbParam::defaultvalue() const {
  return defaultvalue_ != NULL ? *defaultvalue_ : *default_instance_->defaultvalue_;
}
inline ::Proto::qvariant* AfbParam::mutable_defaultvalue() {
  set_has_defaultvalue();
  if (defaultvalue_ == NULL) defaultvalue_ = new ::Proto::qvariant;
  return defaultvalue_;
}
inline ::Proto::qvariant* AfbParam::release_defaultvalue() {
  clear_has_defaultvalue();
  ::Proto::qvariant* temp = defaultvalue_;
  defaultvalue_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_defaultvalue(::Proto::qvariant* defaultvalue) {
  delete defaultvalue_;
  defaultvalue_ = defaultvalue;
  if (defaultvalue) {
    set_has_defaultvalue();
  } else {
    clear_has_defaultvalue();
  }
}

// optional .Proto.qvariant lowlimit = 15;
inline bool AfbParam::has_lowlimit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AfbParam::set_has_lowlimit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AfbParam::clear_has_lowlimit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AfbParam::clear_lowlimit() {
  if (lowlimit_ != NULL) lowlimit_->::Proto::qvariant::Clear();
  clear_has_lowlimit();
}
inline const ::Proto::qvariant& AfbParam::lowlimit() const {
  return lowlimit_ != NULL ? *lowlimit_ : *default_instance_->lowlimit_;
}
inline ::Proto::qvariant* AfbParam::mutable_lowlimit() {
  set_has_lowlimit();
  if (lowlimit_ == NULL) lowlimit_ = new ::Proto::qvariant;
  return lowlimit_;
}
inline ::Proto::qvariant* AfbParam::release_lowlimit() {
  clear_has_lowlimit();
  ::Proto::qvariant* temp = lowlimit_;
  lowlimit_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_lowlimit(::Proto::qvariant* lowlimit) {
  delete lowlimit_;
  lowlimit_ = lowlimit;
  if (lowlimit) {
    set_has_lowlimit();
  } else {
    clear_has_lowlimit();
  }
}

// optional .Proto.qvariant highlimit = 16;
inline bool AfbParam::has_highlimit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AfbParam::set_has_highlimit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AfbParam::clear_has_highlimit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AfbParam::clear_highlimit() {
  if (highlimit_ != NULL) highlimit_->::Proto::qvariant::Clear();
  clear_has_highlimit();
}
inline const ::Proto::qvariant& AfbParam::highlimit() const {
  return highlimit_ != NULL ? *highlimit_ : *default_instance_->highlimit_;
}
inline ::Proto::qvariant* AfbParam::mutable_highlimit() {
  set_has_highlimit();
  if (highlimit_ == NULL) highlimit_ = new ::Proto::qvariant;
  return highlimit_;
}
inline ::Proto::qvariant* AfbParam::release_highlimit() {
  clear_has_highlimit();
  ::Proto::qvariant* temp = highlimit_;
  highlimit_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_highlimit(::Proto::qvariant* highlimit) {
  delete highlimit_;
  highlimit_ = highlimit;
  if (highlimit) {
    set_has_highlimit();
  } else {
    clear_has_highlimit();
  }
}

// optional .Proto.wstring opName = 17;
inline bool AfbParam::has_opname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AfbParam::set_has_opname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AfbParam::clear_has_opname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AfbParam::clear_opname() {
  if (opname_ != NULL) opname_->::Proto::wstring::Clear();
  clear_has_opname();
}
inline const ::Proto::wstring& AfbParam::opname() const {
  return opname_ != NULL ? *opname_ : *default_instance_->opname_;
}
inline ::Proto::wstring* AfbParam::mutable_opname() {
  set_has_opname();
  if (opname_ == NULL) opname_ = new ::Proto::wstring;
  return opname_;
}
inline ::Proto::wstring* AfbParam::release_opname() {
  clear_has_opname();
  ::Proto::wstring* temp = opname_;
  opname_ = NULL;
  return temp;
}
inline void AfbParam::set_allocated_opname(::Proto::wstring* opname) {
  delete opname_;
  opname_ = opname;
  if (opname) {
    set_has_opname();
  } else {
    clear_has_opname();
  }
}

// optional .Proto.FblSignalType type = 18;
inline bool AfbParam::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AfbParam::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AfbParam::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AfbParam::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto::FblSignalType AfbParam::type() const {
  return static_cast< ::Proto::FblSignalType >(type_);
}
inline void AfbParam::set_type(::Proto::FblSignalType value) {
  assert(::Proto::FblSignalType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Proto.FblDataFormat dataFormat = 19;
inline bool AfbParam::has_dataformat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AfbParam::set_has_dataformat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AfbParam::clear_has_dataformat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AfbParam::clear_dataformat() {
  dataformat_ = 0;
  clear_has_dataformat();
}
inline ::Proto::FblDataFormat AfbParam::dataformat() const {
  return static_cast< ::Proto::FblDataFormat >(dataformat_);
}
inline void AfbParam::set_dataformat(::Proto::FblDataFormat value) {
  assert(::Proto::FblDataFormat_IsValid(value));
  set_has_dataformat();
  dataformat_ = value;
}

// -------------------------------------------------------------------

// Schema

// required .Proto.Uuid uuid = 1;
inline bool Schema::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Schema::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Schema::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Schema::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Schema::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Schema::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Schema::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Schema::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring schemaID = 2;
inline bool Schema::has_schemaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Schema::set_has_schemaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Schema::clear_has_schemaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Schema::clear_schemaid() {
  if (schemaid_ != NULL) schemaid_->::Proto::wstring::Clear();
  clear_has_schemaid();
}
inline const ::Proto::wstring& Schema::schemaid() const {
  return schemaid_ != NULL ? *schemaid_ : *default_instance_->schemaid_;
}
inline ::Proto::wstring* Schema::mutable_schemaid() {
  set_has_schemaid();
  if (schemaid_ == NULL) schemaid_ = new ::Proto::wstring;
  return schemaid_;
}
inline ::Proto::wstring* Schema::release_schemaid() {
  clear_has_schemaid();
  ::Proto::wstring* temp = schemaid_;
  schemaid_ = NULL;
  return temp;
}
inline void Schema::set_allocated_schemaid(::Proto::wstring* schemaid) {
  delete schemaid_;
  schemaid_ = schemaid;
  if (schemaid) {
    set_has_schemaid();
  } else {
    clear_has_schemaid();
  }
}

// required .Proto.wstring caption = 3;
inline bool Schema::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Schema::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Schema::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Schema::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& Schema::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* Schema::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* Schema::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void Schema::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required double width = 4;
inline bool Schema::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Schema::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Schema::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Schema::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double Schema::width() const {
  return width_;
}
inline void Schema::set_width(double value) {
  set_has_width();
  width_ = value;
}

// required double height = 5;
inline bool Schema::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Schema::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Schema::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Schema::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double Schema::height() const {
  return height_;
}
inline void Schema::set_height(double value) {
  set_has_height();
  height_ = value;
}

// required .Proto.SchemaUnit unit = 6;
inline bool Schema::has_unit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Schema::set_has_unit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Schema::clear_has_unit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Schema::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::Proto::SchemaUnit Schema::unit() const {
  return static_cast< ::Proto::SchemaUnit >(unit_);
}
inline void Schema::set_unit(::Proto::SchemaUnit value) {
  assert(::Proto::SchemaUnit_IsValid(value));
  set_has_unit();
  unit_ = value;
}

// optional bool excludeFromBuild = 7 [default = false];
inline bool Schema::has_excludefrombuild() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Schema::set_has_excludefrombuild() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Schema::clear_has_excludefrombuild() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Schema::clear_excludefrombuild() {
  excludefrombuild_ = false;
  clear_has_excludefrombuild();
}
inline bool Schema::excludefrombuild() const {
  return excludefrombuild_;
}
inline void Schema::set_excludefrombuild(bool value) {
  set_has_excludefrombuild();
  excludefrombuild_ = value;
}

// repeated .Proto.Envelope layers = 100;
inline int Schema::layers_size() const {
  return layers_.size();
}
inline void Schema::clear_layers() {
  layers_.Clear();
}
inline const ::Proto::Envelope& Schema::layers(int index) const {
  return layers_.Get(index);
}
inline ::Proto::Envelope* Schema::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::Proto::Envelope* Schema::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
Schema::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
Schema::mutable_layers() {
  return &layers_;
}

// required .Proto.AfbElementCollection afbs = 101;
inline bool Schema::has_afbs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Schema::set_has_afbs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Schema::clear_has_afbs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Schema::clear_afbs() {
  if (afbs_ != NULL) afbs_->::Proto::AfbElementCollection::Clear();
  clear_has_afbs();
}
inline const ::Proto::AfbElementCollection& Schema::afbs() const {
  return afbs_ != NULL ? *afbs_ : *default_instance_->afbs_;
}
inline ::Proto::AfbElementCollection* Schema::mutable_afbs() {
  set_has_afbs();
  if (afbs_ == NULL) afbs_ = new ::Proto::AfbElementCollection;
  return afbs_;
}
inline ::Proto::AfbElementCollection* Schema::release_afbs() {
  clear_has_afbs();
  ::Proto::AfbElementCollection* temp = afbs_;
  afbs_ = NULL;
  return temp;
}
inline void Schema::set_allocated_afbs(::Proto::AfbElementCollection* afbs) {
  delete afbs_;
  afbs_ = afbs;
  if (afbs) {
    set_has_afbs();
  } else {
    clear_has_afbs();
  }
}

// optional .Proto.LogicSchema logic_schema = 200;
inline bool Schema::has_logic_schema() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Schema::set_has_logic_schema() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Schema::clear_has_logic_schema() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Schema::clear_logic_schema() {
  if (logic_schema_ != NULL) logic_schema_->::Proto::LogicSchema::Clear();
  clear_has_logic_schema();
}
inline const ::Proto::LogicSchema& Schema::logic_schema() const {
  return logic_schema_ != NULL ? *logic_schema_ : *default_instance_->logic_schema_;
}
inline ::Proto::LogicSchema* Schema::mutable_logic_schema() {
  set_has_logic_schema();
  if (logic_schema_ == NULL) logic_schema_ = new ::Proto::LogicSchema;
  return logic_schema_;
}
inline ::Proto::LogicSchema* Schema::release_logic_schema() {
  clear_has_logic_schema();
  ::Proto::LogicSchema* temp = logic_schema_;
  logic_schema_ = NULL;
  return temp;
}
inline void Schema::set_allocated_logic_schema(::Proto::LogicSchema* logic_schema) {
  delete logic_schema_;
  logic_schema_ = logic_schema;
  if (logic_schema) {
    set_has_logic_schema();
  } else {
    clear_has_logic_schema();
  }
}

// -------------------------------------------------------------------

// LogicSchema

// repeated .Proto.wstring equipmentids = 1;
inline int LogicSchema::equipmentids_size() const {
  return equipmentids_.size();
}
inline void LogicSchema::clear_equipmentids() {
  equipmentids_.Clear();
}
inline const ::Proto::wstring& LogicSchema::equipmentids(int index) const {
  return equipmentids_.Get(index);
}
inline ::Proto::wstring* LogicSchema::mutable_equipmentids(int index) {
  return equipmentids_.Mutable(index);
}
inline ::Proto::wstring* LogicSchema::add_equipmentids() {
  return equipmentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
LogicSchema::equipmentids() const {
  return equipmentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
LogicSchema::mutable_equipmentids() {
  return &equipmentids_;
}

// optional int32 counter = 2 [default = 0];
inline bool LogicSchema::has_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicSchema::set_has_counter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicSchema::clear_has_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicSchema::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 LogicSchema::counter() const {
  return counter_;
}
inline void LogicSchema::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
}

// -------------------------------------------------------------------

// SchemaLayer

// required .Proto.Uuid uuid = 1;
inline bool SchemaLayer::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaLayer::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaLayer::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaLayer::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& SchemaLayer::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* SchemaLayer::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* SchemaLayer::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void SchemaLayer::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring name = 2;
inline bool SchemaLayer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaLayer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaLayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaLayer::clear_name() {
  if (name_ != NULL) name_->::Proto::wstring::Clear();
  clear_has_name();
}
inline const ::Proto::wstring& SchemaLayer::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::Proto::wstring* SchemaLayer::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::Proto::wstring;
  return name_;
}
inline ::Proto::wstring* SchemaLayer::release_name() {
  clear_has_name();
  ::Proto::wstring* temp = name_;
  name_ = NULL;
  return temp;
}
inline void SchemaLayer::set_allocated_name(::Proto::wstring* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// required bool compile = 3;
inline bool SchemaLayer::has_compile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaLayer::set_has_compile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaLayer::clear_has_compile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaLayer::clear_compile() {
  compile_ = false;
  clear_has_compile();
}
inline bool SchemaLayer::compile() const {
  return compile_;
}
inline void SchemaLayer::set_compile(bool value) {
  set_has_compile();
  compile_ = value;
}

// required bool show = 4;
inline bool SchemaLayer::has_show() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaLayer::set_has_show() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaLayer::clear_has_show() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaLayer::clear_show() {
  show_ = false;
  clear_has_show();
}
inline bool SchemaLayer::show() const {
  return show_;
}
inline void SchemaLayer::set_show(bool value) {
  set_has_show();
  show_ = value;
}

// required bool print = 5;
inline bool SchemaLayer::has_print() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaLayer::set_has_print() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaLayer::clear_has_print() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaLayer::clear_print() {
  print_ = false;
  clear_has_print();
}
inline bool SchemaLayer::print() const {
  return print_;
}
inline void SchemaLayer::set_print(bool value) {
  set_has_print();
  print_ = value;
}

// repeated .Proto.Envelope items = 15;
inline int SchemaLayer::items_size() const {
  return items_.size();
}
inline void SchemaLayer::clear_items() {
  items_.Clear();
}
inline const ::Proto::Envelope& SchemaLayer::items(int index) const {
  return items_.Get(index);
}
inline ::Proto::Envelope* SchemaLayer::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Proto::Envelope* SchemaLayer::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
SchemaLayer::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
SchemaLayer::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// SchemaItem

// required .Proto.Uuid uuid = 1;
inline bool SchemaItem::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItem::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItem::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItem::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& SchemaItem::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* SchemaItem::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* SchemaItem::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required bool isStatic = 2;
inline bool SchemaItem::has_isstatic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItem::set_has_isstatic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItem::clear_has_isstatic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItem::clear_isstatic() {
  isstatic_ = false;
  clear_has_isstatic();
}
inline bool SchemaItem::isstatic() const {
  return isstatic_;
}
inline void SchemaItem::set_isstatic(bool value) {
  set_has_isstatic();
  isstatic_ = value;
}

// required bool isLocked = 3;
inline bool SchemaItem::has_islocked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItem::set_has_islocked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItem::clear_has_islocked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItem::clear_islocked() {
  islocked_ = false;
  clear_has_islocked();
}
inline bool SchemaItem::islocked() const {
  return islocked_;
}
inline void SchemaItem::set_islocked(bool value) {
  set_has_islocked();
  islocked_ = value;
}

// required .Proto.SchemaUnit itemUnit = 4;
inline bool SchemaItem::has_itemunit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItem::set_has_itemunit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItem::clear_has_itemunit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItem::clear_itemunit() {
  itemunit_ = 0;
  clear_has_itemunit();
}
inline ::Proto::SchemaUnit SchemaItem::itemunit() const {
  return static_cast< ::Proto::SchemaUnit >(itemunit_);
}
inline void SchemaItem::set_itemunit(::Proto::SchemaUnit value) {
  assert(::Proto::SchemaUnit_IsValid(value));
  set_has_itemunit();
  itemunit_ = value;
}

// optional bool acceptClick = 5 [default = false];
inline bool SchemaItem::has_acceptclick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItem::set_has_acceptclick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItem::clear_has_acceptclick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItem::clear_acceptclick() {
  acceptclick_ = false;
  clear_has_acceptclick();
}
inline bool SchemaItem::acceptclick() const {
  return acceptclick_;
}
inline void SchemaItem::set_acceptclick(bool value) {
  set_has_acceptclick();
  acceptclick_ = value;
}

// optional .Proto.wstring clickScript = 6;
inline bool SchemaItem::has_clickscript() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItem::set_has_clickscript() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItem::clear_has_clickscript() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItem::clear_clickscript() {
  if (clickscript_ != NULL) clickscript_->::Proto::wstring::Clear();
  clear_has_clickscript();
}
inline const ::Proto::wstring& SchemaItem::clickscript() const {
  return clickscript_ != NULL ? *clickscript_ : *default_instance_->clickscript_;
}
inline ::Proto::wstring* SchemaItem::mutable_clickscript() {
  set_has_clickscript();
  if (clickscript_ == NULL) clickscript_ = new ::Proto::wstring;
  return clickscript_;
}
inline ::Proto::wstring* SchemaItem::release_clickscript() {
  clear_has_clickscript();
  ::Proto::wstring* temp = clickscript_;
  clickscript_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_clickscript(::Proto::wstring* clickscript) {
  delete clickscript_;
  clickscript_ = clickscript;
  if (clickscript) {
    set_has_clickscript();
  } else {
    clear_has_clickscript();
  }
}

// optional .Proto.PosRectImpl PosRectImpl = 10;
inline bool SchemaItem::has_posrectimpl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItem::set_has_posrectimpl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItem::clear_has_posrectimpl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItem::clear_posrectimpl() {
  if (posrectimpl_ != NULL) posrectimpl_->::Proto::PosRectImpl::Clear();
  clear_has_posrectimpl();
}
inline const ::Proto::PosRectImpl& SchemaItem::posrectimpl() const {
  return posrectimpl_ != NULL ? *posrectimpl_ : *default_instance_->posrectimpl_;
}
inline ::Proto::PosRectImpl* SchemaItem::mutable_posrectimpl() {
  set_has_posrectimpl();
  if (posrectimpl_ == NULL) posrectimpl_ = new ::Proto::PosRectImpl;
  return posrectimpl_;
}
inline ::Proto::PosRectImpl* SchemaItem::release_posrectimpl() {
  clear_has_posrectimpl();
  ::Proto::PosRectImpl* temp = posrectimpl_;
  posrectimpl_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_posrectimpl(::Proto::PosRectImpl* posrectimpl) {
  delete posrectimpl_;
  posrectimpl_ = posrectimpl;
  if (posrectimpl) {
    set_has_posrectimpl();
  } else {
    clear_has_posrectimpl();
  }
}

// optional .Proto.PosLineImpl PosLineImpl = 11;
inline bool SchemaItem::has_poslineimpl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItem::set_has_poslineimpl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItem::clear_has_poslineimpl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItem::clear_poslineimpl() {
  if (poslineimpl_ != NULL) poslineimpl_->::Proto::PosLineImpl::Clear();
  clear_has_poslineimpl();
}
inline const ::Proto::PosLineImpl& SchemaItem::poslineimpl() const {
  return poslineimpl_ != NULL ? *poslineimpl_ : *default_instance_->poslineimpl_;
}
inline ::Proto::PosLineImpl* SchemaItem::mutable_poslineimpl() {
  set_has_poslineimpl();
  if (poslineimpl_ == NULL) poslineimpl_ = new ::Proto::PosLineImpl;
  return poslineimpl_;
}
inline ::Proto::PosLineImpl* SchemaItem::release_poslineimpl() {
  clear_has_poslineimpl();
  ::Proto::PosLineImpl* temp = poslineimpl_;
  poslineimpl_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_poslineimpl(::Proto::PosLineImpl* poslineimpl) {
  delete poslineimpl_;
  poslineimpl_ = poslineimpl;
  if (poslineimpl) {
    set_has_poslineimpl();
  } else {
    clear_has_poslineimpl();
  }
}

// optional .Proto.PosConnectionImpl PosConnectionImpl = 12;
inline bool SchemaItem::has_posconnectionimpl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItem::set_has_posconnectionimpl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItem::clear_has_posconnectionimpl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItem::clear_posconnectionimpl() {
  if (posconnectionimpl_ != NULL) posconnectionimpl_->::Proto::PosConnectionImpl::Clear();
  clear_has_posconnectionimpl();
}
inline const ::Proto::PosConnectionImpl& SchemaItem::posconnectionimpl() const {
  return posconnectionimpl_ != NULL ? *posconnectionimpl_ : *default_instance_->posconnectionimpl_;
}
inline ::Proto::PosConnectionImpl* SchemaItem::mutable_posconnectionimpl() {
  set_has_posconnectionimpl();
  if (posconnectionimpl_ == NULL) posconnectionimpl_ = new ::Proto::PosConnectionImpl;
  return posconnectionimpl_;
}
inline ::Proto::PosConnectionImpl* SchemaItem::release_posconnectionimpl() {
  clear_has_posconnectionimpl();
  ::Proto::PosConnectionImpl* temp = posconnectionimpl_;
  posconnectionimpl_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_posconnectionimpl(::Proto::PosConnectionImpl* posconnectionimpl) {
  delete posconnectionimpl_;
  posconnectionimpl_ = posconnectionimpl;
  if (posconnectionimpl) {
    set_has_posconnectionimpl();
  } else {
    clear_has_posconnectionimpl();
  }
}

// optional .Proto.FblItem FblItem = 106;
inline bool SchemaItem::has_fblitem() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItem::set_has_fblitem() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItem::clear_has_fblitem() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItem::clear_fblitem() {
  if (fblitem_ != NULL) fblitem_->::Proto::FblItem::Clear();
  clear_has_fblitem();
}
inline const ::Proto::FblItem& SchemaItem::fblitem() const {
  return fblitem_ != NULL ? *fblitem_ : *default_instance_->fblitem_;
}
inline ::Proto::FblItem* SchemaItem::mutable_fblitem() {
  set_has_fblitem();
  if (fblitem_ == NULL) fblitem_ = new ::Proto::FblItem;
  return fblitem_;
}
inline ::Proto::FblItem* SchemaItem::release_fblitem() {
  clear_has_fblitem();
  ::Proto::FblItem* temp = fblitem_;
  fblitem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_fblitem(::Proto::FblItem* fblitem) {
  delete fblitem_;
  fblitem_ = fblitem;
  if (fblitem) {
    set_has_fblitem();
  } else {
    clear_has_fblitem();
  }
}

// optional .Proto.FblItemRect FblItemRect = 107;
inline bool SchemaItem::has_fblitemrect() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SchemaItem::set_has_fblitemrect() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SchemaItem::clear_has_fblitemrect() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SchemaItem::clear_fblitemrect() {
  if (fblitemrect_ != NULL) fblitemrect_->::Proto::FblItemRect::Clear();
  clear_has_fblitemrect();
}
inline const ::Proto::FblItemRect& SchemaItem::fblitemrect() const {
  return fblitemrect_ != NULL ? *fblitemrect_ : *default_instance_->fblitemrect_;
}
inline ::Proto::FblItemRect* SchemaItem::mutable_fblitemrect() {
  set_has_fblitemrect();
  if (fblitemrect_ == NULL) fblitemrect_ = new ::Proto::FblItemRect;
  return fblitemrect_;
}
inline ::Proto::FblItemRect* SchemaItem::release_fblitemrect() {
  clear_has_fblitemrect();
  ::Proto::FblItemRect* temp = fblitemrect_;
  fblitemrect_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_fblitemrect(::Proto::FblItemRect* fblitemrect) {
  delete fblitemrect_;
  fblitemrect_ = fblitemrect;
  if (fblitemrect) {
    set_has_fblitemrect();
  } else {
    clear_has_fblitemrect();
  }
}

// optional .Proto.FblItemLine FblItemLine = 108;
inline bool SchemaItem::has_fblitemline() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SchemaItem::set_has_fblitemline() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SchemaItem::clear_has_fblitemline() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SchemaItem::clear_fblitemline() {
  if (fblitemline_ != NULL) fblitemline_->::Proto::FblItemLine::Clear();
  clear_has_fblitemline();
}
inline const ::Proto::FblItemLine& SchemaItem::fblitemline() const {
  return fblitemline_ != NULL ? *fblitemline_ : *default_instance_->fblitemline_;
}
inline ::Proto::FblItemLine* SchemaItem::mutable_fblitemline() {
  set_has_fblitemline();
  if (fblitemline_ == NULL) fblitemline_ = new ::Proto::FblItemLine;
  return fblitemline_;
}
inline ::Proto::FblItemLine* SchemaItem::release_fblitemline() {
  clear_has_fblitemline();
  ::Proto::FblItemLine* temp = fblitemline_;
  fblitemline_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_fblitemline(::Proto::FblItemLine* fblitemline) {
  delete fblitemline_;
  fblitemline_ = fblitemline;
  if (fblitemline) {
    set_has_fblitemline();
  } else {
    clear_has_fblitemline();
  }
}

// optional .Proto.SchemaItemRect Rect = 116;
inline bool SchemaItem::has_rect() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SchemaItem::set_has_rect() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SchemaItem::clear_has_rect() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SchemaItem::clear_rect() {
  if (rect_ != NULL) rect_->::Proto::SchemaItemRect::Clear();
  clear_has_rect();
}
inline const ::Proto::SchemaItemRect& SchemaItem::rect() const {
  return rect_ != NULL ? *rect_ : *default_instance_->rect_;
}
inline ::Proto::SchemaItemRect* SchemaItem::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) rect_ = new ::Proto::SchemaItemRect;
  return rect_;
}
inline ::Proto::SchemaItemRect* SchemaItem::release_rect() {
  clear_has_rect();
  ::Proto::SchemaItemRect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_rect(::Proto::SchemaItemRect* rect) {
  delete rect_;
  rect_ = rect;
  if (rect) {
    set_has_rect();
  } else {
    clear_has_rect();
  }
}

// optional .Proto.SchemaItemLine Line = 117;
inline bool SchemaItem::has_line() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SchemaItem::set_has_line() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SchemaItem::clear_has_line() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SchemaItem::clear_line() {
  if (line_ != NULL) line_->::Proto::SchemaItemLine::Clear();
  clear_has_line();
}
inline const ::Proto::SchemaItemLine& SchemaItem::line() const {
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::Proto::SchemaItemLine* SchemaItem::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::Proto::SchemaItemLine;
  return line_;
}
inline ::Proto::SchemaItemLine* SchemaItem::release_line() {
  clear_has_line();
  ::Proto::SchemaItemLine* temp = line_;
  line_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_line(::Proto::SchemaItemLine* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
}

// optional .Proto.SchemaItemPath Path = 118;
inline bool SchemaItem::has_path() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SchemaItem::set_has_path() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SchemaItem::clear_has_path() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SchemaItem::clear_path() {
  if (path_ != NULL) path_->::Proto::SchemaItemPath::Clear();
  clear_has_path();
}
inline const ::Proto::SchemaItemPath& SchemaItem::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::Proto::SchemaItemPath* SchemaItem::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::Proto::SchemaItemPath;
  return path_;
}
inline ::Proto::SchemaItemPath* SchemaItem::release_path() {
  clear_has_path();
  ::Proto::SchemaItemPath* temp = path_;
  path_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_path(::Proto::SchemaItemPath* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
}

// optional .Proto.SchemaItemSignal Signal = 124;
inline bool SchemaItem::has_signal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SchemaItem::set_has_signal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SchemaItem::clear_has_signal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SchemaItem::clear_signal() {
  if (signal_ != NULL) signal_->::Proto::SchemaItemSignal::Clear();
  clear_has_signal();
}
inline const ::Proto::SchemaItemSignal& SchemaItem::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Proto::SchemaItemSignal* SchemaItem::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Proto::SchemaItemSignal;
  return signal_;
}
inline ::Proto::SchemaItemSignal* SchemaItem::release_signal() {
  clear_has_signal();
  ::Proto::SchemaItemSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_signal(::Proto::SchemaItemSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Proto.SchemaItemInput InputSignal = 125;
inline bool SchemaItem::has_inputsignal() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SchemaItem::set_has_inputsignal() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SchemaItem::clear_has_inputsignal() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SchemaItem::clear_inputsignal() {
  if (inputsignal_ != NULL) inputsignal_->::Proto::SchemaItemInput::Clear();
  clear_has_inputsignal();
}
inline const ::Proto::SchemaItemInput& SchemaItem::inputsignal() const {
  return inputsignal_ != NULL ? *inputsignal_ : *default_instance_->inputsignal_;
}
inline ::Proto::SchemaItemInput* SchemaItem::mutable_inputsignal() {
  set_has_inputsignal();
  if (inputsignal_ == NULL) inputsignal_ = new ::Proto::SchemaItemInput;
  return inputsignal_;
}
inline ::Proto::SchemaItemInput* SchemaItem::release_inputsignal() {
  clear_has_inputsignal();
  ::Proto::SchemaItemInput* temp = inputsignal_;
  inputsignal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_inputsignal(::Proto::SchemaItemInput* inputsignal) {
  delete inputsignal_;
  inputsignal_ = inputsignal;
  if (inputsignal) {
    set_has_inputsignal();
  } else {
    clear_has_inputsignal();
  }
}

// optional .Proto.SchemaItemOutput OutputSignal = 126;
inline bool SchemaItem::has_outputsignal() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SchemaItem::set_has_outputsignal() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SchemaItem::clear_has_outputsignal() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SchemaItem::clear_outputsignal() {
  if (outputsignal_ != NULL) outputsignal_->::Proto::SchemaItemOutput::Clear();
  clear_has_outputsignal();
}
inline const ::Proto::SchemaItemOutput& SchemaItem::outputsignal() const {
  return outputsignal_ != NULL ? *outputsignal_ : *default_instance_->outputsignal_;
}
inline ::Proto::SchemaItemOutput* SchemaItem::mutable_outputsignal() {
  set_has_outputsignal();
  if (outputsignal_ == NULL) outputsignal_ = new ::Proto::SchemaItemOutput;
  return outputsignal_;
}
inline ::Proto::SchemaItemOutput* SchemaItem::release_outputsignal() {
  clear_has_outputsignal();
  ::Proto::SchemaItemOutput* temp = outputsignal_;
  outputsignal_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_outputsignal(::Proto::SchemaItemOutput* outputsignal) {
  delete outputsignal_;
  outputsignal_ = outputsignal;
  if (outputsignal) {
    set_has_outputsignal();
  } else {
    clear_has_outputsignal();
  }
}

// optional .Proto.SchemaItemLink Link = 127;
inline bool SchemaItem::has_link() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SchemaItem::set_has_link() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SchemaItem::clear_has_link() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SchemaItem::clear_link() {
  if (link_ != NULL) link_->::Proto::SchemaItemLink::Clear();
  clear_has_link();
}
inline const ::Proto::SchemaItemLink& SchemaItem::link() const {
  return link_ != NULL ? *link_ : *default_instance_->link_;
}
inline ::Proto::SchemaItemLink* SchemaItem::mutable_link() {
  set_has_link();
  if (link_ == NULL) link_ = new ::Proto::SchemaItemLink;
  return link_;
}
inline ::Proto::SchemaItemLink* SchemaItem::release_link() {
  clear_has_link();
  ::Proto::SchemaItemLink* temp = link_;
  link_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_link(::Proto::SchemaItemLink* link) {
  delete link_;
  link_ = link;
  if (link) {
    set_has_link();
  } else {
    clear_has_link();
  }
}

// optional .Proto.SchemaItemAfb Afb = 128;
inline bool SchemaItem::has_afb() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SchemaItem::set_has_afb() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SchemaItem::clear_has_afb() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SchemaItem::clear_afb() {
  if (afb_ != NULL) afb_->::Proto::SchemaItemAfb::Clear();
  clear_has_afb();
}
inline const ::Proto::SchemaItemAfb& SchemaItem::afb() const {
  return afb_ != NULL ? *afb_ : *default_instance_->afb_;
}
inline ::Proto::SchemaItemAfb* SchemaItem::mutable_afb() {
  set_has_afb();
  if (afb_ == NULL) afb_ = new ::Proto::SchemaItemAfb;
  return afb_;
}
inline ::Proto::SchemaItemAfb* SchemaItem::release_afb() {
  clear_has_afb();
  ::Proto::SchemaItemAfb* temp = afb_;
  afb_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_afb(::Proto::SchemaItemAfb* afb) {
  delete afb_;
  afb_ = afb;
  if (afb) {
    set_has_afb();
  } else {
    clear_has_afb();
  }
}

// optional .Proto.SchemaItemConst ConstItem = 129;
inline bool SchemaItem::has_constitem() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SchemaItem::set_has_constitem() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SchemaItem::clear_has_constitem() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SchemaItem::clear_constitem() {
  if (constitem_ != NULL) constitem_->::Proto::SchemaItemConst::Clear();
  clear_has_constitem();
}
inline const ::Proto::SchemaItemConst& SchemaItem::constitem() const {
  return constitem_ != NULL ? *constitem_ : *default_instance_->constitem_;
}
inline ::Proto::SchemaItemConst* SchemaItem::mutable_constitem() {
  set_has_constitem();
  if (constitem_ == NULL) constitem_ = new ::Proto::SchemaItemConst;
  return constitem_;
}
inline ::Proto::SchemaItemConst* SchemaItem::release_constitem() {
  clear_has_constitem();
  ::Proto::SchemaItemConst* temp = constitem_;
  constitem_ = NULL;
  return temp;
}
inline void SchemaItem::set_allocated_constitem(::Proto::SchemaItemConst* constitem) {
  delete constitem_;
  constitem_ = constitem;
  if (constitem) {
    set_has_constitem();
  } else {
    clear_has_constitem();
  }
}

// -------------------------------------------------------------------

// PosRectImpl

// required double leftDocPt = 1;
inline bool PosRectImpl::has_leftdocpt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosRectImpl::set_has_leftdocpt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosRectImpl::clear_has_leftdocpt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosRectImpl::clear_leftdocpt() {
  leftdocpt_ = 0;
  clear_has_leftdocpt();
}
inline double PosRectImpl::leftdocpt() const {
  return leftdocpt_;
}
inline void PosRectImpl::set_leftdocpt(double value) {
  set_has_leftdocpt();
  leftdocpt_ = value;
}

// required double topDocPt = 2;
inline bool PosRectImpl::has_topdocpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosRectImpl::set_has_topdocpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosRectImpl::clear_has_topdocpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosRectImpl::clear_topdocpt() {
  topdocpt_ = 0;
  clear_has_topdocpt();
}
inline double PosRectImpl::topdocpt() const {
  return topdocpt_;
}
inline void PosRectImpl::set_topdocpt(double value) {
  set_has_topdocpt();
  topdocpt_ = value;
}

// required double widthDocPt = 3;
inline bool PosRectImpl::has_widthdocpt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosRectImpl::set_has_widthdocpt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosRectImpl::clear_has_widthdocpt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosRectImpl::clear_widthdocpt() {
  widthdocpt_ = 0;
  clear_has_widthdocpt();
}
inline double PosRectImpl::widthdocpt() const {
  return widthdocpt_;
}
inline void PosRectImpl::set_widthdocpt(double value) {
  set_has_widthdocpt();
  widthdocpt_ = value;
}

// required double heightDocPt = 4;
inline bool PosRectImpl::has_heightdocpt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosRectImpl::set_has_heightdocpt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosRectImpl::clear_has_heightdocpt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosRectImpl::clear_heightdocpt() {
  heightdocpt_ = 0;
  clear_has_heightdocpt();
}
inline double PosRectImpl::heightdocpt() const {
  return heightdocpt_;
}
inline void PosRectImpl::set_heightdocpt(double value) {
  set_has_heightdocpt();
  heightdocpt_ = value;
}

// -------------------------------------------------------------------

// PosLineImpl

// required double startXDocPt = 1;
inline bool PosLineImpl::has_startxdocpt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosLineImpl::set_has_startxdocpt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosLineImpl::clear_has_startxdocpt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosLineImpl::clear_startxdocpt() {
  startxdocpt_ = 0;
  clear_has_startxdocpt();
}
inline double PosLineImpl::startxdocpt() const {
  return startxdocpt_;
}
inline void PosLineImpl::set_startxdocpt(double value) {
  set_has_startxdocpt();
  startxdocpt_ = value;
}

// required double startYDocPt = 2;
inline bool PosLineImpl::has_startydocpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosLineImpl::set_has_startydocpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosLineImpl::clear_has_startydocpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosLineImpl::clear_startydocpt() {
  startydocpt_ = 0;
  clear_has_startydocpt();
}
inline double PosLineImpl::startydocpt() const {
  return startydocpt_;
}
inline void PosLineImpl::set_startydocpt(double value) {
  set_has_startydocpt();
  startydocpt_ = value;
}

// required double endXDocPt = 3;
inline bool PosLineImpl::has_endxdocpt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosLineImpl::set_has_endxdocpt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosLineImpl::clear_has_endxdocpt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosLineImpl::clear_endxdocpt() {
  endxdocpt_ = 0;
  clear_has_endxdocpt();
}
inline double PosLineImpl::endxdocpt() const {
  return endxdocpt_;
}
inline void PosLineImpl::set_endxdocpt(double value) {
  set_has_endxdocpt();
  endxdocpt_ = value;
}

// required double endYDocPt = 4;
inline bool PosLineImpl::has_endydocpt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosLineImpl::set_has_endydocpt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosLineImpl::clear_has_endydocpt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosLineImpl::clear_endydocpt() {
  endydocpt_ = 0;
  clear_has_endydocpt();
}
inline double PosLineImpl::endydocpt() const {
  return endydocpt_;
}
inline void PosLineImpl::set_endydocpt(double value) {
  set_has_endydocpt();
  endydocpt_ = value;
}

// -------------------------------------------------------------------

// PosConnectionImpl

// repeated .Proto.SchemaPoint points = 1;
inline int PosConnectionImpl::points_size() const {
  return points_.size();
}
inline void PosConnectionImpl::clear_points() {
  points_.Clear();
}
inline const ::Proto::SchemaPoint& PosConnectionImpl::points(int index) const {
  return points_.Get(index);
}
inline ::Proto::SchemaPoint* PosConnectionImpl::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::Proto::SchemaPoint* PosConnectionImpl::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >&
PosConnectionImpl::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemaPoint >*
PosConnectionImpl::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// SchemaItemRect

// required double weight = 1;
inline bool SchemaItemRect::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemRect::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemRect::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemRect::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemRect::weight() const {
  return weight_;
}
inline void SchemaItemRect::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemaItemRect::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemRect::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemRect::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemRect::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemRect::linecolor() const {
  return linecolor_;
}
inline void SchemaItemRect::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// required uint32 fillColor = 3;
inline bool SchemaItemRect::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemRect::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemRect::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemRect::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 SchemaItemRect::fillcolor() const {
  return fillcolor_;
}
inline void SchemaItemRect::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// required .Proto.wstring text = 4;
inline bool SchemaItemRect::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemRect::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemRect::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemRect::clear_text() {
  if (text_ != NULL) text_->::Proto::wstring::Clear();
  clear_has_text();
}
inline const ::Proto::wstring& SchemaItemRect::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::Proto::wstring* SchemaItemRect::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::Proto::wstring;
  return text_;
}
inline ::Proto::wstring* SchemaItemRect::release_text() {
  clear_has_text();
  ::Proto::wstring* temp = text_;
  text_ = NULL;
  return temp;
}
inline void SchemaItemRect::set_allocated_text(::Proto::wstring* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// required uint32 textColor = 5;
inline bool SchemaItemRect::has_textcolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemaItemRect::set_has_textcolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemaItemRect::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemaItemRect::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 SchemaItemRect::textcolor() const {
  return textcolor_;
}
inline void SchemaItemRect::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// required .Proto.FontParam font = 6;
inline bool SchemaItemRect::has_font() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemaItemRect::set_has_font() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemaItemRect::clear_has_font() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemaItemRect::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& SchemaItemRect::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* SchemaItemRect::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* SchemaItemRect::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void SchemaItemRect::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// required bool fill = 7;
inline bool SchemaItemRect::has_fill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemaItemRect::set_has_fill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemaItemRect::clear_has_fill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemaItemRect::clear_fill() {
  fill_ = false;
  clear_has_fill();
}
inline bool SchemaItemRect::fill() const {
  return fill_;
}
inline void SchemaItemRect::set_fill(bool value) {
  set_has_fill();
  fill_ = value;
}

// optional bool drawrect = 8 [default = true];
inline bool SchemaItemRect::has_drawrect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemaItemRect::set_has_drawrect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemaItemRect::clear_has_drawrect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemaItemRect::clear_drawrect() {
  drawrect_ = true;
  clear_has_drawrect();
}
inline bool SchemaItemRect::drawrect() const {
  return drawrect_;
}
inline void SchemaItemRect::set_drawrect(bool value) {
  set_has_drawrect();
  drawrect_ = value;
}

// optional int32 horzAlign = 9 [default = 4];
inline bool SchemaItemRect::has_horzalign() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemaItemRect::set_has_horzalign() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemaItemRect::clear_has_horzalign() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemaItemRect::clear_horzalign() {
  horzalign_ = 4;
  clear_has_horzalign();
}
inline ::google::protobuf::int32 SchemaItemRect::horzalign() const {
  return horzalign_;
}
inline void SchemaItemRect::set_horzalign(::google::protobuf::int32 value) {
  set_has_horzalign();
  horzalign_ = value;
}

// optional int32 vertAlign = 10 [default = 128];
inline bool SchemaItemRect::has_vertalign() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemaItemRect::set_has_vertalign() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemaItemRect::clear_has_vertalign() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemaItemRect::clear_vertalign() {
  vertalign_ = 128;
  clear_has_vertalign();
}
inline ::google::protobuf::int32 SchemaItemRect::vertalign() const {
  return vertalign_;
}
inline void SchemaItemRect::set_vertalign(::google::protobuf::int32 value) {
  set_has_vertalign();
  vertalign_ = value;
}

// -------------------------------------------------------------------

// SchemaItemLine

// required double weight = 1;
inline bool SchemaItemLine::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemLine::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemLine::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemLine::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemLine::weight() const {
  return weight_;
}
inline void SchemaItemLine::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemaItemLine::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemLine::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemLine::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemLine::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemLine::linecolor() const {
  return linecolor_;
}
inline void SchemaItemLine::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// SchemaItemPath

// required double weight = 1;
inline bool SchemaItemPath::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemPath::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemPath::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemPath::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemaItemPath::weight() const {
  return weight_;
}
inline void SchemaItemPath::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemaItemPath::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemPath::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemPath::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemPath::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemaItemPath::linecolor() const {
  return linecolor_;
}
inline void SchemaItemPath::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// FblConnectionPoint

// optional .Proto.SchemaPoint point = 1;
inline bool FblConnectionPoint::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblConnectionPoint::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblConnectionPoint::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblConnectionPoint::clear_point() {
  if (point_ != NULL) point_->::Proto::SchemaPoint::Clear();
  clear_has_point();
}
inline const ::Proto::SchemaPoint& FblConnectionPoint::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::Proto::SchemaPoint* FblConnectionPoint::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::Proto::SchemaPoint;
  return point_;
}
inline ::Proto::SchemaPoint* FblConnectionPoint::release_point() {
  clear_has_point();
  ::Proto::SchemaPoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void FblConnectionPoint::set_allocated_point(::Proto::SchemaPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// optional .Proto.ConnectionDirrection dirrection = 2;
inline bool FblConnectionPoint::has_dirrection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblConnectionPoint::set_has_dirrection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblConnectionPoint::clear_has_dirrection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblConnectionPoint::clear_dirrection() {
  dirrection_ = 0;
  clear_has_dirrection();
}
inline ::Proto::ConnectionDirrection FblConnectionPoint::dirrection() const {
  return static_cast< ::Proto::ConnectionDirrection >(dirrection_);
}
inline void FblConnectionPoint::set_dirrection(::Proto::ConnectionDirrection value) {
  assert(::Proto::ConnectionDirrection_IsValid(value));
  set_has_dirrection();
  dirrection_ = value;
}

// optional .Proto.Uuid uuid = 3;
inline bool FblConnectionPoint::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblConnectionPoint::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblConnectionPoint::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblConnectionPoint::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& FblConnectionPoint::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* FblConnectionPoint::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* FblConnectionPoint::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void FblConnectionPoint::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// optional int32 operandIndex = 4 [default = -1];
inline bool FblConnectionPoint::has_operandindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblConnectionPoint::set_has_operandindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblConnectionPoint::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblConnectionPoint::clear_operandindex() {
  operandindex_ = -1;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 FblConnectionPoint::operandindex() const {
  return operandindex_;
}
inline void FblConnectionPoint::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional string caption = 5 [default = ""];
inline bool FblConnectionPoint::has_caption() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblConnectionPoint::set_has_caption() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblConnectionPoint::clear_has_caption() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblConnectionPoint::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& FblConnectionPoint::caption() const {
  return *caption_;
}
inline void FblConnectionPoint::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void FblConnectionPoint::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void FblConnectionPoint::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FblConnectionPoint::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* FblConnectionPoint::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FblConnectionPoint::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FblItem

// repeated .Proto.FblConnectionPoint points = 1;
inline int FblItem::points_size() const {
  return points_.size();
}
inline void FblItem::clear_points() {
  points_.Clear();
}
inline const ::Proto::FblConnectionPoint& FblItem::points(int index) const {
  return points_.Get(index);
}
inline ::Proto::FblConnectionPoint* FblItem::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::Proto::FblConnectionPoint* FblItem::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >&
FblItem::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >*
FblItem::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// FblItemRect

// required double weight = 1;
inline bool FblItemRect::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblItemRect::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblItemRect::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblItemRect::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double FblItemRect::weight() const {
  return weight_;
}
inline void FblItemRect::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool FblItemRect::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblItemRect::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblItemRect::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblItemRect::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 FblItemRect::linecolor() const {
  return linecolor_;
}
inline void FblItemRect::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// required uint32 fillColor = 3;
inline bool FblItemRect::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblItemRect::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblItemRect::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblItemRect::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 FblItemRect::fillcolor() const {
  return fillcolor_;
}
inline void FblItemRect::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// required uint32 textColor = 4;
inline bool FblItemRect::has_textcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblItemRect::set_has_textcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblItemRect::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblItemRect::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 FblItemRect::textcolor() const {
  return textcolor_;
}
inline void FblItemRect::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// required .Proto.FontParam font = 5;
inline bool FblItemRect::has_font() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblItemRect::set_has_font() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblItemRect::clear_has_font() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblItemRect::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& FblItemRect::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* FblItemRect::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* FblItemRect::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void FblItemRect::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// -------------------------------------------------------------------

// FblItemLine

// required double weight = 1;
inline bool FblItemLine::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblItemLine::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblItemLine::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblItemLine::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double FblItemLine::weight() const {
  return weight_;
}
inline void FblItemLine::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool FblItemLine::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblItemLine::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblItemLine::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblItemLine::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 FblItemLine::linecolor() const {
  return linecolor_;
}
inline void FblItemLine::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// SchemaItemSignal

// repeated .Proto.wstring appSignalIDs = 1;
inline int SchemaItemSignal::appsignalids_size() const {
  return appsignalids_.size();
}
inline void SchemaItemSignal::clear_appsignalids() {
  appsignalids_.Clear();
}
inline const ::Proto::wstring& SchemaItemSignal::appsignalids(int index) const {
  return appsignalids_.Get(index);
}
inline ::Proto::wstring* SchemaItemSignal::mutable_appsignalids(int index) {
  return appsignalids_.Mutable(index);
}
inline ::Proto::wstring* SchemaItemSignal::add_appsignalids() {
  return appsignalids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
SchemaItemSignal::appsignalids() const {
  return appsignalids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
SchemaItemSignal::mutable_appsignalids() {
  return &appsignalids_;
}

// -------------------------------------------------------------------

// SchemaItemInput

// -------------------------------------------------------------------

// SchemaItemOutput

// -------------------------------------------------------------------

// SchemaItemLink

// -------------------------------------------------------------------

// SchemaItemAfb

// repeated .Proto.AfbParam params = 2;
inline int SchemaItemAfb::params_size() const {
  return params_.size();
}
inline void SchemaItemAfb::clear_params() {
  params_.Clear();
}
inline const ::Proto::AfbParam& SchemaItemAfb::params(int index) const {
  return params_.Get(index);
}
inline ::Proto::AfbParam* SchemaItemAfb::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Proto::AfbParam* SchemaItemAfb::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >&
SchemaItemAfb::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbParam >*
SchemaItemAfb::mutable_params() {
  return &params_;
}

// optional .Proto.wstring afbStrid = 3;
inline bool SchemaItemAfb::has_afbstrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemAfb::set_has_afbstrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemAfb::clear_has_afbstrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemAfb::clear_afbstrid() {
  if (afbstrid_ != NULL) afbstrid_->::Proto::wstring::Clear();
  clear_has_afbstrid();
}
inline const ::Proto::wstring& SchemaItemAfb::afbstrid() const {
  return afbstrid_ != NULL ? *afbstrid_ : *default_instance_->afbstrid_;
}
inline ::Proto::wstring* SchemaItemAfb::mutable_afbstrid() {
  set_has_afbstrid();
  if (afbstrid_ == NULL) afbstrid_ = new ::Proto::wstring;
  return afbstrid_;
}
inline ::Proto::wstring* SchemaItemAfb::release_afbstrid() {
  clear_has_afbstrid();
  ::Proto::wstring* temp = afbstrid_;
  afbstrid_ = NULL;
  return temp;
}
inline void SchemaItemAfb::set_allocated_afbstrid(::Proto::wstring* afbstrid) {
  delete afbstrid_;
  afbstrid_ = afbstrid;
  if (afbstrid) {
    set_has_afbstrid();
  } else {
    clear_has_afbstrid();
  }
}

// optional int32 precision = 4 [default = 2];
inline bool SchemaItemAfb::has_precision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemAfb::set_has_precision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemAfb::clear_has_precision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemAfb::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemAfb::precision() const {
  return precision_;
}
inline void SchemaItemAfb::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// optional .Proto.AfbElementXml afbelement = 5;
inline bool SchemaItemAfb::has_afbelement() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemAfb::set_has_afbelement() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemAfb::clear_has_afbelement() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemAfb::clear_afbelement() {
  if (afbelement_ != NULL) afbelement_->::Proto::AfbElementXml::Clear();
  clear_has_afbelement();
}
inline const ::Proto::AfbElementXml& SchemaItemAfb::afbelement() const {
  return afbelement_ != NULL ? *afbelement_ : *default_instance_->afbelement_;
}
inline ::Proto::AfbElementXml* SchemaItemAfb::mutable_afbelement() {
  set_has_afbelement();
  if (afbelement_ == NULL) afbelement_ = new ::Proto::AfbElementXml;
  return afbelement_;
}
inline ::Proto::AfbElementXml* SchemaItemAfb::release_afbelement() {
  clear_has_afbelement();
  ::Proto::AfbElementXml* temp = afbelement_;
  afbelement_ = NULL;
  return temp;
}
inline void SchemaItemAfb::set_allocated_afbelement(::Proto::AfbElementXml* afbelement) {
  delete afbelement_;
  afbelement_ = afbelement;
  if (afbelement) {
    set_has_afbelement();
  } else {
    clear_has_afbelement();
  }
}

// -------------------------------------------------------------------

// SchemaItemConst

// optional int32 type = 1 [default = 0];
inline bool SchemaItemConst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemaItemConst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemaItemConst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemaItemConst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SchemaItemConst::type() const {
  return type_;
}
inline void SchemaItemConst::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 intValue = 2 [default = 0];
inline bool SchemaItemConst::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemaItemConst::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemaItemConst::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemaItemConst::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 SchemaItemConst::intvalue() const {
  return intvalue_;
}
inline void SchemaItemConst::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional double floatValue = 3 [default = 0];
inline bool SchemaItemConst::has_floatvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemaItemConst::set_has_floatvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemaItemConst::clear_has_floatvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemaItemConst::clear_floatvalue() {
  floatvalue_ = 0;
  clear_has_floatvalue();
}
inline double SchemaItemConst::floatvalue() const {
  return floatvalue_;
}
inline void SchemaItemConst::set_floatvalue(double value) {
  set_has_floatvalue();
  floatvalue_ = value;
}

// optional int32 precision = 4 [default = 2];
inline bool SchemaItemConst::has_precision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemaItemConst::set_has_precision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemaItemConst::clear_has_precision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemaItemConst::clear_precision() {
  precision_ = 2;
  clear_has_precision();
}
inline ::google::protobuf::int32 SchemaItemConst::precision() const {
  return precision_;
}
inline void SchemaItemConst::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// -------------------------------------------------------------------

// DeviceObject

// required .Proto.Uuid uuid = 1;
inline bool DeviceObject::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceObject::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceObject::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceObject::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& DeviceObject::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* DeviceObject::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* DeviceObject::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring equipmentId = 2;
inline bool DeviceObject::has_equipmentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceObject::set_has_equipmentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceObject::clear_has_equipmentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceObject::clear_equipmentid() {
  if (equipmentid_ != NULL) equipmentid_->::Proto::wstring::Clear();
  clear_has_equipmentid();
}
inline const ::Proto::wstring& DeviceObject::equipmentid() const {
  return equipmentid_ != NULL ? *equipmentid_ : *default_instance_->equipmentid_;
}
inline ::Proto::wstring* DeviceObject::mutable_equipmentid() {
  set_has_equipmentid();
  if (equipmentid_ == NULL) equipmentid_ = new ::Proto::wstring;
  return equipmentid_;
}
inline ::Proto::wstring* DeviceObject::release_equipmentid() {
  clear_has_equipmentid();
  ::Proto::wstring* temp = equipmentid_;
  equipmentid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_equipmentid(::Proto::wstring* equipmentid) {
  delete equipmentid_;
  equipmentid_ = equipmentid;
  if (equipmentid) {
    set_has_equipmentid();
  } else {
    clear_has_equipmentid();
  }
}

// required .Proto.wstring caption = 3;
inline bool DeviceObject::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceObject::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceObject::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceObject::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& DeviceObject::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* DeviceObject::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* DeviceObject::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// optional .Proto.wstring childRestriction = 4;
inline bool DeviceObject::has_childrestriction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceObject::set_has_childrestriction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceObject::clear_has_childrestriction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceObject::clear_childrestriction() {
  if (childrestriction_ != NULL) childrestriction_->::Proto::wstring::Clear();
  clear_has_childrestriction();
}
inline const ::Proto::wstring& DeviceObject::childrestriction() const {
  return childrestriction_ != NULL ? *childrestriction_ : *default_instance_->childrestriction_;
}
inline ::Proto::wstring* DeviceObject::mutable_childrestriction() {
  set_has_childrestriction();
  if (childrestriction_ == NULL) childrestriction_ = new ::Proto::wstring;
  return childrestriction_;
}
inline ::Proto::wstring* DeviceObject::release_childrestriction() {
  clear_has_childrestriction();
  ::Proto::wstring* temp = childrestriction_;
  childrestriction_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_childrestriction(::Proto::wstring* childrestriction) {
  delete childrestriction_;
  childrestriction_ = childrestriction;
  if (childrestriction) {
    set_has_childrestriction();
  } else {
    clear_has_childrestriction();
  }
}

// optional int32 place = 5 [default = 0];
inline bool DeviceObject::has_place() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceObject::set_has_place() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceObject::clear_has_place() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceObject::clear_place() {
  place_ = 0;
  clear_has_place();
}
inline ::google::protobuf::int32 DeviceObject::place() const {
  return place_;
}
inline void DeviceObject::set_place(::google::protobuf::int32 value) {
  set_has_place();
  place_ = value;
}

// optional string specific_properties_struct = 6;
inline bool DeviceObject::has_specific_properties_struct() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceObject::set_has_specific_properties_struct() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceObject::clear_has_specific_properties_struct() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceObject::clear_specific_properties_struct() {
  if (specific_properties_struct_ != &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_->clear();
  }
  clear_has_specific_properties_struct();
}
inline const ::std::string& DeviceObject::specific_properties_struct() const {
  return *specific_properties_struct_;
}
inline void DeviceObject::set_specific_properties_struct(const ::std::string& value) {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  specific_properties_struct_->assign(value);
}
inline void DeviceObject::set_specific_properties_struct(const char* value) {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  specific_properties_struct_->assign(value);
}
inline void DeviceObject::set_specific_properties_struct(const char* value, size_t size) {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  specific_properties_struct_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceObject::mutable_specific_properties_struct() {
  set_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    specific_properties_struct_ = new ::std::string;
  }
  return specific_properties_struct_;
}
inline ::std::string* DeviceObject::release_specific_properties_struct() {
  clear_has_specific_properties_struct();
  if (specific_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = specific_properties_struct_;
    specific_properties_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceObject::set_allocated_specific_properties_struct(::std::string* specific_properties_struct) {
  if (specific_properties_struct_ != &::google::protobuf::internal::kEmptyString) {
    delete specific_properties_struct_;
  }
  if (specific_properties_struct) {
    set_has_specific_properties_struct();
    specific_properties_struct_ = specific_properties_struct;
  } else {
    clear_has_specific_properties_struct();
    specific_properties_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.Property properties = 7;
inline int DeviceObject::properties_size() const {
  return properties_.size();
}
inline void DeviceObject::clear_properties() {
  properties_.Clear();
}
inline const ::Proto::Property& DeviceObject::properties(int index) const {
  return properties_.Get(index);
}
inline ::Proto::Property* DeviceObject::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Proto::Property* DeviceObject::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Property >&
DeviceObject::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Property >*
DeviceObject::mutable_properties() {
  return &properties_;
}

// optional bool preset = 32 [default = false];
inline bool DeviceObject::has_preset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceObject::set_has_preset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceObject::clear_has_preset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceObject::clear_preset() {
  preset_ = false;
  clear_has_preset();
}
inline bool DeviceObject::preset() const {
  return preset_;
}
inline void DeviceObject::set_preset(bool value) {
  set_has_preset();
  preset_ = value;
}

// optional bool presetRoot = 33 [default = false];
inline bool DeviceObject::has_presetroot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceObject::set_has_presetroot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceObject::clear_has_presetroot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceObject::clear_presetroot() {
  presetroot_ = false;
  clear_has_presetroot();
}
inline bool DeviceObject::presetroot() const {
  return presetroot_;
}
inline void DeviceObject::set_presetroot(bool value) {
  set_has_presetroot();
  presetroot_ = value;
}

// optional .Proto.wstring presetName = 34;
inline bool DeviceObject::has_presetname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceObject::set_has_presetname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceObject::clear_has_presetname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceObject::clear_presetname() {
  if (presetname_ != NULL) presetname_->::Proto::wstring::Clear();
  clear_has_presetname();
}
inline const ::Proto::wstring& DeviceObject::presetname() const {
  return presetname_ != NULL ? *presetname_ : *default_instance_->presetname_;
}
inline ::Proto::wstring* DeviceObject::mutable_presetname() {
  set_has_presetname();
  if (presetname_ == NULL) presetname_ = new ::Proto::wstring;
  return presetname_;
}
inline ::Proto::wstring* DeviceObject::release_presetname() {
  clear_has_presetname();
  ::Proto::wstring* temp = presetname_;
  presetname_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_presetname(::Proto::wstring* presetname) {
  delete presetname_;
  presetname_ = presetname;
  if (presetname) {
    set_has_presetname();
  } else {
    clear_has_presetname();
  }
}

// optional .Proto.Uuid presetObjectUuid = 35;
inline bool DeviceObject::has_presetobjectuuid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceObject::set_has_presetobjectuuid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeviceObject::clear_has_presetobjectuuid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceObject::clear_presetobjectuuid() {
  if (presetobjectuuid_ != NULL) presetobjectuuid_->::Proto::Uuid::Clear();
  clear_has_presetobjectuuid();
}
inline const ::Proto::Uuid& DeviceObject::presetobjectuuid() const {
  return presetobjectuuid_ != NULL ? *presetobjectuuid_ : *default_instance_->presetobjectuuid_;
}
inline ::Proto::Uuid* DeviceObject::mutable_presetobjectuuid() {
  set_has_presetobjectuuid();
  if (presetobjectuuid_ == NULL) presetobjectuuid_ = new ::Proto::Uuid;
  return presetobjectuuid_;
}
inline ::Proto::Uuid* DeviceObject::release_presetobjectuuid() {
  clear_has_presetobjectuuid();
  ::Proto::Uuid* temp = presetobjectuuid_;
  presetobjectuuid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_presetobjectuuid(::Proto::Uuid* presetobjectuuid) {
  delete presetobjectuuid_;
  presetobjectuuid_ = presetobjectuuid;
  if (presetobjectuuid) {
    set_has_presetobjectuuid();
  } else {
    clear_has_presetobjectuuid();
  }
}

// optional .Proto.DeviceRoot Root = 100;
inline bool DeviceObject::has_root() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceObject::set_has_root() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeviceObject::clear_has_root() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceObject::clear_root() {
  if (root_ != NULL) root_->::Proto::DeviceRoot::Clear();
  clear_has_root();
}
inline const ::Proto::DeviceRoot& DeviceObject::root() const {
  return root_ != NULL ? *root_ : *default_instance_->root_;
}
inline ::Proto::DeviceRoot* DeviceObject::mutable_root() {
  set_has_root();
  if (root_ == NULL) root_ = new ::Proto::DeviceRoot;
  return root_;
}
inline ::Proto::DeviceRoot* DeviceObject::release_root() {
  clear_has_root();
  ::Proto::DeviceRoot* temp = root_;
  root_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_root(::Proto::DeviceRoot* root) {
  delete root_;
  root_ = root;
  if (root) {
    set_has_root();
  } else {
    clear_has_root();
  }
}

// optional .Proto.DeviceSystem System = 101;
inline bool DeviceObject::has_system() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceObject::set_has_system() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DeviceObject::clear_has_system() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceObject::clear_system() {
  if (system_ != NULL) system_->::Proto::DeviceSystem::Clear();
  clear_has_system();
}
inline const ::Proto::DeviceSystem& DeviceObject::system() const {
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::Proto::DeviceSystem* DeviceObject::mutable_system() {
  set_has_system();
  if (system_ == NULL) system_ = new ::Proto::DeviceSystem;
  return system_;
}
inline ::Proto::DeviceSystem* DeviceObject::release_system() {
  clear_has_system();
  ::Proto::DeviceSystem* temp = system_;
  system_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_system(::Proto::DeviceSystem* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
}

// optional .Proto.DeviceRack Rack = 102;
inline bool DeviceObject::has_rack() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceObject::set_has_rack() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DeviceObject::clear_has_rack() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceObject::clear_rack() {
  if (rack_ != NULL) rack_->::Proto::DeviceRack::Clear();
  clear_has_rack();
}
inline const ::Proto::DeviceRack& DeviceObject::rack() const {
  return rack_ != NULL ? *rack_ : *default_instance_->rack_;
}
inline ::Proto::DeviceRack* DeviceObject::mutable_rack() {
  set_has_rack();
  if (rack_ == NULL) rack_ = new ::Proto::DeviceRack;
  return rack_;
}
inline ::Proto::DeviceRack* DeviceObject::release_rack() {
  clear_has_rack();
  ::Proto::DeviceRack* temp = rack_;
  rack_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_rack(::Proto::DeviceRack* rack) {
  delete rack_;
  rack_ = rack;
  if (rack) {
    set_has_rack();
  } else {
    clear_has_rack();
  }
}

// optional .Proto.DeviceChassis Chassis = 103;
inline bool DeviceObject::has_chassis() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceObject::set_has_chassis() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DeviceObject::clear_has_chassis() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceObject::clear_chassis() {
  if (chassis_ != NULL) chassis_->::Proto::DeviceChassis::Clear();
  clear_has_chassis();
}
inline const ::Proto::DeviceChassis& DeviceObject::chassis() const {
  return chassis_ != NULL ? *chassis_ : *default_instance_->chassis_;
}
inline ::Proto::DeviceChassis* DeviceObject::mutable_chassis() {
  set_has_chassis();
  if (chassis_ == NULL) chassis_ = new ::Proto::DeviceChassis;
  return chassis_;
}
inline ::Proto::DeviceChassis* DeviceObject::release_chassis() {
  clear_has_chassis();
  ::Proto::DeviceChassis* temp = chassis_;
  chassis_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_chassis(::Proto::DeviceChassis* chassis) {
  delete chassis_;
  chassis_ = chassis;
  if (chassis) {
    set_has_chassis();
  } else {
    clear_has_chassis();
  }
}

// optional .Proto.DeviceModule Module = 104;
inline bool DeviceObject::has_module() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceObject::set_has_module() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DeviceObject::clear_has_module() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceObject::clear_module() {
  if (module_ != NULL) module_->::Proto::DeviceModule::Clear();
  clear_has_module();
}
inline const ::Proto::DeviceModule& DeviceObject::module() const {
  return module_ != NULL ? *module_ : *default_instance_->module_;
}
inline ::Proto::DeviceModule* DeviceObject::mutable_module() {
  set_has_module();
  if (module_ == NULL) module_ = new ::Proto::DeviceModule;
  return module_;
}
inline ::Proto::DeviceModule* DeviceObject::release_module() {
  clear_has_module();
  ::Proto::DeviceModule* temp = module_;
  module_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_module(::Proto::DeviceModule* module) {
  delete module_;
  module_ = module;
  if (module) {
    set_has_module();
  } else {
    clear_has_module();
  }
}

// optional .Proto.DeviceController Controller = 105;
inline bool DeviceObject::has_controller() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceObject::set_has_controller() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DeviceObject::clear_has_controller() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceObject::clear_controller() {
  if (controller_ != NULL) controller_->::Proto::DeviceController::Clear();
  clear_has_controller();
}
inline const ::Proto::DeviceController& DeviceObject::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::Proto::DeviceController* DeviceObject::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::Proto::DeviceController;
  return controller_;
}
inline ::Proto::DeviceController* DeviceObject::release_controller() {
  clear_has_controller();
  ::Proto::DeviceController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_controller(::Proto::DeviceController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// optional .Proto.DeviceSignal Signal = 106;
inline bool DeviceObject::has_signal() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceObject::set_has_signal() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DeviceObject::clear_has_signal() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceObject::clear_signal() {
  if (signal_ != NULL) signal_->::Proto::DeviceSignal::Clear();
  clear_has_signal();
}
inline const ::Proto::DeviceSignal& DeviceObject::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Proto::DeviceSignal* DeviceObject::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Proto::DeviceSignal;
  return signal_;
}
inline ::Proto::DeviceSignal* DeviceObject::release_signal() {
  clear_has_signal();
  ::Proto::DeviceSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_signal(::Proto::DeviceSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Proto.Workstation Workstation = 107;
inline bool DeviceObject::has_workstation() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceObject::set_has_workstation() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DeviceObject::clear_has_workstation() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DeviceObject::clear_workstation() {
  if (workstation_ != NULL) workstation_->::Proto::Workstation::Clear();
  clear_has_workstation();
}
inline const ::Proto::Workstation& DeviceObject::workstation() const {
  return workstation_ != NULL ? *workstation_ : *default_instance_->workstation_;
}
inline ::Proto::Workstation* DeviceObject::mutable_workstation() {
  set_has_workstation();
  if (workstation_ == NULL) workstation_ = new ::Proto::Workstation;
  return workstation_;
}
inline ::Proto::Workstation* DeviceObject::release_workstation() {
  clear_has_workstation();
  ::Proto::Workstation* temp = workstation_;
  workstation_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_workstation(::Proto::Workstation* workstation) {
  delete workstation_;
  workstation_ = workstation;
  if (workstation) {
    set_has_workstation();
  } else {
    clear_has_workstation();
  }
}

// optional .Proto.Software Software = 108;
inline bool DeviceObject::has_software() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DeviceObject::set_has_software() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DeviceObject::clear_has_software() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DeviceObject::clear_software() {
  if (software_ != NULL) software_->::Proto::Software::Clear();
  clear_has_software();
}
inline const ::Proto::Software& DeviceObject::software() const {
  return software_ != NULL ? *software_ : *default_instance_->software_;
}
inline ::Proto::Software* DeviceObject::mutable_software() {
  set_has_software();
  if (software_ == NULL) software_ = new ::Proto::Software;
  return software_;
}
inline ::Proto::Software* DeviceObject::release_software() {
  clear_has_software();
  ::Proto::Software* temp = software_;
  software_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_software(::Proto::Software* software) {
  delete software_;
  software_ = software;
  if (software) {
    set_has_software();
  } else {
    clear_has_software();
  }
}

// -------------------------------------------------------------------

// DeviceRoot

// -------------------------------------------------------------------

// DeviceSystem

// -------------------------------------------------------------------

// DeviceRack

// -------------------------------------------------------------------

// DeviceChassis

// optional int32 type = 1 [default = 0];
inline bool DeviceChassis::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceChassis::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceChassis::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceChassis::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceChassis::type() const {
  return type_;
}
inline void DeviceChassis::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// DeviceModule

// optional int32 type = 1 [default = 0];
inline bool DeviceModule::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceModule::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceModule::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceModule::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceModule::type() const {
  return type_;
}
inline void DeviceModule::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// DeviceController

// -------------------------------------------------------------------

// DeviceSignal

// optional int32 obsoletetype = 1 [default = 0];
inline bool DeviceSignal::has_obsoletetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceSignal::set_has_obsoletetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceSignal::clear_has_obsoletetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceSignal::clear_obsoletetype() {
  obsoletetype_ = 0;
  clear_has_obsoletetype();
}
inline ::google::protobuf::int32 DeviceSignal::obsoletetype() const {
  return obsoletetype_;
}
inline void DeviceSignal::set_obsoletetype(::google::protobuf::int32 value) {
  set_has_obsoletetype();
  obsoletetype_ = value;
}

// optional int32 byteOrder = 2 [default = 0];
inline bool DeviceSignal::has_byteorder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceSignal::set_has_byteorder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceSignal::clear_has_byteorder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceSignal::clear_byteorder() {
  byteorder_ = 0;
  clear_has_byteorder();
}
inline ::google::protobuf::int32 DeviceSignal::byteorder() const {
  return byteorder_;
}
inline void DeviceSignal::set_byteorder(::google::protobuf::int32 value) {
  set_has_byteorder();
  byteorder_ = value;
}

// optional int32 format = 3 [default = 0];
inline bool DeviceSignal::has_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceSignal::set_has_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceSignal::clear_has_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceSignal::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 DeviceSignal::format() const {
  return format_;
}
inline void DeviceSignal::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
}

// optional int32 size = 4 [default = 0];
inline bool DeviceSignal::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceSignal::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceSignal::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceSignal::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 DeviceSignal::size() const {
  return size_;
}
inline void DeviceSignal::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int32 validityOffset = 5 [default = 0];
inline bool DeviceSignal::has_validityoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceSignal::set_has_validityoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceSignal::clear_has_validityoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceSignal::clear_validityoffset() {
  validityoffset_ = 0;
  clear_has_validityoffset();
}
inline ::google::protobuf::int32 DeviceSignal::validityoffset() const {
  return validityoffset_;
}
inline void DeviceSignal::set_validityoffset(::google::protobuf::int32 value) {
  set_has_validityoffset();
  validityoffset_ = value;
}

// optional int32 validityBit = 6 [default = 0];
inline bool DeviceSignal::has_validitybit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceSignal::set_has_validitybit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceSignal::clear_has_validitybit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceSignal::clear_validitybit() {
  validitybit_ = 0;
  clear_has_validitybit();
}
inline ::google::protobuf::int32 DeviceSignal::validitybit() const {
  return validitybit_;
}
inline void DeviceSignal::set_validitybit(::google::protobuf::int32 value) {
  set_has_validitybit();
  validitybit_ = value;
}

// optional int32 valueOffset = 7 [default = 0];
inline bool DeviceSignal::has_valueoffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceSignal::set_has_valueoffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceSignal::clear_has_valueoffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceSignal::clear_valueoffset() {
  valueoffset_ = 0;
  clear_has_valueoffset();
}
inline ::google::protobuf::int32 DeviceSignal::valueoffset() const {
  return valueoffset_;
}
inline void DeviceSignal::set_valueoffset(::google::protobuf::int32 value) {
  set_has_valueoffset();
  valueoffset_ = value;
}

// optional int32 valueBit = 8 [default = 0];
inline bool DeviceSignal::has_valuebit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceSignal::set_has_valuebit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceSignal::clear_has_valuebit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceSignal::clear_valuebit() {
  valuebit_ = 0;
  clear_has_valuebit();
}
inline ::google::protobuf::int32 DeviceSignal::valuebit() const {
  return valuebit_;
}
inline void DeviceSignal::set_valuebit(::google::protobuf::int32 value) {
  set_has_valuebit();
  valuebit_ = value;
}

// optional int32 type = 9 [default = 0];
inline bool DeviceSignal::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceSignal::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceSignal::type() const {
  return type_;
}
inline void DeviceSignal::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 function = 10 [default = 0];
inline bool DeviceSignal::has_function() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceSignal::set_has_function() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceSignal::clear_has_function() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceSignal::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::google::protobuf::int32 DeviceSignal::function() const {
  return function_;
}
inline void DeviceSignal::set_function(::google::protobuf::int32 value) {
  set_has_function();
  function_ = value;
}

// -------------------------------------------------------------------

// Workstation

// optional int32 type = 1 [default = 0];
inline bool Workstation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Workstation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Workstation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Workstation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Workstation::type() const {
  return type_;
}
inline void Workstation::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// Software

// optional int32 type = 1 [default = 0];
inline bool Software::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Software::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Software::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Software::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Software::type() const {
  return type_;
}
inline void Software::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ModuleConfiguration

// optional string struct_description = 1;
inline bool ModuleConfiguration::has_struct_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleConfiguration::set_has_struct_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleConfiguration::clear_has_struct_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleConfiguration::clear_struct_description() {
  if (struct_description_ != &::google::protobuf::internal::kEmptyString) {
    struct_description_->clear();
  }
  clear_has_struct_description();
}
inline const ::std::string& ModuleConfiguration::struct_description() const {
  return *struct_description_;
}
inline void ModuleConfiguration::set_struct_description(const ::std::string& value) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(value);
}
inline void ModuleConfiguration::set_struct_description(const char* value) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(value);
}
inline void ModuleConfiguration::set_struct_description(const char* value, size_t size) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfiguration::mutable_struct_description() {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  return struct_description_;
}
inline ::std::string* ModuleConfiguration::release_struct_description() {
  clear_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = struct_description_;
    struct_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfiguration::set_allocated_struct_description(::std::string* struct_description) {
  if (struct_description_ != &::google::protobuf::internal::kEmptyString) {
    delete struct_description_;
  }
  if (struct_description) {
    set_has_struct_description();
    struct_description_ = struct_description;
  } else {
    clear_has_struct_description();
    struct_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.ModuleConfigurationValue values = 2;
inline int ModuleConfiguration::values_size() const {
  return values_.size();
}
inline void ModuleConfiguration::clear_values() {
  values_.Clear();
}
inline const ::Proto::ModuleConfigurationValue& ModuleConfiguration::values(int index) const {
  return values_.Get(index);
}
inline ::Proto::ModuleConfigurationValue* ModuleConfiguration::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::Proto::ModuleConfigurationValue* ModuleConfiguration::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >&
ModuleConfiguration::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >*
ModuleConfiguration::mutable_values() {
  return &values_;
}

// optional string name = 3 [default = ""];
inline bool ModuleConfiguration::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModuleConfiguration::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModuleConfiguration::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModuleConfiguration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleConfiguration::name() const {
  return *name_;
}
inline void ModuleConfiguration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfiguration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfiguration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfiguration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleConfiguration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfiguration::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModuleConfigurationValue

// required string name = 1;
inline bool ModuleConfigurationValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleConfigurationValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleConfigurationValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleConfigurationValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleConfigurationValue::name() const {
  return *name_;
}
inline void ModuleConfigurationValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfigurationValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfigurationValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfigurationValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleConfigurationValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfigurationValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool ModuleConfigurationValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleConfigurationValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleConfigurationValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleConfigurationValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ModuleConfigurationValue::value() const {
  return *value_;
}
inline void ModuleConfigurationValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ModuleConfigurationValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ModuleConfigurationValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfigurationValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ModuleConfigurationValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfigurationValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Property

// required string name = 1;
inline bool Property::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Property::name() const {
  return *name_;
}
inline void Property::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Property::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Property::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Property::value() const {
  return *value_;
}
inline void Property::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Property::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Address16

// required int32 offset = 1 [default = -1];
inline bool Address16::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address16::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address16::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address16::clear_offset() {
  offset_ = -1;
  clear_has_offset();
}
inline ::google::protobuf::int32 Address16::offset() const {
  return offset_;
}
inline void Address16::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 bit = 2 [default = -1];
inline bool Address16::has_bit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address16::set_has_bit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address16::clear_has_bit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address16::clear_bit() {
  bit_ = -1;
  clear_has_bit();
}
inline ::google::protobuf::int32 Address16::bit() const {
  return bit_;
}
inline void Address16::set_bit(::google::protobuf::int32 value) {
  set_has_bit();
  bit_ = value;
}

// -------------------------------------------------------------------

// AppSignal

// optional int32 ID = 1;
inline bool AppSignal::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppSignal::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppSignal::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppSignal::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AppSignal::id() const {
  return id_;
}
inline void AppSignal::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 signalGroupID = 2;
inline bool AppSignal::has_signalgroupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppSignal::set_has_signalgroupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppSignal::clear_has_signalgroupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppSignal::clear_signalgroupid() {
  signalgroupid_ = 0;
  clear_has_signalgroupid();
}
inline ::google::protobuf::int32 AppSignal::signalgroupid() const {
  return signalgroupid_;
}
inline void AppSignal::set_signalgroupid(::google::protobuf::int32 value) {
  set_has_signalgroupid();
  signalgroupid_ = value;
}

// optional int32 signalInstanceID = 3;
inline bool AppSignal::has_signalinstanceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppSignal::set_has_signalinstanceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppSignal::clear_has_signalinstanceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppSignal::clear_signalinstanceid() {
  signalinstanceid_ = 0;
  clear_has_signalinstanceid();
}
inline ::google::protobuf::int32 AppSignal::signalinstanceid() const {
  return signalinstanceid_;
}
inline void AppSignal::set_signalinstanceid(::google::protobuf::int32 value) {
  set_has_signalinstanceid();
  signalinstanceid_ = value;
}

// optional int32 changesetID = 4;
inline bool AppSignal::has_changesetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppSignal::set_has_changesetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppSignal::clear_has_changesetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppSignal::clear_changesetid() {
  changesetid_ = 0;
  clear_has_changesetid();
}
inline ::google::protobuf::int32 AppSignal::changesetid() const {
  return changesetid_;
}
inline void AppSignal::set_changesetid(::google::protobuf::int32 value) {
  set_has_changesetid();
  changesetid_ = value;
}

// optional bool checkedOut = 5;
inline bool AppSignal::has_checkedout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppSignal::set_has_checkedout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppSignal::clear_has_checkedout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppSignal::clear_checkedout() {
  checkedout_ = false;
  clear_has_checkedout();
}
inline bool AppSignal::checkedout() const {
  return checkedout_;
}
inline void AppSignal::set_checkedout(bool value) {
  set_has_checkedout();
  checkedout_ = value;
}

// optional int32 userID = 6;
inline bool AppSignal::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppSignal::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppSignal::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppSignal::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 AppSignal::userid() const {
  return userid_;
}
inline void AppSignal::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 subsystemChannel = 7;
inline bool AppSignal::has_subsystemchannel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppSignal::set_has_subsystemchannel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AppSignal::clear_has_subsystemchannel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AppSignal::clear_subsystemchannel() {
  subsystemchannel_ = 0;
  clear_has_subsystemchannel();
}
inline ::google::protobuf::int32 AppSignal::subsystemchannel() const {
  return subsystemchannel_;
}
inline void AppSignal::set_subsystemchannel(::google::protobuf::int32 value) {
  set_has_subsystemchannel();
  subsystemchannel_ = value;
}

// optional int32 type = 8;
inline bool AppSignal::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppSignal::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AppSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AppSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AppSignal::type() const {
  return type_;
}
inline void AppSignal::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int64 created = 9;
inline bool AppSignal::has_created() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppSignal::set_has_created() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AppSignal::clear_has_created() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AppSignal::clear_created() {
  created_ = GOOGLE_LONGLONG(0);
  clear_has_created();
}
inline ::google::protobuf::int64 AppSignal::created() const {
  return created_;
}
inline void AppSignal::set_created(::google::protobuf::int64 value) {
  set_has_created();
  created_ = value;
}

// optional bool deleted = 10;
inline bool AppSignal::has_deleted() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AppSignal::set_has_deleted() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AppSignal::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AppSignal::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool AppSignal::deleted() const {
  return deleted_;
}
inline void AppSignal::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
}

// optional int64 instanceCreated = 11;
inline bool AppSignal::has_instancecreated() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AppSignal::set_has_instancecreated() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AppSignal::clear_has_instancecreated() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AppSignal::clear_instancecreated() {
  instancecreated_ = GOOGLE_LONGLONG(0);
  clear_has_instancecreated();
}
inline ::google::protobuf::int64 AppSignal::instancecreated() const {
  return instancecreated_;
}
inline void AppSignal::set_instancecreated(::google::protobuf::int64 value) {
  set_has_instancecreated();
  instancecreated_ = value;
}

// optional int32 instanceAction = 12;
inline bool AppSignal::has_instanceaction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AppSignal::set_has_instanceaction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AppSignal::clear_has_instanceaction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AppSignal::clear_instanceaction() {
  instanceaction_ = 0;
  clear_has_instanceaction();
}
inline ::google::protobuf::int32 AppSignal::instanceaction() const {
  return instanceaction_;
}
inline void AppSignal::set_instanceaction(::google::protobuf::int32 value) {
  set_has_instanceaction();
  instanceaction_ = value;
}

// optional string appSignalID = 13;
inline bool AppSignal::has_appsignalid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AppSignal::set_has_appsignalid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AppSignal::clear_has_appsignalid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AppSignal::clear_appsignalid() {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    appsignalid_->clear();
  }
  clear_has_appsignalid();
}
inline const ::std::string& AppSignal::appsignalid() const {
  return *appsignalid_;
}
inline void AppSignal::set_appsignalid(const ::std::string& value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void AppSignal::set_appsignalid(const char* value) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(value);
}
inline void AppSignal::set_appsignalid(const char* value, size_t size) {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  appsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_appsignalid() {
  set_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    appsignalid_ = new ::std::string;
  }
  return appsignalid_;
}
inline ::std::string* AppSignal::release_appsignalid() {
  clear_has_appsignalid();
  if (appsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appsignalid_;
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_appsignalid(::std::string* appsignalid) {
  if (appsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete appsignalid_;
  }
  if (appsignalid) {
    set_has_appsignalid();
    appsignalid_ = appsignalid;
  } else {
    clear_has_appsignalid();
    appsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string customAppSignalID = 14;
inline bool AppSignal::has_customappsignalid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AppSignal::set_has_customappsignalid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AppSignal::clear_has_customappsignalid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AppSignal::clear_customappsignalid() {
  if (customappsignalid_ != &::google::protobuf::internal::kEmptyString) {
    customappsignalid_->clear();
  }
  clear_has_customappsignalid();
}
inline const ::std::string& AppSignal::customappsignalid() const {
  return *customappsignalid_;
}
inline void AppSignal::set_customappsignalid(const ::std::string& value) {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  customappsignalid_->assign(value);
}
inline void AppSignal::set_customappsignalid(const char* value) {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  customappsignalid_->assign(value);
}
inline void AppSignal::set_customappsignalid(const char* value, size_t size) {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  customappsignalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_customappsignalid() {
  set_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    customappsignalid_ = new ::std::string;
  }
  return customappsignalid_;
}
inline ::std::string* AppSignal::release_customappsignalid() {
  clear_has_customappsignalid();
  if (customappsignalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customappsignalid_;
    customappsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_customappsignalid(::std::string* customappsignalid) {
  if (customappsignalid_ != &::google::protobuf::internal::kEmptyString) {
    delete customappsignalid_;
  }
  if (customappsignalid) {
    set_has_customappsignalid();
    customappsignalid_ = customappsignalid;
  } else {
    clear_has_customappsignalid();
    customappsignalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string caption = 15;
inline bool AppSignal::has_caption() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AppSignal::set_has_caption() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AppSignal::clear_has_caption() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AppSignal::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& AppSignal::caption() const {
  return *caption_;
}
inline void AppSignal::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void AppSignal::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void AppSignal::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* AppSignal::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dataFormat = 16;
inline bool AppSignal::has_dataformat() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AppSignal::set_has_dataformat() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AppSignal::clear_has_dataformat() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AppSignal::clear_dataformat() {
  dataformat_ = 0;
  clear_has_dataformat();
}
inline ::google::protobuf::int32 AppSignal::dataformat() const {
  return dataformat_;
}
inline void AppSignal::set_dataformat(::google::protobuf::int32 value) {
  set_has_dataformat();
  dataformat_ = value;
}

// optional int32 dataSize = 17;
inline bool AppSignal::has_datasize() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AppSignal::set_has_datasize() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AppSignal::clear_has_datasize() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AppSignal::clear_datasize() {
  datasize_ = 0;
  clear_has_datasize();
}
inline ::google::protobuf::int32 AppSignal::datasize() const {
  return datasize_;
}
inline void AppSignal::set_datasize(::google::protobuf::int32 value) {
  set_has_datasize();
  datasize_ = value;
}

// optional int32 lowADC = 18;
inline bool AppSignal::has_lowadc() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AppSignal::set_has_lowadc() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AppSignal::clear_has_lowadc() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AppSignal::clear_lowadc() {
  lowadc_ = 0;
  clear_has_lowadc();
}
inline ::google::protobuf::int32 AppSignal::lowadc() const {
  return lowadc_;
}
inline void AppSignal::set_lowadc(::google::protobuf::int32 value) {
  set_has_lowadc();
  lowadc_ = value;
}

// optional int32 highADC = 19;
inline bool AppSignal::has_highadc() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AppSignal::set_has_highadc() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AppSignal::clear_has_highadc() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AppSignal::clear_highadc() {
  highadc_ = 0;
  clear_has_highadc();
}
inline ::google::protobuf::int32 AppSignal::highadc() const {
  return highadc_;
}
inline void AppSignal::set_highadc(::google::protobuf::int32 value) {
  set_has_highadc();
  highadc_ = value;
}

// optional double lowEngeneeringUnits = 20;
inline bool AppSignal::has_lowengeneeringunits() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AppSignal::set_has_lowengeneeringunits() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AppSignal::clear_has_lowengeneeringunits() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AppSignal::clear_lowengeneeringunits() {
  lowengeneeringunits_ = 0;
  clear_has_lowengeneeringunits();
}
inline double AppSignal::lowengeneeringunits() const {
  return lowengeneeringunits_;
}
inline void AppSignal::set_lowengeneeringunits(double value) {
  set_has_lowengeneeringunits();
  lowengeneeringunits_ = value;
}

// optional double highEngeneeringUnits = 21;
inline bool AppSignal::has_highengeneeringunits() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AppSignal::set_has_highengeneeringunits() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AppSignal::clear_has_highengeneeringunits() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AppSignal::clear_highengeneeringunits() {
  highengeneeringunits_ = 0;
  clear_has_highengeneeringunits();
}
inline double AppSignal::highengeneeringunits() const {
  return highengeneeringunits_;
}
inline void AppSignal::set_highengeneeringunits(double value) {
  set_has_highengeneeringunits();
  highengeneeringunits_ = value;
}

// optional int32 unitID = 22;
inline bool AppSignal::has_unitid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AppSignal::set_has_unitid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AppSignal::clear_has_unitid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AppSignal::clear_unitid() {
  unitid_ = 0;
  clear_has_unitid();
}
inline ::google::protobuf::int32 AppSignal::unitid() const {
  return unitid_;
}
inline void AppSignal::set_unitid(::google::protobuf::int32 value) {
  set_has_unitid();
  unitid_ = value;
}

// optional double adjustment = 23;
inline bool AppSignal::has_adjustment() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AppSignal::set_has_adjustment() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AppSignal::clear_has_adjustment() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AppSignal::clear_adjustment() {
  adjustment_ = 0;
  clear_has_adjustment();
}
inline double AppSignal::adjustment() const {
  return adjustment_;
}
inline void AppSignal::set_adjustment(double value) {
  set_has_adjustment();
  adjustment_ = value;
}

// optional double lowValidRange = 24;
inline bool AppSignal::has_lowvalidrange() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AppSignal::set_has_lowvalidrange() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AppSignal::clear_has_lowvalidrange() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AppSignal::clear_lowvalidrange() {
  lowvalidrange_ = 0;
  clear_has_lowvalidrange();
}
inline double AppSignal::lowvalidrange() const {
  return lowvalidrange_;
}
inline void AppSignal::set_lowvalidrange(double value) {
  set_has_lowvalidrange();
  lowvalidrange_ = value;
}

// optional double highValidRange = 25;
inline bool AppSignal::has_highvalidrange() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AppSignal::set_has_highvalidrange() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AppSignal::clear_has_highvalidrange() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AppSignal::clear_highvalidrange() {
  highvalidrange_ = 0;
  clear_has_highvalidrange();
}
inline double AppSignal::highvalidrange() const {
  return highvalidrange_;
}
inline void AppSignal::set_highvalidrange(double value) {
  set_has_highvalidrange();
  highvalidrange_ = value;
}

// optional double unbalanceLimit = 26;
inline bool AppSignal::has_unbalancelimit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AppSignal::set_has_unbalancelimit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AppSignal::clear_has_unbalancelimit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AppSignal::clear_unbalancelimit() {
  unbalancelimit_ = 0;
  clear_has_unbalancelimit();
}
inline double AppSignal::unbalancelimit() const {
  return unbalancelimit_;
}
inline void AppSignal::set_unbalancelimit(double value) {
  set_has_unbalancelimit();
  unbalancelimit_ = value;
}

// optional double inputLowLimit = 27;
inline bool AppSignal::has_inputlowlimit() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AppSignal::set_has_inputlowlimit() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AppSignal::clear_has_inputlowlimit() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AppSignal::clear_inputlowlimit() {
  inputlowlimit_ = 0;
  clear_has_inputlowlimit();
}
inline double AppSignal::inputlowlimit() const {
  return inputlowlimit_;
}
inline void AppSignal::set_inputlowlimit(double value) {
  set_has_inputlowlimit();
  inputlowlimit_ = value;
}

// optional double inputHighLimit = 28;
inline bool AppSignal::has_inputhighlimit() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AppSignal::set_has_inputhighlimit() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AppSignal::clear_has_inputhighlimit() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AppSignal::clear_inputhighlimit() {
  inputhighlimit_ = 0;
  clear_has_inputhighlimit();
}
inline double AppSignal::inputhighlimit() const {
  return inputhighlimit_;
}
inline void AppSignal::set_inputhighlimit(double value) {
  set_has_inputhighlimit();
  inputhighlimit_ = value;
}

// optional int32 inputUnitID = 29;
inline bool AppSignal::has_inputunitid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AppSignal::set_has_inputunitid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AppSignal::clear_has_inputunitid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AppSignal::clear_inputunitid() {
  inputunitid_ = 0;
  clear_has_inputunitid();
}
inline ::google::protobuf::int32 AppSignal::inputunitid() const {
  return inputunitid_;
}
inline void AppSignal::set_inputunitid(::google::protobuf::int32 value) {
  set_has_inputunitid();
  inputunitid_ = value;
}

// optional int32 inputSensorID = 30;
inline bool AppSignal::has_inputsensorid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AppSignal::set_has_inputsensorid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AppSignal::clear_has_inputsensorid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AppSignal::clear_inputsensorid() {
  inputsensorid_ = 0;
  clear_has_inputsensorid();
}
inline ::google::protobuf::int32 AppSignal::inputsensorid() const {
  return inputsensorid_;
}
inline void AppSignal::set_inputsensorid(::google::protobuf::int32 value) {
  set_has_inputsensorid();
  inputsensorid_ = value;
}

// optional double outputLowLimit = 31;
inline bool AppSignal::has_outputlowlimit() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AppSignal::set_has_outputlowlimit() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AppSignal::clear_has_outputlowlimit() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AppSignal::clear_outputlowlimit() {
  outputlowlimit_ = 0;
  clear_has_outputlowlimit();
}
inline double AppSignal::outputlowlimit() const {
  return outputlowlimit_;
}
inline void AppSignal::set_outputlowlimit(double value) {
  set_has_outputlowlimit();
  outputlowlimit_ = value;
}

// optional double outputHighLimit = 32;
inline bool AppSignal::has_outputhighlimit() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AppSignal::set_has_outputhighlimit() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AppSignal::clear_has_outputhighlimit() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AppSignal::clear_outputhighlimit() {
  outputhighlimit_ = 0;
  clear_has_outputhighlimit();
}
inline double AppSignal::outputhighlimit() const {
  return outputhighlimit_;
}
inline void AppSignal::set_outputhighlimit(double value) {
  set_has_outputhighlimit();
  outputhighlimit_ = value;
}

// optional int32 outputUnitID = 33;
inline bool AppSignal::has_outputunitid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AppSignal::set_has_outputunitid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AppSignal::clear_has_outputunitid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AppSignal::clear_outputunitid() {
  outputunitid_ = 0;
  clear_has_outputunitid();
}
inline ::google::protobuf::int32 AppSignal::outputunitid() const {
  return outputunitid_;
}
inline void AppSignal::set_outputunitid(::google::protobuf::int32 value) {
  set_has_outputunitid();
  outputunitid_ = value;
}

// optional int32 outputMode = 34;
inline bool AppSignal::has_outputmode() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AppSignal::set_has_outputmode() {
  _has_bits_[1] |= 0x00000002u;
}
inline void AppSignal::clear_has_outputmode() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void AppSignal::clear_outputmode() {
  outputmode_ = 0;
  clear_has_outputmode();
}
inline ::google::protobuf::int32 AppSignal::outputmode() const {
  return outputmode_;
}
inline void AppSignal::set_outputmode(::google::protobuf::int32 value) {
  set_has_outputmode();
  outputmode_ = value;
}

// optional int32 outputSensorID = 35;
inline bool AppSignal::has_outputsensorid() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AppSignal::set_has_outputsensorid() {
  _has_bits_[1] |= 0x00000004u;
}
inline void AppSignal::clear_has_outputsensorid() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void AppSignal::clear_outputsensorid() {
  outputsensorid_ = 0;
  clear_has_outputsensorid();
}
inline ::google::protobuf::int32 AppSignal::outputsensorid() const {
  return outputsensorid_;
}
inline void AppSignal::set_outputsensorid(::google::protobuf::int32 value) {
  set_has_outputsensorid();
  outputsensorid_ = value;
}

// optional bool acquire = 36;
inline bool AppSignal::has_acquire() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AppSignal::set_has_acquire() {
  _has_bits_[1] |= 0x00000008u;
}
inline void AppSignal::clear_has_acquire() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void AppSignal::clear_acquire() {
  acquire_ = false;
  clear_has_acquire();
}
inline bool AppSignal::acquire() const {
  return acquire_;
}
inline void AppSignal::set_acquire(bool value) {
  set_has_acquire();
  acquire_ = value;
}

// optional bool calculated = 37;
inline bool AppSignal::has_calculated() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AppSignal::set_has_calculated() {
  _has_bits_[1] |= 0x00000010u;
}
inline void AppSignal::clear_has_calculated() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void AppSignal::clear_calculated() {
  calculated_ = false;
  clear_has_calculated();
}
inline bool AppSignal::calculated() const {
  return calculated_;
}
inline void AppSignal::set_calculated(bool value) {
  set_has_calculated();
  calculated_ = value;
}

// optional int32 normalState = 38;
inline bool AppSignal::has_normalstate() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AppSignal::set_has_normalstate() {
  _has_bits_[1] |= 0x00000020u;
}
inline void AppSignal::clear_has_normalstate() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void AppSignal::clear_normalstate() {
  normalstate_ = 0;
  clear_has_normalstate();
}
inline ::google::protobuf::int32 AppSignal::normalstate() const {
  return normalstate_;
}
inline void AppSignal::set_normalstate(::google::protobuf::int32 value) {
  set_has_normalstate();
  normalstate_ = value;
}

// optional int32 decimalPlaces = 39;
inline bool AppSignal::has_decimalplaces() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void AppSignal::set_has_decimalplaces() {
  _has_bits_[1] |= 0x00000040u;
}
inline void AppSignal::clear_has_decimalplaces() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void AppSignal::clear_decimalplaces() {
  decimalplaces_ = 0;
  clear_has_decimalplaces();
}
inline ::google::protobuf::int32 AppSignal::decimalplaces() const {
  return decimalplaces_;
}
inline void AppSignal::set_decimalplaces(::google::protobuf::int32 value) {
  set_has_decimalplaces();
  decimalplaces_ = value;
}

// optional double aperture = 40;
inline bool AppSignal::has_aperture() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void AppSignal::set_has_aperture() {
  _has_bits_[1] |= 0x00000080u;
}
inline void AppSignal::clear_has_aperture() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void AppSignal::clear_aperture() {
  aperture_ = 0;
  clear_has_aperture();
}
inline double AppSignal::aperture() const {
  return aperture_;
}
inline void AppSignal::set_aperture(double value) {
  set_has_aperture();
  aperture_ = value;
}

// optional int32 inOutType = 41;
inline bool AppSignal::has_inouttype() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void AppSignal::set_has_inouttype() {
  _has_bits_[1] |= 0x00000100u;
}
inline void AppSignal::clear_has_inouttype() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void AppSignal::clear_inouttype() {
  inouttype_ = 0;
  clear_has_inouttype();
}
inline ::google::protobuf::int32 AppSignal::inouttype() const {
  return inouttype_;
}
inline void AppSignal::set_inouttype(::google::protobuf::int32 value) {
  set_has_inouttype();
  inouttype_ = value;
}

// optional string equipmentID = 42;
inline bool AppSignal::has_equipmentid() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void AppSignal::set_has_equipmentid() {
  _has_bits_[1] |= 0x00000200u;
}
inline void AppSignal::clear_has_equipmentid() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void AppSignal::clear_equipmentid() {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    equipmentid_->clear();
  }
  clear_has_equipmentid();
}
inline const ::std::string& AppSignal::equipmentid() const {
  return *equipmentid_;
}
inline void AppSignal::set_equipmentid(const ::std::string& value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void AppSignal::set_equipmentid(const char* value) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(value);
}
inline void AppSignal::set_equipmentid(const char* value, size_t size) {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  equipmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppSignal::mutable_equipmentid() {
  set_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    equipmentid_ = new ::std::string;
  }
  return equipmentid_;
}
inline ::std::string* AppSignal::release_equipmentid() {
  clear_has_equipmentid();
  if (equipmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equipmentid_;
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppSignal::set_allocated_equipmentid(::std::string* equipmentid) {
  if (equipmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete equipmentid_;
  }
  if (equipmentid) {
    set_has_equipmentid();
    equipmentid_ = equipmentid;
  } else {
    clear_has_equipmentid();
    equipmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double filteringTime = 43;
inline bool AppSignal::has_filteringtime() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void AppSignal::set_has_filteringtime() {
  _has_bits_[1] |= 0x00000400u;
}
inline void AppSignal::clear_has_filteringtime() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void AppSignal::clear_filteringtime() {
  filteringtime_ = 0;
  clear_has_filteringtime();
}
inline double AppSignal::filteringtime() const {
  return filteringtime_;
}
inline void AppSignal::set_filteringtime(double value) {
  set_has_filteringtime();
  filteringtime_ = value;
}

// optional double spreadTolerance = 44;
inline bool AppSignal::has_spreadtolerance() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void AppSignal::set_has_spreadtolerance() {
  _has_bits_[1] |= 0x00000800u;
}
inline void AppSignal::clear_has_spreadtolerance() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void AppSignal::clear_spreadtolerance() {
  spreadtolerance_ = 0;
  clear_has_spreadtolerance();
}
inline double AppSignal::spreadtolerance() const {
  return spreadtolerance_;
}
inline void AppSignal::set_spreadtolerance(double value) {
  set_has_spreadtolerance();
  spreadtolerance_ = value;
}

// optional int32 byteOrder = 45;
inline bool AppSignal::has_byteorder() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void AppSignal::set_has_byteorder() {
  _has_bits_[1] |= 0x00001000u;
}
inline void AppSignal::clear_has_byteorder() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void AppSignal::clear_byteorder() {
  byteorder_ = 0;
  clear_has_byteorder();
}
inline ::google::protobuf::int32 AppSignal::byteorder() const {
  return byteorder_;
}
inline void AppSignal::set_byteorder(::google::protobuf::int32 value) {
  set_has_byteorder();
  byteorder_ = value;
}

// optional bool enableTuning = 46;
inline bool AppSignal::has_enabletuning() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void AppSignal::set_has_enabletuning() {
  _has_bits_[1] |= 0x00002000u;
}
inline void AppSignal::clear_has_enabletuning() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void AppSignal::clear_enabletuning() {
  enabletuning_ = false;
  clear_has_enabletuning();
}
inline bool AppSignal::enabletuning() const {
  return enabletuning_;
}
inline void AppSignal::set_enabletuning(bool value) {
  set_has_enabletuning();
  enabletuning_ = value;
}

// optional double tuningDefaultValue = 47;
inline bool AppSignal::has_tuningdefaultvalue() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void AppSignal::set_has_tuningdefaultvalue() {
  _has_bits_[1] |= 0x00004000u;
}
inline void AppSignal::clear_has_tuningdefaultvalue() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void AppSignal::clear_tuningdefaultvalue() {
  tuningdefaultvalue_ = 0;
  clear_has_tuningdefaultvalue();
}
inline double AppSignal::tuningdefaultvalue() const {
  return tuningdefaultvalue_;
}
inline void AppSignal::set_tuningdefaultvalue(double value) {
  set_has_tuningdefaultvalue();
  tuningdefaultvalue_ = value;
}

// optional uint64 hash = 48;
inline bool AppSignal::has_hash() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void AppSignal::set_has_hash() {
  _has_bits_[1] |= 0x00008000u;
}
inline void AppSignal::clear_has_hash() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void AppSignal::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 AppSignal::hash() const {
  return hash_;
}
inline void AppSignal::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// optional int32 regValueAddrOffset = 200;
inline bool AppSignal::has_regvalueaddroffset() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void AppSignal::set_has_regvalueaddroffset() {
  _has_bits_[1] |= 0x00010000u;
}
inline void AppSignal::clear_has_regvalueaddroffset() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void AppSignal::clear_regvalueaddroffset() {
  regvalueaddroffset_ = 0;
  clear_has_regvalueaddroffset();
}
inline ::google::protobuf::int32 AppSignal::regvalueaddroffset() const {
  return regvalueaddroffset_;
}
inline void AppSignal::set_regvalueaddroffset(::google::protobuf::int32 value) {
  set_has_regvalueaddroffset();
  regvalueaddroffset_ = value;
}

// optional int32 regValueAddrBit = 201;
inline bool AppSignal::has_regvalueaddrbit() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void AppSignal::set_has_regvalueaddrbit() {
  _has_bits_[1] |= 0x00020000u;
}
inline void AppSignal::clear_has_regvalueaddrbit() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void AppSignal::clear_regvalueaddrbit() {
  regvalueaddrbit_ = 0;
  clear_has_regvalueaddrbit();
}
inline ::google::protobuf::int32 AppSignal::regvalueaddrbit() const {
  return regvalueaddrbit_;
}
inline void AppSignal::set_regvalueaddrbit(::google::protobuf::int32 value) {
  set_has_regvalueaddrbit();
  regvalueaddrbit_ = value;
}

// optional int32 regValidityAddrOffset = 202;
inline bool AppSignal::has_regvalidityaddroffset() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void AppSignal::set_has_regvalidityaddroffset() {
  _has_bits_[1] |= 0x00040000u;
}
inline void AppSignal::clear_has_regvalidityaddroffset() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void AppSignal::clear_regvalidityaddroffset() {
  regvalidityaddroffset_ = 0;
  clear_has_regvalidityaddroffset();
}
inline ::google::protobuf::int32 AppSignal::regvalidityaddroffset() const {
  return regvalidityaddroffset_;
}
inline void AppSignal::set_regvalidityaddroffset(::google::protobuf::int32 value) {
  set_has_regvalidityaddroffset();
  regvalidityaddroffset_ = value;
}

// optional int32 regValidityAddrBit = 203;
inline bool AppSignal::has_regvalidityaddrbit() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void AppSignal::set_has_regvalidityaddrbit() {
  _has_bits_[1] |= 0x00080000u;
}
inline void AppSignal::clear_has_regvalidityaddrbit() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void AppSignal::clear_regvalidityaddrbit() {
  regvalidityaddrbit_ = 0;
  clear_has_regvalidityaddrbit();
}
inline ::google::protobuf::int32 AppSignal::regvalidityaddrbit() const {
  return regvalidityaddrbit_;
}
inline void AppSignal::set_regvalidityaddrbit(::google::protobuf::int32 value) {
  set_has_regvalidityaddrbit();
  regvalidityaddrbit_ = value;
}

// optional int32 ioBufferAddrOffset = 204;
inline bool AppSignal::has_iobufferaddroffset() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void AppSignal::set_has_iobufferaddroffset() {
  _has_bits_[1] |= 0x00100000u;
}
inline void AppSignal::clear_has_iobufferaddroffset() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void AppSignal::clear_iobufferaddroffset() {
  iobufferaddroffset_ = 0;
  clear_has_iobufferaddroffset();
}
inline ::google::protobuf::int32 AppSignal::iobufferaddroffset() const {
  return iobufferaddroffset_;
}
inline void AppSignal::set_iobufferaddroffset(::google::protobuf::int32 value) {
  set_has_iobufferaddroffset();
  iobufferaddroffset_ = value;
}

// optional int32 ioBufferAddrBit = 205;
inline bool AppSignal::has_iobufferaddrbit() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void AppSignal::set_has_iobufferaddrbit() {
  _has_bits_[1] |= 0x00200000u;
}
inline void AppSignal::clear_has_iobufferaddrbit() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void AppSignal::clear_iobufferaddrbit() {
  iobufferaddrbit_ = 0;
  clear_has_iobufferaddrbit();
}
inline ::google::protobuf::int32 AppSignal::iobufferaddrbit() const {
  return iobufferaddrbit_;
}
inline void AppSignal::set_iobufferaddrbit(::google::protobuf::int32 value) {
  set_has_iobufferaddrbit();
  iobufferaddrbit_ = value;
}

// optional int32 ramAddrOffset = 206;
inline bool AppSignal::has_ramaddroffset() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void AppSignal::set_has_ramaddroffset() {
  _has_bits_[1] |= 0x00400000u;
}
inline void AppSignal::clear_has_ramaddroffset() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void AppSignal::clear_ramaddroffset() {
  ramaddroffset_ = 0;
  clear_has_ramaddroffset();
}
inline ::google::protobuf::int32 AppSignal::ramaddroffset() const {
  return ramaddroffset_;
}
inline void AppSignal::set_ramaddroffset(::google::protobuf::int32 value) {
  set_has_ramaddroffset();
  ramaddroffset_ = value;
}

// optional int32 ramAddrBit = 207;
inline bool AppSignal::has_ramaddrbit() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void AppSignal::set_has_ramaddrbit() {
  _has_bits_[1] |= 0x00800000u;
}
inline void AppSignal::clear_has_ramaddrbit() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void AppSignal::clear_ramaddrbit() {
  ramaddrbit_ = 0;
  clear_has_ramaddrbit();
}
inline ::google::protobuf::int32 AppSignal::ramaddrbit() const {
  return ramaddrbit_;
}
inline void AppSignal::set_ramaddrbit(::google::protobuf::int32 value) {
  set_has_ramaddrbit();
  ramaddrbit_ = value;
}

// -------------------------------------------------------------------

// AppSignalState

// optional uint64 hash = 1;
inline bool AppSignalState::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppSignalState::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppSignalState::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppSignalState::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 AppSignalState::hash() const {
  return hash_;
}
inline void AppSignalState::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
}

// optional double value = 2;
inline bool AppSignalState::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppSignalState::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppSignalState::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppSignalState::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double AppSignalState::value() const {
  return value_;
}
inline void AppSignalState::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional uint32 flags = 3;
inline bool AppSignalState::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppSignalState::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppSignalState::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppSignalState::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 AppSignalState::flags() const {
  return flags_;
}
inline void AppSignalState::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional sint64 systemTime = 4;
inline bool AppSignalState::has_systemtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppSignalState::set_has_systemtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppSignalState::clear_has_systemtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppSignalState::clear_systemtime() {
  systemtime_ = GOOGLE_LONGLONG(0);
  clear_has_systemtime();
}
inline ::google::protobuf::int64 AppSignalState::systemtime() const {
  return systemtime_;
}
inline void AppSignalState::set_systemtime(::google::protobuf::int64 value) {
  set_has_systemtime();
  systemtime_ = value;
}

// optional sint64 localTime = 5;
inline bool AppSignalState::has_localtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppSignalState::set_has_localtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppSignalState::clear_has_localtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppSignalState::clear_localtime() {
  localtime_ = GOOGLE_LONGLONG(0);
  clear_has_localtime();
}
inline ::google::protobuf::int64 AppSignalState::localtime() const {
  return localtime_;
}
inline void AppSignalState::set_localtime(::google::protobuf::int64 value) {
  set_has_localtime();
  localtime_ = value;
}

// optional sint64 plantTime = 6;
inline bool AppSignalState::has_planttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppSignalState::set_has_planttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppSignalState::clear_has_planttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppSignalState::clear_planttime() {
  planttime_ = GOOGLE_LONGLONG(0);
  clear_has_planttime();
}
inline ::google::protobuf::int64 AppSignalState::planttime() const {
  return planttime_;
}
inline void AppSignalState::set_planttime(::google::protobuf::int64 value) {
  set_has_planttime();
  planttime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::SchemaUnit>() {
  return ::Proto::SchemaUnit_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::ConnectionDirrection>() {
  return ::Proto::ConnectionDirrection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::FblSignalType>() {
  return ::Proto::FblSignalType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::FblDataFormat>() {
  return ::Proto::FblDataFormat_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_serialization_2eproto__INCLUDED
