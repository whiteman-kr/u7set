// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serialization.proto

#ifndef PROTOBUF_serialization_2eproto__INCLUDED
#define PROTOBUF_serialization_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_serialization_2eproto();
void protobuf_AssignDesc_serialization_2eproto();
void protobuf_ShutdownFile_serialization_2eproto();

class Uuid;
class qvariant;
class wstring;
class FontParam;
class SchemePoint;
class Envelope;
class Configuration;
class AfbElementCollection;
class AfbElementXml;
class FblElement;
class FblElementSignal;
class FblElementParam;
class Scheme;
class LogicScheme;
class SchemeLayer;
class SchemeItem;
class PosRectImpl;
class PosLineImpl;
class PosConnectionImpl;
class SchemeItemRect;
class SchemeItemLine;
class SchemeItemPath;
class FblConnectionPoint;
class FblItem;
class FblItemRect;
class FblItemLine;
class SchemeItemSignal;
class SchemeItemInput;
class SchemeItemOutput;
class SchemeItemLink;
class SchemeItemAfb;
class SchemeItemConst;
class DeviceObject;
class DeviceRoot;
class DeviceSystem;
class DeviceRack;
class DeviceChassis;
class DeviceModule;
class DeviceController;
class DeviceSignal;
class Workstation;
class Software;
class ModuleConfiguration;
class ModuleConfigurationValue;
class Property;

enum SchemeUnit {
  Display = 0,
  Millimeter = 1,
  Inch = 2
};
bool SchemeUnit_IsValid(int value);
const SchemeUnit SchemeUnit_MIN = Display;
const SchemeUnit SchemeUnit_MAX = Inch;
const int SchemeUnit_ARRAYSIZE = SchemeUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* SchemeUnit_descriptor();
inline const ::std::string& SchemeUnit_Name(SchemeUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    SchemeUnit_descriptor(), value);
}
inline bool SchemeUnit_Parse(
    const ::std::string& name, SchemeUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SchemeUnit>(
    SchemeUnit_descriptor(), name, value);
}
enum ConnectionDirrection {
  Input = 0,
  Output = 1
};
bool ConnectionDirrection_IsValid(int value);
const ConnectionDirrection ConnectionDirrection_MIN = Input;
const ConnectionDirrection ConnectionDirrection_MAX = Output;
const int ConnectionDirrection_ARRAYSIZE = ConnectionDirrection_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionDirrection_descriptor();
inline const ::std::string& ConnectionDirrection_Name(ConnectionDirrection value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionDirrection_descriptor(), value);
}
inline bool ConnectionDirrection_Parse(
    const ::std::string& name, ConnectionDirrection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionDirrection>(
    ConnectionDirrection_descriptor(), name, value);
}
enum FblSignalType {
  Analog = 0,
  Discrete = 1
};
bool FblSignalType_IsValid(int value);
const FblSignalType FblSignalType_MIN = Analog;
const FblSignalType FblSignalType_MAX = Discrete;
const int FblSignalType_ARRAYSIZE = FblSignalType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FblSignalType_descriptor();
inline const ::std::string& FblSignalType_Name(FblSignalType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FblSignalType_descriptor(), value);
}
inline bool FblSignalType_Parse(
    const ::std::string& name, FblSignalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FblSignalType>(
    FblSignalType_descriptor(), name, value);
}
enum FblParamType {
  AnalogIntegral = 0,
  AnalogFloatingPoint = 1,
  DiscreteValue = 2
};
bool FblParamType_IsValid(int value);
const FblParamType FblParamType_MIN = AnalogIntegral;
const FblParamType FblParamType_MAX = DiscreteValue;
const int FblParamType_ARRAYSIZE = FblParamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FblParamType_descriptor();
inline const ::std::string& FblParamType_Name(FblParamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FblParamType_descriptor(), value);
}
inline bool FblParamType_Parse(
    const ::std::string& name, FblParamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FblParamType>(
    FblParamType_descriptor(), name, value);
}
// ===================================================================

class Uuid : public ::google::protobuf::Message {
 public:
  Uuid();
  virtual ~Uuid();

  Uuid(const Uuid& from);

  inline Uuid& operator=(const Uuid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uuid& default_instance();

  void Swap(Uuid* other);

  // implements Message ----------------------------------------------

  Uuid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Uuid& from);
  void MergeFrom(const Uuid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:Proto.Uuid)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Uuid* default_instance_;
};
// -------------------------------------------------------------------

class qvariant : public ::google::protobuf::Message {
 public:
  qvariant();
  virtual ~qvariant();

  qvariant(const qvariant& from);

  inline qvariant& operator=(const qvariant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const qvariant& default_instance();

  void Swap(qvariant* other);

  // implements Message ----------------------------------------------

  qvariant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const qvariant& from);
  void MergeFrom(const qvariant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 intValue = 2 [default = 0];
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional uint32 uintValue = 3 [default = 0];
  inline bool has_uintvalue() const;
  inline void clear_uintvalue();
  static const int kUintValueFieldNumber = 3;
  inline ::google::protobuf::uint32 uintvalue() const;
  inline void set_uintvalue(::google::protobuf::uint32 value);

  // optional double doubleValue = 4 [default = 0];
  inline bool has_doublevalue() const;
  inline void clear_doublevalue();
  static const int kDoubleValueFieldNumber = 4;
  inline double doublevalue() const;
  inline void set_doublevalue(double value);

  // optional bool boolValue = 5 [default = false];
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 5;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  // @@protoc_insertion_point(class_scope:Proto.qvariant)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_uintvalue();
  inline void clear_has_uintvalue();
  inline void set_has_doublevalue();
  inline void clear_has_doublevalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 intvalue_;
  double doublevalue_;
  ::google::protobuf::uint32 uintvalue_;
  bool boolvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static qvariant* default_instance_;
};
// -------------------------------------------------------------------

class wstring : public ::google::protobuf::Message {
 public:
  wstring();
  virtual ~wstring();

  wstring(const wstring& from);

  inline wstring& operator=(const wstring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wstring& default_instance();

  void Swap(wstring* other);

  // implements Message ----------------------------------------------

  wstring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wstring& from);
  void MergeFrom(const wstring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:Proto.wstring)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static wstring* default_instance_;
};
// -------------------------------------------------------------------

class FontParam : public ::google::protobuf::Message {
 public:
  FontParam();
  virtual ~FontParam();

  FontParam(const FontParam& from);

  inline FontParam& operator=(const FontParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FontParam& default_instance();

  void Swap(FontParam* other);

  // implements Message ----------------------------------------------

  FontParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FontParam& from);
  void MergeFrom(const FontParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::Proto::wstring& name() const;
  inline ::Proto::wstring* mutable_name();
  inline ::Proto::wstring* release_name();
  inline void set_allocated_name(::Proto::wstring* name);

  // required double size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline double size() const;
  inline void set_size(double value);

  // required bool bold = 3;
  inline bool has_bold() const;
  inline void clear_bold();
  static const int kBoldFieldNumber = 3;
  inline bool bold() const;
  inline void set_bold(bool value);

  // required bool italic = 4;
  inline bool has_italic() const;
  inline void clear_italic();
  static const int kItalicFieldNumber = 4;
  inline bool italic() const;
  inline void set_italic(bool value);

  // @@protoc_insertion_point(class_scope:Proto.FontParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_bold();
  inline void clear_has_bold();
  inline void set_has_italic();
  inline void clear_has_italic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* name_;
  double size_;
  bool bold_;
  bool italic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FontParam* default_instance_;
};
// -------------------------------------------------------------------

class SchemePoint : public ::google::protobuf::Message {
 public:
  SchemePoint();
  virtual ~SchemePoint();

  SchemePoint(const SchemePoint& from);

  inline SchemePoint& operator=(const SchemePoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemePoint& default_instance();

  void Swap(SchemePoint* other);

  // implements Message ----------------------------------------------

  SchemePoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemePoint& from);
  void MergeFrom(const SchemePoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // @@protoc_insertion_point(class_scope:Proto.SchemePoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemePoint* default_instance_;
};
// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 classnamehash = 1;
  inline bool has_classnamehash() const;
  inline void clear_classnamehash();
  static const int kClassnamehashFieldNumber = 1;
  inline ::google::protobuf::uint32 classnamehash() const;
  inline void set_classnamehash(::google::protobuf::uint32 value);

  // optional .Proto.SchemeItem schemeitem = 6;
  inline bool has_schemeitem() const;
  inline void clear_schemeitem();
  static const int kSchemeitemFieldNumber = 6;
  inline const ::Proto::SchemeItem& schemeitem() const;
  inline ::Proto::SchemeItem* mutable_schemeitem();
  inline ::Proto::SchemeItem* release_schemeitem();
  inline void set_allocated_schemeitem(::Proto::SchemeItem* schemeitem);

  // optional .Proto.DeviceObject deviceobject = 7;
  inline bool has_deviceobject() const;
  inline void clear_deviceobject();
  static const int kDeviceobjectFieldNumber = 7;
  inline const ::Proto::DeviceObject& deviceobject() const;
  inline ::Proto::DeviceObject* mutable_deviceobject();
  inline ::Proto::DeviceObject* release_deviceobject();
  inline void set_allocated_deviceobject(::Proto::DeviceObject* deviceobject);

  // optional .Proto.Scheme scheme = 100;
  inline bool has_scheme() const;
  inline void clear_scheme();
  static const int kSchemeFieldNumber = 100;
  inline const ::Proto::Scheme& scheme() const;
  inline ::Proto::Scheme* mutable_scheme();
  inline ::Proto::Scheme* release_scheme();
  inline void set_allocated_scheme(::Proto::Scheme* scheme);

  // optional .Proto.SchemeLayer schemelayer = 101;
  inline bool has_schemelayer() const;
  inline void clear_schemelayer();
  static const int kSchemelayerFieldNumber = 101;
  inline const ::Proto::SchemeLayer& schemelayer() const;
  inline ::Proto::SchemeLayer* mutable_schemelayer();
  inline ::Proto::SchemeLayer* release_schemelayer();
  inline void set_allocated_schemelayer(::Proto::SchemeLayer* schemelayer);

  // optional .Proto.FblElement fblelement = 102;
  inline bool has_fblelement() const;
  inline void clear_fblelement();
  static const int kFblelementFieldNumber = 102;
  inline const ::Proto::FblElement& fblelement() const;
  inline ::Proto::FblElement* mutable_fblelement();
  inline ::Proto::FblElement* release_fblelement();
  inline void set_allocated_fblelement(::Proto::FblElement* fblelement);

  // optional .Proto.Configuration configuration = 103;
  inline bool has_configuration() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 103;
  inline const ::Proto::Configuration& configuration() const;
  inline ::Proto::Configuration* mutable_configuration();
  inline ::Proto::Configuration* release_configuration();
  inline void set_allocated_configuration(::Proto::Configuration* configuration);

  // @@protoc_insertion_point(class_scope:Proto.Envelope)
 private:
  inline void set_has_classnamehash();
  inline void clear_has_classnamehash();
  inline void set_has_schemeitem();
  inline void clear_has_schemeitem();
  inline void set_has_deviceobject();
  inline void clear_has_deviceobject();
  inline void set_has_scheme();
  inline void clear_has_scheme();
  inline void set_has_schemelayer();
  inline void clear_has_schemelayer();
  inline void set_has_fblelement();
  inline void clear_has_fblelement();
  inline void set_has_configuration();
  inline void clear_has_configuration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::SchemeItem* schemeitem_;
  ::Proto::DeviceObject* deviceobject_;
  ::Proto::Scheme* scheme_;
  ::Proto::SchemeLayer* schemelayer_;
  ::Proto::FblElement* fblelement_;
  ::Proto::Configuration* configuration_;
  ::google::protobuf::uint32 classnamehash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.wstring variables = 4;
  inline bool has_variables() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 4;
  inline const ::Proto::wstring& variables() const;
  inline ::Proto::wstring* mutable_variables();
  inline ::Proto::wstring* release_variables();
  inline void set_allocated_variables(::Proto::wstring* variables);

  // required .Proto.wstring globals = 5;
  inline bool has_globals() const;
  inline void clear_globals();
  static const int kGlobalsFieldNumber = 5;
  inline const ::Proto::wstring& globals() const;
  inline ::Proto::wstring* mutable_globals();
  inline ::Proto::wstring* release_globals();
  inline void set_allocated_globals(::Proto::wstring* globals);

  // repeated .Proto.Uuid schemesIDs = 100;
  inline int schemesids_size() const;
  inline void clear_schemesids();
  static const int kSchemesIDsFieldNumber = 100;
  inline const ::Proto::Uuid& schemesids(int index) const;
  inline ::Proto::Uuid* mutable_schemesids(int index);
  inline ::Proto::Uuid* add_schemesids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
      schemesids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
      mutable_schemesids();

  // repeated .Proto.Envelope schemes = 101;
  inline int schemes_size() const;
  inline void clear_schemes();
  static const int kSchemesFieldNumber = 101;
  inline const ::Proto::Envelope& schemes(int index) const;
  inline ::Proto::Envelope* mutable_schemes(int index);
  inline ::Proto::Envelope* add_schemes();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      schemes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_schemes();

  // @@protoc_insertion_point(class_scope:Proto.Configuration)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_variables();
  inline void clear_has_variables();
  inline void set_has_globals();
  inline void clear_has_globals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::Proto::wstring* variables_;
  ::Proto::wstring* globals_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Uuid > schemesids_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > schemes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class AfbElementCollection : public ::google::protobuf::Message {
 public:
  AfbElementCollection();
  virtual ~AfbElementCollection();

  AfbElementCollection(const AfbElementCollection& from);

  inline AfbElementCollection& operator=(const AfbElementCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbElementCollection& default_instance();

  void Swap(AfbElementCollection* other);

  // implements Message ----------------------------------------------

  AfbElementCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbElementCollection& from);
  void MergeFrom(const AfbElementCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.AfbElementXml elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Proto::AfbElementXml& elements(int index) const;
  inline ::Proto::AfbElementXml* mutable_elements(int index);
  inline ::Proto::AfbElementXml* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Proto.AfbElementCollection)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml > elements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbElementCollection* default_instance_;
};
// -------------------------------------------------------------------

class AfbElementXml : public ::google::protobuf::Message {
 public:
  AfbElementXml();
  virtual ~AfbElementXml();

  AfbElementXml(const AfbElementXml& from);

  inline AfbElementXml& operator=(const AfbElementXml& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AfbElementXml& default_instance();

  void Swap(AfbElementXml* other);

  // implements Message ----------------------------------------------

  AfbElementXml* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AfbElementXml& from);
  void MergeFrom(const AfbElementXml& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Proto.AfbElementXml)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static AfbElementXml* default_instance_;
};
// -------------------------------------------------------------------

class FblElement : public ::google::protobuf::Message {
 public:
  FblElement();
  virtual ~FblElement();

  FblElement(const FblElement& from);

  inline FblElement& operator=(const FblElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblElement& default_instance();

  void Swap(FblElement* other);

  // implements Message ----------------------------------------------

  FblElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblElement& from);
  void MergeFrom(const FblElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required uint32 opcode = 4;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 4;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);

  // optional bool hasRam = 5 [default = false];
  inline bool has_hasram() const;
  inline void clear_hasram();
  static const int kHasRamFieldNumber = 5;
  inline bool hasram() const;
  inline void set_hasram(bool value);

  // optional bool requiredStart = 6 [default = true];
  inline bool has_requiredstart() const;
  inline void clear_requiredstart();
  static const int kRequiredStartFieldNumber = 6;
  inline bool requiredstart() const;
  inline void set_requiredstart(bool value);

  // repeated .Proto.FblElementSignal inputSignals = 11;
  inline int inputsignals_size() const;
  inline void clear_inputsignals();
  static const int kInputSignalsFieldNumber = 11;
  inline const ::Proto::FblElementSignal& inputsignals(int index) const;
  inline ::Proto::FblElementSignal* mutable_inputsignals(int index);
  inline ::Proto::FblElementSignal* add_inputsignals();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >&
      inputsignals() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >*
      mutable_inputsignals();

  // repeated .Proto.FblElementSignal outputSignals = 12;
  inline int outputsignals_size() const;
  inline void clear_outputsignals();
  static const int kOutputSignalsFieldNumber = 12;
  inline const ::Proto::FblElementSignal& outputsignals(int index) const;
  inline ::Proto::FblElementSignal* mutable_outputsignals(int index);
  inline ::Proto::FblElementSignal* add_outputsignals();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >&
      outputsignals() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >*
      mutable_outputsignals();

  // repeated .Proto.FblElementParam params = 13;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 13;
  inline const ::Proto::FblElementParam& params(int index) const;
  inline ::Proto::FblElementParam* mutable_params(int index);
  inline ::Proto::FblElementParam* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >*
      mutable_params();

  // optional .Proto.wstring description = 14;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 14;
  inline const ::Proto::wstring& description() const;
  inline ::Proto::wstring* mutable_description();
  inline ::Proto::wstring* release_description();
  inline void set_allocated_description(::Proto::wstring* description);

  // @@protoc_insertion_point(class_scope:Proto.FblElement)
 private:
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_hasram();
  inline void clear_has_hasram();
  inline void set_has_requiredstart();
  inline void clear_has_requiredstart();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::google::protobuf::uint32 opcode_;
  bool hasram_;
  bool requiredstart_;
  ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal > inputsignals_;
  ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal > outputsignals_;
  ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam > params_;
  ::Proto::wstring* description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblElement* default_instance_;
};
// -------------------------------------------------------------------

class FblElementSignal : public ::google::protobuf::Message {
 public:
  FblElementSignal();
  virtual ~FblElementSignal();

  FblElementSignal(const FblElementSignal& from);

  inline FblElementSignal& operator=(const FblElementSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblElementSignal& default_instance();

  void Swap(FblElementSignal* other);

  // implements Message ----------------------------------------------

  FblElementSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblElementSignal& from);
  void MergeFrom(const FblElementSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.FblSignalType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Proto::FblSignalType type() const;
  inline void set_type(::Proto::FblSignalType value);

  // optional int32 operandIndex = 3 [default = 0];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 3;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional int32 size = 4 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional .Proto.wstring opName = 5;
  inline bool has_opname() const;
  inline void clear_opname();
  static const int kOpNameFieldNumber = 5;
  inline const ::Proto::wstring& opname() const;
  inline ::Proto::wstring* mutable_opname();
  inline ::Proto::wstring* release_opname();
  inline void set_allocated_opname(::Proto::wstring* opname);

  // @@protoc_insertion_point(class_scope:Proto.FblElementSignal)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_opname();
  inline void clear_has_opname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* caption_;
  int type_;
  ::google::protobuf::int32 operandindex_;
  ::Proto::wstring* opname_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblElementSignal* default_instance_;
};
// -------------------------------------------------------------------

class FblElementParam : public ::google::protobuf::Message {
 public:
  FblElementParam();
  virtual ~FblElementParam();

  FblElementParam(const FblElementParam& from);

  inline FblElementParam& operator=(const FblElementParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblElementParam& default_instance();

  void Swap(FblElementParam* other);

  // implements Message ----------------------------------------------

  FblElementParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblElementParam& from);
  void MergeFrom(const FblElementParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.wstring caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required .Proto.FblParamType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Proto::FblParamType type() const;
  inline void set_type(::Proto::FblParamType value);

  // required bool visible = 7;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 7;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional int32 operandIndex = 8 [default = 0];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 8;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional int32 size = 9 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional bool instantiator = 10 [default = false];
  inline bool has_instantiator() const;
  inline void clear_instantiator();
  static const int kInstantiatorFieldNumber = 10;
  inline bool instantiator() const;
  inline void set_instantiator(bool value);

  // optional bool user = 11 [default = false];
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 11;
  inline bool user() const;
  inline void set_user(bool value);

  // optional .Proto.wstring changedScript = 12;
  inline bool has_changedscript() const;
  inline void clear_changedscript();
  static const int kChangedScriptFieldNumber = 12;
  inline const ::Proto::wstring& changedscript() const;
  inline ::Proto::wstring* mutable_changedscript();
  inline ::Proto::wstring* release_changedscript();
  inline void set_allocated_changedscript(::Proto::wstring* changedscript);

  // optional .Proto.qvariant value = 13;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 13;
  inline const ::Proto::qvariant& value() const;
  inline ::Proto::qvariant* mutable_value();
  inline ::Proto::qvariant* release_value();
  inline void set_allocated_value(::Proto::qvariant* value);

  // optional .Proto.qvariant defaultvalue = 14;
  inline bool has_defaultvalue() const;
  inline void clear_defaultvalue();
  static const int kDefaultvalueFieldNumber = 14;
  inline const ::Proto::qvariant& defaultvalue() const;
  inline ::Proto::qvariant* mutable_defaultvalue();
  inline ::Proto::qvariant* release_defaultvalue();
  inline void set_allocated_defaultvalue(::Proto::qvariant* defaultvalue);

  // optional .Proto.qvariant lowlimit = 15;
  inline bool has_lowlimit() const;
  inline void clear_lowlimit();
  static const int kLowlimitFieldNumber = 15;
  inline const ::Proto::qvariant& lowlimit() const;
  inline ::Proto::qvariant* mutable_lowlimit();
  inline ::Proto::qvariant* release_lowlimit();
  inline void set_allocated_lowlimit(::Proto::qvariant* lowlimit);

  // optional .Proto.qvariant highlimit = 16;
  inline bool has_highlimit() const;
  inline void clear_highlimit();
  static const int kHighlimitFieldNumber = 16;
  inline const ::Proto::qvariant& highlimit() const;
  inline ::Proto::qvariant* mutable_highlimit();
  inline ::Proto::qvariant* release_highlimit();
  inline void set_allocated_highlimit(::Proto::qvariant* highlimit);

  // optional .Proto.wstring opName = 17;
  inline bool has_opname() const;
  inline void clear_opname();
  static const int kOpNameFieldNumber = 17;
  inline const ::Proto::wstring& opname() const;
  inline ::Proto::wstring* mutable_opname();
  inline ::Proto::wstring* release_opname();
  inline void set_allocated_opname(::Proto::wstring* opname);

  // @@protoc_insertion_point(class_scope:Proto.FblElementParam)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_instantiator();
  inline void clear_has_instantiator();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_changedscript();
  inline void clear_has_changedscript();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_defaultvalue();
  inline void clear_has_defaultvalue();
  inline void set_has_lowlimit();
  inline void clear_has_lowlimit();
  inline void set_has_highlimit();
  inline void clear_has_highlimit();
  inline void set_has_opname();
  inline void clear_has_opname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::wstring* caption_;
  int type_;
  ::google::protobuf::int32 operandindex_;
  ::google::protobuf::int32 size_;
  bool visible_;
  bool instantiator_;
  bool user_;
  ::Proto::wstring* changedscript_;
  ::Proto::qvariant* value_;
  ::Proto::qvariant* defaultvalue_;
  ::Proto::qvariant* lowlimit_;
  ::Proto::qvariant* highlimit_;
  ::Proto::wstring* opname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblElementParam* default_instance_;
};
// -------------------------------------------------------------------

class Scheme : public ::google::protobuf::Message {
 public:
  Scheme();
  virtual ~Scheme();

  Scheme(const Scheme& from);

  inline Scheme& operator=(const Scheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scheme& default_instance();

  void Swap(Scheme* other);

  // implements Message ----------------------------------------------

  Scheme* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scheme& from);
  void MergeFrom(const Scheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring strID = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIDFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // required double width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline double width() const;
  inline void set_width(double value);

  // required double height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline double height() const;
  inline void set_height(double value);

  // required .Proto.SchemeUnit unit = 6;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 6;
  inline ::Proto::SchemeUnit unit() const;
  inline void set_unit(::Proto::SchemeUnit value);

  // optional bool excludeFromBuild = 7 [default = false];
  inline bool has_excludefrombuild() const;
  inline void clear_excludefrombuild();
  static const int kExcludeFromBuildFieldNumber = 7;
  inline bool excludefrombuild() const;
  inline void set_excludefrombuild(bool value);

  // repeated .Proto.Envelope layers = 100;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 100;
  inline const ::Proto::Envelope& layers(int index) const;
  inline ::Proto::Envelope* mutable_layers(int index);
  inline ::Proto::Envelope* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_layers();

  // required .Proto.AfbElementCollection afbs = 101;
  inline bool has_afbs() const;
  inline void clear_afbs();
  static const int kAfbsFieldNumber = 101;
  inline const ::Proto::AfbElementCollection& afbs() const;
  inline ::Proto::AfbElementCollection* mutable_afbs();
  inline ::Proto::AfbElementCollection* release_afbs();
  inline void set_allocated_afbs(::Proto::AfbElementCollection* afbs);

  // optional .Proto.LogicScheme logics_scheme = 200;
  inline bool has_logics_scheme() const;
  inline void clear_logics_scheme();
  static const int kLogicsSchemeFieldNumber = 200;
  inline const ::Proto::LogicScheme& logics_scheme() const;
  inline ::Proto::LogicScheme* mutable_logics_scheme();
  inline ::Proto::LogicScheme* release_logics_scheme();
  inline void set_allocated_logics_scheme(::Proto::LogicScheme* logics_scheme);

  // @@protoc_insertion_point(class_scope:Proto.Scheme)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_excludefrombuild();
  inline void clear_has_excludefrombuild();
  inline void set_has_afbs();
  inline void clear_has_afbs();
  inline void set_has_logics_scheme();
  inline void clear_has_logics_scheme();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  double width_;
  double height_;
  int unit_;
  bool excludefrombuild_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > layers_;
  ::Proto::AfbElementCollection* afbs_;
  ::Proto::LogicScheme* logics_scheme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Scheme* default_instance_;
};
// -------------------------------------------------------------------

class LogicScheme : public ::google::protobuf::Message {
 public:
  LogicScheme();
  virtual ~LogicScheme();

  LogicScheme(const LogicScheme& from);

  inline LogicScheme& operator=(const LogicScheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicScheme& default_instance();

  void Swap(LogicScheme* other);

  // implements Message ----------------------------------------------

  LogicScheme* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicScheme& from);
  void MergeFrom(const LogicScheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.wstring hardware_strids = 1;
  inline int hardware_strids_size() const;
  inline void clear_hardware_strids();
  static const int kHardwareStridsFieldNumber = 1;
  inline const ::Proto::wstring& hardware_strids(int index) const;
  inline ::Proto::wstring* mutable_hardware_strids(int index);
  inline ::Proto::wstring* add_hardware_strids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
      hardware_strids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
      mutable_hardware_strids();

  // @@protoc_insertion_point(class_scope:Proto.LogicScheme)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::wstring > hardware_strids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static LogicScheme* default_instance_;
};
// -------------------------------------------------------------------

class SchemeLayer : public ::google::protobuf::Message {
 public:
  SchemeLayer();
  virtual ~SchemeLayer();

  SchemeLayer(const SchemeLayer& from);

  inline SchemeLayer& operator=(const SchemeLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeLayer& default_instance();

  void Swap(SchemeLayer* other);

  // implements Message ----------------------------------------------

  SchemeLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeLayer& from);
  void MergeFrom(const SchemeLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::Proto::wstring& name() const;
  inline ::Proto::wstring* mutable_name();
  inline ::Proto::wstring* release_name();
  inline void set_allocated_name(::Proto::wstring* name);

  // required bool compile = 3;
  inline bool has_compile() const;
  inline void clear_compile();
  static const int kCompileFieldNumber = 3;
  inline bool compile() const;
  inline void set_compile(bool value);

  // required bool show = 4;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 4;
  inline bool show() const;
  inline void set_show(bool value);

  // required bool print = 5;
  inline bool has_print() const;
  inline void clear_print();
  static const int kPrintFieldNumber = 5;
  inline bool print() const;
  inline void set_print(bool value);

  // repeated .Proto.Envelope items = 15;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 15;
  inline const ::Proto::Envelope& items(int index) const;
  inline ::Proto::Envelope* mutable_items(int index);
  inline ::Proto::Envelope* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Proto.SchemeLayer)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_compile();
  inline void clear_has_compile();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_print();
  inline void clear_has_print();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* name_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Envelope > items_;
  bool compile_;
  bool show_;
  bool print_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeLayer* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItem : public ::google::protobuf::Message {
 public:
  SchemeItem();
  virtual ~SchemeItem();

  SchemeItem(const SchemeItem& from);

  inline SchemeItem& operator=(const SchemeItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItem& default_instance();

  void Swap(SchemeItem* other);

  // implements Message ----------------------------------------------

  SchemeItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItem& from);
  void MergeFrom(const SchemeItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required bool isStatic = 2;
  inline bool has_isstatic() const;
  inline void clear_isstatic();
  static const int kIsStaticFieldNumber = 2;
  inline bool isstatic() const;
  inline void set_isstatic(bool value);

  // required bool isLocked = 3;
  inline bool has_islocked() const;
  inline void clear_islocked();
  static const int kIsLockedFieldNumber = 3;
  inline bool islocked() const;
  inline void set_islocked(bool value);

  // required .Proto.SchemeUnit itemUnit = 4;
  inline bool has_itemunit() const;
  inline void clear_itemunit();
  static const int kItemUnitFieldNumber = 4;
  inline ::Proto::SchemeUnit itemunit() const;
  inline void set_itemunit(::Proto::SchemeUnit value);

  // optional bool acceptClick = 5 [default = false];
  inline bool has_acceptclick() const;
  inline void clear_acceptclick();
  static const int kAcceptClickFieldNumber = 5;
  inline bool acceptclick() const;
  inline void set_acceptclick(bool value);

  // optional .Proto.wstring clickScript = 6;
  inline bool has_clickscript() const;
  inline void clear_clickscript();
  static const int kClickScriptFieldNumber = 6;
  inline const ::Proto::wstring& clickscript() const;
  inline ::Proto::wstring* mutable_clickscript();
  inline ::Proto::wstring* release_clickscript();
  inline void set_allocated_clickscript(::Proto::wstring* clickscript);

  // optional .Proto.PosRectImpl PosRectImpl = 10;
  inline bool has_posrectimpl() const;
  inline void clear_posrectimpl();
  static const int kPosRectImplFieldNumber = 10;
  inline const ::Proto::PosRectImpl& posrectimpl() const;
  inline ::Proto::PosRectImpl* mutable_posrectimpl();
  inline ::Proto::PosRectImpl* release_posrectimpl();
  inline void set_allocated_posrectimpl(::Proto::PosRectImpl* posrectimpl);

  // optional .Proto.PosLineImpl PosLineImpl = 11;
  inline bool has_poslineimpl() const;
  inline void clear_poslineimpl();
  static const int kPosLineImplFieldNumber = 11;
  inline const ::Proto::PosLineImpl& poslineimpl() const;
  inline ::Proto::PosLineImpl* mutable_poslineimpl();
  inline ::Proto::PosLineImpl* release_poslineimpl();
  inline void set_allocated_poslineimpl(::Proto::PosLineImpl* poslineimpl);

  // optional .Proto.PosConnectionImpl PosConnectionImpl = 12;
  inline bool has_posconnectionimpl() const;
  inline void clear_posconnectionimpl();
  static const int kPosConnectionImplFieldNumber = 12;
  inline const ::Proto::PosConnectionImpl& posconnectionimpl() const;
  inline ::Proto::PosConnectionImpl* mutable_posconnectionimpl();
  inline ::Proto::PosConnectionImpl* release_posconnectionimpl();
  inline void set_allocated_posconnectionimpl(::Proto::PosConnectionImpl* posconnectionimpl);

  // optional .Proto.FblItem FblItem = 106;
  inline bool has_fblitem() const;
  inline void clear_fblitem();
  static const int kFblItemFieldNumber = 106;
  inline const ::Proto::FblItem& fblitem() const;
  inline ::Proto::FblItem* mutable_fblitem();
  inline ::Proto::FblItem* release_fblitem();
  inline void set_allocated_fblitem(::Proto::FblItem* fblitem);

  // optional .Proto.FblItemRect FblItemRect = 107;
  inline bool has_fblitemrect() const;
  inline void clear_fblitemrect();
  static const int kFblItemRectFieldNumber = 107;
  inline const ::Proto::FblItemRect& fblitemrect() const;
  inline ::Proto::FblItemRect* mutable_fblitemrect();
  inline ::Proto::FblItemRect* release_fblitemrect();
  inline void set_allocated_fblitemrect(::Proto::FblItemRect* fblitemrect);

  // optional .Proto.FblItemLine FblItemLine = 108;
  inline bool has_fblitemline() const;
  inline void clear_fblitemline();
  static const int kFblItemLineFieldNumber = 108;
  inline const ::Proto::FblItemLine& fblitemline() const;
  inline ::Proto::FblItemLine* mutable_fblitemline();
  inline ::Proto::FblItemLine* release_fblitemline();
  inline void set_allocated_fblitemline(::Proto::FblItemLine* fblitemline);

  // optional .Proto.SchemeItemRect Rect = 116;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 116;
  inline const ::Proto::SchemeItemRect& rect() const;
  inline ::Proto::SchemeItemRect* mutable_rect();
  inline ::Proto::SchemeItemRect* release_rect();
  inline void set_allocated_rect(::Proto::SchemeItemRect* rect);

  // optional .Proto.SchemeItemLine Line = 117;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 117;
  inline const ::Proto::SchemeItemLine& line() const;
  inline ::Proto::SchemeItemLine* mutable_line();
  inline ::Proto::SchemeItemLine* release_line();
  inline void set_allocated_line(::Proto::SchemeItemLine* line);

  // optional .Proto.SchemeItemPath Path = 118;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 118;
  inline const ::Proto::SchemeItemPath& path() const;
  inline ::Proto::SchemeItemPath* mutable_path();
  inline ::Proto::SchemeItemPath* release_path();
  inline void set_allocated_path(::Proto::SchemeItemPath* path);

  // optional .Proto.SchemeItemSignal Signal = 124;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 124;
  inline const ::Proto::SchemeItemSignal& signal() const;
  inline ::Proto::SchemeItemSignal* mutable_signal();
  inline ::Proto::SchemeItemSignal* release_signal();
  inline void set_allocated_signal(::Proto::SchemeItemSignal* signal);

  // optional .Proto.SchemeItemInput InputSignal = 125;
  inline bool has_inputsignal() const;
  inline void clear_inputsignal();
  static const int kInputSignalFieldNumber = 125;
  inline const ::Proto::SchemeItemInput& inputsignal() const;
  inline ::Proto::SchemeItemInput* mutable_inputsignal();
  inline ::Proto::SchemeItemInput* release_inputsignal();
  inline void set_allocated_inputsignal(::Proto::SchemeItemInput* inputsignal);

  // optional .Proto.SchemeItemOutput OutputSignal = 126;
  inline bool has_outputsignal() const;
  inline void clear_outputsignal();
  static const int kOutputSignalFieldNumber = 126;
  inline const ::Proto::SchemeItemOutput& outputsignal() const;
  inline ::Proto::SchemeItemOutput* mutable_outputsignal();
  inline ::Proto::SchemeItemOutput* release_outputsignal();
  inline void set_allocated_outputsignal(::Proto::SchemeItemOutput* outputsignal);

  // optional .Proto.SchemeItemLink Link = 127;
  inline bool has_link() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 127;
  inline const ::Proto::SchemeItemLink& link() const;
  inline ::Proto::SchemeItemLink* mutable_link();
  inline ::Proto::SchemeItemLink* release_link();
  inline void set_allocated_link(::Proto::SchemeItemLink* link);

  // optional .Proto.SchemeItemAfb Afb = 128;
  inline bool has_afb() const;
  inline void clear_afb();
  static const int kAfbFieldNumber = 128;
  inline const ::Proto::SchemeItemAfb& afb() const;
  inline ::Proto::SchemeItemAfb* mutable_afb();
  inline ::Proto::SchemeItemAfb* release_afb();
  inline void set_allocated_afb(::Proto::SchemeItemAfb* afb);

  // optional .Proto.SchemeItemConst ConstItem = 129;
  inline bool has_constitem() const;
  inline void clear_constitem();
  static const int kConstItemFieldNumber = 129;
  inline const ::Proto::SchemeItemConst& constitem() const;
  inline ::Proto::SchemeItemConst* mutable_constitem();
  inline ::Proto::SchemeItemConst* release_constitem();
  inline void set_allocated_constitem(::Proto::SchemeItemConst* constitem);

  // @@protoc_insertion_point(class_scope:Proto.SchemeItem)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_isstatic();
  inline void clear_has_isstatic();
  inline void set_has_islocked();
  inline void clear_has_islocked();
  inline void set_has_itemunit();
  inline void clear_has_itemunit();
  inline void set_has_acceptclick();
  inline void clear_has_acceptclick();
  inline void set_has_clickscript();
  inline void clear_has_clickscript();
  inline void set_has_posrectimpl();
  inline void clear_has_posrectimpl();
  inline void set_has_poslineimpl();
  inline void clear_has_poslineimpl();
  inline void set_has_posconnectionimpl();
  inline void clear_has_posconnectionimpl();
  inline void set_has_fblitem();
  inline void clear_has_fblitem();
  inline void set_has_fblitemrect();
  inline void clear_has_fblitemrect();
  inline void set_has_fblitemline();
  inline void clear_has_fblitemline();
  inline void set_has_rect();
  inline void clear_has_rect();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_inputsignal();
  inline void clear_has_inputsignal();
  inline void set_has_outputsignal();
  inline void clear_has_outputsignal();
  inline void set_has_link();
  inline void clear_has_link();
  inline void set_has_afb();
  inline void clear_has_afb();
  inline void set_has_constitem();
  inline void clear_has_constitem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  bool isstatic_;
  bool islocked_;
  bool acceptclick_;
  int itemunit_;
  ::Proto::wstring* clickscript_;
  ::Proto::PosRectImpl* posrectimpl_;
  ::Proto::PosLineImpl* poslineimpl_;
  ::Proto::PosConnectionImpl* posconnectionimpl_;
  ::Proto::FblItem* fblitem_;
  ::Proto::FblItemRect* fblitemrect_;
  ::Proto::FblItemLine* fblitemline_;
  ::Proto::SchemeItemRect* rect_;
  ::Proto::SchemeItemLine* line_;
  ::Proto::SchemeItemPath* path_;
  ::Proto::SchemeItemSignal* signal_;
  ::Proto::SchemeItemInput* inputsignal_;
  ::Proto::SchemeItemOutput* outputsignal_;
  ::Proto::SchemeItemLink* link_;
  ::Proto::SchemeItemAfb* afb_;
  ::Proto::SchemeItemConst* constitem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItem* default_instance_;
};
// -------------------------------------------------------------------

class PosRectImpl : public ::google::protobuf::Message {
 public:
  PosRectImpl();
  virtual ~PosRectImpl();

  PosRectImpl(const PosRectImpl& from);

  inline PosRectImpl& operator=(const PosRectImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosRectImpl& default_instance();

  void Swap(PosRectImpl* other);

  // implements Message ----------------------------------------------

  PosRectImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosRectImpl& from);
  void MergeFrom(const PosRectImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double leftDocPt = 1;
  inline bool has_leftdocpt() const;
  inline void clear_leftdocpt();
  static const int kLeftDocPtFieldNumber = 1;
  inline double leftdocpt() const;
  inline void set_leftdocpt(double value);

  // required double topDocPt = 2;
  inline bool has_topdocpt() const;
  inline void clear_topdocpt();
  static const int kTopDocPtFieldNumber = 2;
  inline double topdocpt() const;
  inline void set_topdocpt(double value);

  // required double widthDocPt = 3;
  inline bool has_widthdocpt() const;
  inline void clear_widthdocpt();
  static const int kWidthDocPtFieldNumber = 3;
  inline double widthdocpt() const;
  inline void set_widthdocpt(double value);

  // required double heightDocPt = 4;
  inline bool has_heightdocpt() const;
  inline void clear_heightdocpt();
  static const int kHeightDocPtFieldNumber = 4;
  inline double heightdocpt() const;
  inline void set_heightdocpt(double value);

  // @@protoc_insertion_point(class_scope:Proto.PosRectImpl)
 private:
  inline void set_has_leftdocpt();
  inline void clear_has_leftdocpt();
  inline void set_has_topdocpt();
  inline void clear_has_topdocpt();
  inline void set_has_widthdocpt();
  inline void clear_has_widthdocpt();
  inline void set_has_heightdocpt();
  inline void clear_has_heightdocpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double leftdocpt_;
  double topdocpt_;
  double widthdocpt_;
  double heightdocpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosRectImpl* default_instance_;
};
// -------------------------------------------------------------------

class PosLineImpl : public ::google::protobuf::Message {
 public:
  PosLineImpl();
  virtual ~PosLineImpl();

  PosLineImpl(const PosLineImpl& from);

  inline PosLineImpl& operator=(const PosLineImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosLineImpl& default_instance();

  void Swap(PosLineImpl* other);

  // implements Message ----------------------------------------------

  PosLineImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosLineImpl& from);
  void MergeFrom(const PosLineImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double startXDocPt = 1;
  inline bool has_startxdocpt() const;
  inline void clear_startxdocpt();
  static const int kStartXDocPtFieldNumber = 1;
  inline double startxdocpt() const;
  inline void set_startxdocpt(double value);

  // required double startYDocPt = 2;
  inline bool has_startydocpt() const;
  inline void clear_startydocpt();
  static const int kStartYDocPtFieldNumber = 2;
  inline double startydocpt() const;
  inline void set_startydocpt(double value);

  // required double endXDocPt = 3;
  inline bool has_endxdocpt() const;
  inline void clear_endxdocpt();
  static const int kEndXDocPtFieldNumber = 3;
  inline double endxdocpt() const;
  inline void set_endxdocpt(double value);

  // required double endYDocPt = 4;
  inline bool has_endydocpt() const;
  inline void clear_endydocpt();
  static const int kEndYDocPtFieldNumber = 4;
  inline double endydocpt() const;
  inline void set_endydocpt(double value);

  // @@protoc_insertion_point(class_scope:Proto.PosLineImpl)
 private:
  inline void set_has_startxdocpt();
  inline void clear_has_startxdocpt();
  inline void set_has_startydocpt();
  inline void clear_has_startydocpt();
  inline void set_has_endxdocpt();
  inline void clear_has_endxdocpt();
  inline void set_has_endydocpt();
  inline void clear_has_endydocpt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double startxdocpt_;
  double startydocpt_;
  double endxdocpt_;
  double endydocpt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosLineImpl* default_instance_;
};
// -------------------------------------------------------------------

class PosConnectionImpl : public ::google::protobuf::Message {
 public:
  PosConnectionImpl();
  virtual ~PosConnectionImpl();

  PosConnectionImpl(const PosConnectionImpl& from);

  inline PosConnectionImpl& operator=(const PosConnectionImpl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosConnectionImpl& default_instance();

  void Swap(PosConnectionImpl* other);

  // implements Message ----------------------------------------------

  PosConnectionImpl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosConnectionImpl& from);
  void MergeFrom(const PosConnectionImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.SchemePoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::Proto::SchemePoint& points(int index) const;
  inline ::Proto::SchemePoint* mutable_points(int index);
  inline ::Proto::SchemePoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemePoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemePoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Proto.PosConnectionImpl)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::SchemePoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static PosConnectionImpl* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemRect : public ::google::protobuf::Message {
 public:
  SchemeItemRect();
  virtual ~SchemeItemRect();

  SchemeItemRect(const SchemeItemRect& from);

  inline SchemeItemRect& operator=(const SchemeItemRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemRect& default_instance();

  void Swap(SchemeItemRect* other);

  // implements Message ----------------------------------------------

  SchemeItemRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemRect& from);
  void MergeFrom(const SchemeItemRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // required uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // required .Proto.wstring text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::Proto::wstring& text() const;
  inline ::Proto::wstring* mutable_text();
  inline ::Proto::wstring* release_text();
  inline void set_allocated_text(::Proto::wstring* text);

  // required uint32 textColor = 5;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 5;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // required .Proto.FontParam font = 6;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 6;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // required bool fill = 7;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 7;
  inline bool fill() const;
  inline void set_fill(bool value);

  // optional bool drawrect = 8 [default = true];
  inline bool has_drawrect() const;
  inline void clear_drawrect();
  static const int kDrawrectFieldNumber = 8;
  inline bool drawrect() const;
  inline void set_drawrect(bool value);

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemRect)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_drawrect();
  inline void clear_has_drawrect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::Proto::wstring* text_;
  ::Proto::FontParam* font_;
  ::google::protobuf::uint32 textcolor_;
  bool fill_;
  bool drawrect_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemRect* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemLine : public ::google::protobuf::Message {
 public:
  SchemeItemLine();
  virtual ~SchemeItemLine();

  SchemeItemLine(const SchemeItemLine& from);

  inline SchemeItemLine& operator=(const SchemeItemLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemLine& default_instance();

  void Swap(SchemeItemLine* other);

  // implements Message ----------------------------------------------

  SchemeItemLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemLine& from);
  void MergeFrom(const SchemeItemLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemLine)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemLine* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemPath : public ::google::protobuf::Message {
 public:
  SchemeItemPath();
  virtual ~SchemeItemPath();

  SchemeItemPath(const SchemeItemPath& from);

  inline SchemeItemPath& operator=(const SchemeItemPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemPath& default_instance();

  void Swap(SchemeItemPath* other);

  // implements Message ----------------------------------------------

  SchemeItemPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemPath& from);
  void MergeFrom(const SchemeItemPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemPath)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemPath* default_instance_;
};
// -------------------------------------------------------------------

class FblConnectionPoint : public ::google::protobuf::Message {
 public:
  FblConnectionPoint();
  virtual ~FblConnectionPoint();

  FblConnectionPoint(const FblConnectionPoint& from);

  inline FblConnectionPoint& operator=(const FblConnectionPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblConnectionPoint& default_instance();

  void Swap(FblConnectionPoint* other);

  // implements Message ----------------------------------------------

  FblConnectionPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblConnectionPoint& from);
  void MergeFrom(const FblConnectionPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.SchemePoint point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::Proto::SchemePoint& point() const;
  inline ::Proto::SchemePoint* mutable_point();
  inline ::Proto::SchemePoint* release_point();
  inline void set_allocated_point(::Proto::SchemePoint* point);

  // optional .Proto.ConnectionDirrection dirrection = 2;
  inline bool has_dirrection() const;
  inline void clear_dirrection();
  static const int kDirrectionFieldNumber = 2;
  inline ::Proto::ConnectionDirrection dirrection() const;
  inline void set_dirrection(::Proto::ConnectionDirrection value);

  // optional .Proto.Uuid uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // optional int32 operandIndex = 4 [default = -1];
  inline bool has_operandindex() const;
  inline void clear_operandindex();
  static const int kOperandIndexFieldNumber = 4;
  inline ::google::protobuf::int32 operandindex() const;
  inline void set_operandindex(::google::protobuf::int32 value);

  // optional string caption = 5 [default = ""];
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 5;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // @@protoc_insertion_point(class_scope:Proto.FblConnectionPoint)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_dirrection();
  inline void clear_has_dirrection();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_operandindex();
  inline void clear_has_operandindex();
  inline void set_has_caption();
  inline void clear_has_caption();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::SchemePoint* point_;
  ::Proto::Uuid* uuid_;
  int dirrection_;
  ::google::protobuf::int32 operandindex_;
  ::std::string* caption_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblConnectionPoint* default_instance_;
};
// -------------------------------------------------------------------

class FblItem : public ::google::protobuf::Message {
 public:
  FblItem();
  virtual ~FblItem();

  FblItem(const FblItem& from);

  inline FblItem& operator=(const FblItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItem& default_instance();

  void Swap(FblItem* other);

  // implements Message ----------------------------------------------

  FblItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItem& from);
  void MergeFrom(const FblItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.FblConnectionPoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::Proto::FblConnectionPoint& points(int index) const;
  inline ::Proto::FblConnectionPoint* mutable_points(int index);
  inline ::Proto::FblConnectionPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:Proto.FblItem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItem* default_instance_;
};
// -------------------------------------------------------------------

class FblItemRect : public ::google::protobuf::Message {
 public:
  FblItemRect();
  virtual ~FblItemRect();

  FblItemRect(const FblItemRect& from);

  inline FblItemRect& operator=(const FblItemRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItemRect& default_instance();

  void Swap(FblItemRect* other);

  // implements Message ----------------------------------------------

  FblItemRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItemRect& from);
  void MergeFrom(const FblItemRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // required uint32 fillColor = 3;
  inline bool has_fillcolor() const;
  inline void clear_fillcolor();
  static const int kFillColorFieldNumber = 3;
  inline ::google::protobuf::uint32 fillcolor() const;
  inline void set_fillcolor(::google::protobuf::uint32 value);

  // required uint32 textColor = 4;
  inline bool has_textcolor() const;
  inline void clear_textcolor();
  static const int kTextColorFieldNumber = 4;
  inline ::google::protobuf::uint32 textcolor() const;
  inline void set_textcolor(::google::protobuf::uint32 value);

  // required .Proto.FontParam font = 5;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 5;
  inline const ::Proto::FontParam& font() const;
  inline ::Proto::FontParam* mutable_font();
  inline ::Proto::FontParam* release_font();
  inline void set_allocated_font(::Proto::FontParam* font);

  // @@protoc_insertion_point(class_scope:Proto.FblItemRect)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();
  inline void set_has_fillcolor();
  inline void clear_has_fillcolor();
  inline void set_has_textcolor();
  inline void clear_has_textcolor();
  inline void set_has_font();
  inline void clear_has_font();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;
  ::google::protobuf::uint32 fillcolor_;
  ::Proto::FontParam* font_;
  ::google::protobuf::uint32 textcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItemRect* default_instance_;
};
// -------------------------------------------------------------------

class FblItemLine : public ::google::protobuf::Message {
 public:
  FblItemLine();
  virtual ~FblItemLine();

  FblItemLine(const FblItemLine& from);

  inline FblItemLine& operator=(const FblItemLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FblItemLine& default_instance();

  void Swap(FblItemLine* other);

  // implements Message ----------------------------------------------

  FblItemLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FblItemLine& from);
  void MergeFrom(const FblItemLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // required uint32 lineColor = 2;
  inline bool has_linecolor() const;
  inline void clear_linecolor();
  static const int kLineColorFieldNumber = 2;
  inline ::google::protobuf::uint32 linecolor() const;
  inline void set_linecolor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.FblItemLine)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_linecolor();
  inline void clear_has_linecolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double weight_;
  ::google::protobuf::uint32 linecolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static FblItemLine* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemSignal : public ::google::protobuf::Message {
 public:
  SchemeItemSignal();
  virtual ~SchemeItemSignal();

  SchemeItemSignal(const SchemeItemSignal& from);

  inline SchemeItemSignal& operator=(const SchemeItemSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemSignal& default_instance();

  void Swap(SchemeItemSignal* other);

  // implements Message ----------------------------------------------

  SchemeItemSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemSignal& from);
  void MergeFrom(const SchemeItemSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.wstring signalStrIDs = 1;
  inline int signalstrids_size() const;
  inline void clear_signalstrids();
  static const int kSignalStrIDsFieldNumber = 1;
  inline const ::Proto::wstring& signalstrids(int index) const;
  inline ::Proto::wstring* mutable_signalstrids(int index);
  inline ::Proto::wstring* add_signalstrids();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
      signalstrids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
      mutable_signalstrids();

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemSignal)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::wstring > signalstrids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemSignal* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemInput : public ::google::protobuf::Message {
 public:
  SchemeItemInput();
  virtual ~SchemeItemInput();

  SchemeItemInput(const SchemeItemInput& from);

  inline SchemeItemInput& operator=(const SchemeItemInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemInput& default_instance();

  void Swap(SchemeItemInput* other);

  // implements Message ----------------------------------------------

  SchemeItemInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemInput& from);
  void MergeFrom(const SchemeItemInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemInput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemInput* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemOutput : public ::google::protobuf::Message {
 public:
  SchemeItemOutput();
  virtual ~SchemeItemOutput();

  SchemeItemOutput(const SchemeItemOutput& from);

  inline SchemeItemOutput& operator=(const SchemeItemOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemOutput& default_instance();

  void Swap(SchemeItemOutput* other);

  // implements Message ----------------------------------------------

  SchemeItemOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemOutput& from);
  void MergeFrom(const SchemeItemOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemOutput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemOutput* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemLink : public ::google::protobuf::Message {
 public:
  SchemeItemLink();
  virtual ~SchemeItemLink();

  SchemeItemLink(const SchemeItemLink& from);

  inline SchemeItemLink& operator=(const SchemeItemLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemLink& default_instance();

  void Swap(SchemeItemLink* other);

  // implements Message ----------------------------------------------

  SchemeItemLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemLink& from);
  void MergeFrom(const SchemeItemLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemLink)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemLink* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemAfb : public ::google::protobuf::Message {
 public:
  SchemeItemAfb();
  virtual ~SchemeItemAfb();

  SchemeItemAfb(const SchemeItemAfb& from);

  inline SchemeItemAfb& operator=(const SchemeItemAfb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemAfb& default_instance();

  void Swap(SchemeItemAfb* other);

  // implements Message ----------------------------------------------

  SchemeItemAfb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemAfb& from);
  void MergeFrom(const SchemeItemAfb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.FblElementParam params = 2;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::Proto::FblElementParam& params(int index) const;
  inline ::Proto::FblElementParam* mutable_params(int index);
  inline ::Proto::FblElementParam* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >*
      mutable_params();

  // optional .Proto.wstring afbStrid = 3;
  inline bool has_afbstrid() const;
  inline void clear_afbstrid();
  static const int kAfbStridFieldNumber = 3;
  inline const ::Proto::wstring& afbstrid() const;
  inline ::Proto::wstring* mutable_afbstrid();
  inline ::Proto::wstring* release_afbstrid();
  inline void set_allocated_afbstrid(::Proto::wstring* afbstrid);

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemAfb)
 private:
  inline void set_has_afbstrid();
  inline void clear_has_afbstrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam > params_;
  ::Proto::wstring* afbstrid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemAfb* default_instance_;
};
// -------------------------------------------------------------------

class SchemeItemConst : public ::google::protobuf::Message {
 public:
  SchemeItemConst();
  virtual ~SchemeItemConst();

  SchemeItemConst(const SchemeItemConst& from);

  inline SchemeItemConst& operator=(const SchemeItemConst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemeItemConst& default_instance();

  void Swap(SchemeItemConst* other);

  // implements Message ----------------------------------------------

  SchemeItemConst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchemeItemConst& from);
  void MergeFrom(const SchemeItemConst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 intValue = 2 [default = 0];
  inline bool has_intvalue() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 intvalue() const;
  inline void set_intvalue(::google::protobuf::int32 value);

  // optional double floatValue = 3 [default = 0];
  inline bool has_floatvalue() const;
  inline void clear_floatvalue();
  static const int kFloatValueFieldNumber = 3;
  inline double floatvalue() const;
  inline void set_floatvalue(double value);

  // @@protoc_insertion_point(class_scope:Proto.SchemeItemConst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intvalue();
  inline void clear_has_intvalue();
  inline void set_has_floatvalue();
  inline void clear_has_floatvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 intvalue_;
  double floatvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static SchemeItemConst* default_instance_;
};
// -------------------------------------------------------------------

class DeviceObject : public ::google::protobuf::Message {
 public:
  DeviceObject();
  virtual ~DeviceObject();

  DeviceObject(const DeviceObject& from);

  inline DeviceObject& operator=(const DeviceObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceObject& default_instance();

  void Swap(DeviceObject* other);

  // implements Message ----------------------------------------------

  DeviceObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceObject& from);
  void MergeFrom(const DeviceObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proto.Uuid uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::Proto::Uuid& uuid() const;
  inline ::Proto::Uuid* mutable_uuid();
  inline ::Proto::Uuid* release_uuid();
  inline void set_allocated_uuid(::Proto::Uuid* uuid);

  // required .Proto.wstring strId = 2;
  inline bool has_strid() const;
  inline void clear_strid();
  static const int kStrIdFieldNumber = 2;
  inline const ::Proto::wstring& strid() const;
  inline ::Proto::wstring* mutable_strid();
  inline ::Proto::wstring* release_strid();
  inline void set_allocated_strid(::Proto::wstring* strid);

  // required .Proto.wstring caption = 3;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 3;
  inline const ::Proto::wstring& caption() const;
  inline ::Proto::wstring* mutable_caption();
  inline ::Proto::wstring* release_caption();
  inline void set_allocated_caption(::Proto::wstring* caption);

  // optional .Proto.wstring childRestriction = 4;
  inline bool has_childrestriction() const;
  inline void clear_childrestriction();
  static const int kChildRestrictionFieldNumber = 4;
  inline const ::Proto::wstring& childrestriction() const;
  inline ::Proto::wstring* mutable_childrestriction();
  inline ::Proto::wstring* release_childrestriction();
  inline void set_allocated_childrestriction(::Proto::wstring* childrestriction);

  // optional int32 place = 5 [default = 0];
  inline bool has_place() const;
  inline void clear_place();
  static const int kPlaceFieldNumber = 5;
  inline ::google::protobuf::int32 place() const;
  inline void set_place(::google::protobuf::int32 value);

  // optional string dynamic_properties_struct = 6;
  inline bool has_dynamic_properties_struct() const;
  inline void clear_dynamic_properties_struct();
  static const int kDynamicPropertiesStructFieldNumber = 6;
  inline const ::std::string& dynamic_properties_struct() const;
  inline void set_dynamic_properties_struct(const ::std::string& value);
  inline void set_dynamic_properties_struct(const char* value);
  inline void set_dynamic_properties_struct(const char* value, size_t size);
  inline ::std::string* mutable_dynamic_properties_struct();
  inline ::std::string* release_dynamic_properties_struct();
  inline void set_allocated_dynamic_properties_struct(::std::string* dynamic_properties_struct);

  // repeated .Proto.Property properties = 7;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 7;
  inline const ::Proto::Property& properties(int index) const;
  inline ::Proto::Property* mutable_properties(int index);
  inline ::Proto::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::Property >*
      mutable_properties();

  // optional bool preset = 32 [default = false];
  inline bool has_preset() const;
  inline void clear_preset();
  static const int kPresetFieldNumber = 32;
  inline bool preset() const;
  inline void set_preset(bool value);

  // optional bool presetRoot = 33 [default = false];
  inline bool has_presetroot() const;
  inline void clear_presetroot();
  static const int kPresetRootFieldNumber = 33;
  inline bool presetroot() const;
  inline void set_presetroot(bool value);

  // optional .Proto.wstring presetName = 34;
  inline bool has_presetname() const;
  inline void clear_presetname();
  static const int kPresetNameFieldNumber = 34;
  inline const ::Proto::wstring& presetname() const;
  inline ::Proto::wstring* mutable_presetname();
  inline ::Proto::wstring* release_presetname();
  inline void set_allocated_presetname(::Proto::wstring* presetname);

  // optional .Proto.DeviceRoot Root = 100;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 100;
  inline const ::Proto::DeviceRoot& root() const;
  inline ::Proto::DeviceRoot* mutable_root();
  inline ::Proto::DeviceRoot* release_root();
  inline void set_allocated_root(::Proto::DeviceRoot* root);

  // optional .Proto.DeviceSystem System = 101;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 101;
  inline const ::Proto::DeviceSystem& system() const;
  inline ::Proto::DeviceSystem* mutable_system();
  inline ::Proto::DeviceSystem* release_system();
  inline void set_allocated_system(::Proto::DeviceSystem* system);

  // optional .Proto.DeviceRack Rack = 102;
  inline bool has_rack() const;
  inline void clear_rack();
  static const int kRackFieldNumber = 102;
  inline const ::Proto::DeviceRack& rack() const;
  inline ::Proto::DeviceRack* mutable_rack();
  inline ::Proto::DeviceRack* release_rack();
  inline void set_allocated_rack(::Proto::DeviceRack* rack);

  // optional .Proto.DeviceChassis Chassis = 103;
  inline bool has_chassis() const;
  inline void clear_chassis();
  static const int kChassisFieldNumber = 103;
  inline const ::Proto::DeviceChassis& chassis() const;
  inline ::Proto::DeviceChassis* mutable_chassis();
  inline ::Proto::DeviceChassis* release_chassis();
  inline void set_allocated_chassis(::Proto::DeviceChassis* chassis);

  // optional .Proto.DeviceModule Module = 104;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 104;
  inline const ::Proto::DeviceModule& module() const;
  inline ::Proto::DeviceModule* mutable_module();
  inline ::Proto::DeviceModule* release_module();
  inline void set_allocated_module(::Proto::DeviceModule* module);

  // optional .Proto.DeviceController Controller = 105;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 105;
  inline const ::Proto::DeviceController& controller() const;
  inline ::Proto::DeviceController* mutable_controller();
  inline ::Proto::DeviceController* release_controller();
  inline void set_allocated_controller(::Proto::DeviceController* controller);

  // optional .Proto.DeviceSignal Signal = 106;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 106;
  inline const ::Proto::DeviceSignal& signal() const;
  inline ::Proto::DeviceSignal* mutable_signal();
  inline ::Proto::DeviceSignal* release_signal();
  inline void set_allocated_signal(::Proto::DeviceSignal* signal);

  // optional .Proto.Workstation Workstation = 107;
  inline bool has_workstation() const;
  inline void clear_workstation();
  static const int kWorkstationFieldNumber = 107;
  inline const ::Proto::Workstation& workstation() const;
  inline ::Proto::Workstation* mutable_workstation();
  inline ::Proto::Workstation* release_workstation();
  inline void set_allocated_workstation(::Proto::Workstation* workstation);

  // optional .Proto.Software Software = 108;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 108;
  inline const ::Proto::Software& software() const;
  inline ::Proto::Software* mutable_software();
  inline ::Proto::Software* release_software();
  inline void set_allocated_software(::Proto::Software* software);

  // @@protoc_insertion_point(class_scope:Proto.DeviceObject)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_strid();
  inline void clear_has_strid();
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_childrestriction();
  inline void clear_has_childrestriction();
  inline void set_has_place();
  inline void clear_has_place();
  inline void set_has_dynamic_properties_struct();
  inline void clear_has_dynamic_properties_struct();
  inline void set_has_preset();
  inline void clear_has_preset();
  inline void set_has_presetroot();
  inline void clear_has_presetroot();
  inline void set_has_presetname();
  inline void clear_has_presetname();
  inline void set_has_root();
  inline void clear_has_root();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_rack();
  inline void clear_has_rack();
  inline void set_has_chassis();
  inline void clear_has_chassis();
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_workstation();
  inline void clear_has_workstation();
  inline void set_has_software();
  inline void clear_has_software();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Proto::Uuid* uuid_;
  ::Proto::wstring* strid_;
  ::Proto::wstring* caption_;
  ::Proto::wstring* childrestriction_;
  ::std::string* dynamic_properties_struct_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Property > properties_;
  ::google::protobuf::int32 place_;
  bool preset_;
  bool presetroot_;
  ::Proto::wstring* presetname_;
  ::Proto::DeviceRoot* root_;
  ::Proto::DeviceSystem* system_;
  ::Proto::DeviceRack* rack_;
  ::Proto::DeviceChassis* chassis_;
  ::Proto::DeviceModule* module_;
  ::Proto::DeviceController* controller_;
  ::Proto::DeviceSignal* signal_;
  ::Proto::Workstation* workstation_;
  ::Proto::Software* software_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceObject* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRoot : public ::google::protobuf::Message {
 public:
  DeviceRoot();
  virtual ~DeviceRoot();

  DeviceRoot(const DeviceRoot& from);

  inline DeviceRoot& operator=(const DeviceRoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceRoot& default_instance();

  void Swap(DeviceRoot* other);

  // implements Message ----------------------------------------------

  DeviceRoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceRoot& from);
  void MergeFrom(const DeviceRoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceRoot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceRoot* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSystem : public ::google::protobuf::Message {
 public:
  DeviceSystem();
  virtual ~DeviceSystem();

  DeviceSystem(const DeviceSystem& from);

  inline DeviceSystem& operator=(const DeviceSystem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSystem& default_instance();

  void Swap(DeviceSystem* other);

  // implements Message ----------------------------------------------

  DeviceSystem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSystem& from);
  void MergeFrom(const DeviceSystem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceSystem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceSystem* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRack : public ::google::protobuf::Message {
 public:
  DeviceRack();
  virtual ~DeviceRack();

  DeviceRack(const DeviceRack& from);

  inline DeviceRack& operator=(const DeviceRack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceRack& default_instance();

  void Swap(DeviceRack* other);

  // implements Message ----------------------------------------------

  DeviceRack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceRack& from);
  void MergeFrom(const DeviceRack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceRack)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceRack* default_instance_;
};
// -------------------------------------------------------------------

class DeviceChassis : public ::google::protobuf::Message {
 public:
  DeviceChassis();
  virtual ~DeviceChassis();

  DeviceChassis(const DeviceChassis& from);

  inline DeviceChassis& operator=(const DeviceChassis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceChassis& default_instance();

  void Swap(DeviceChassis* other);

  // implements Message ----------------------------------------------

  DeviceChassis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceChassis& from);
  void MergeFrom(const DeviceChassis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DeviceChassis)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceChassis* default_instance_;
};
// -------------------------------------------------------------------

class DeviceModule : public ::google::protobuf::Message {
 public:
  DeviceModule();
  virtual ~DeviceModule();

  DeviceModule(const DeviceModule& from);

  inline DeviceModule& operator=(const DeviceModule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceModule& default_instance();

  void Swap(DeviceModule* other);

  // implements Message ----------------------------------------------

  DeviceModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceModule& from);
  void MergeFrom(const DeviceModule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 Channel = 2 [default = 0];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string SubsysID = 3 [default = ""];
  inline bool has_subsysid() const;
  inline void clear_subsysid();
  static const int kSubsysIDFieldNumber = 3;
  inline const ::std::string& subsysid() const;
  inline void set_subsysid(const ::std::string& value);
  inline void set_subsysid(const char* value);
  inline void set_subsysid(const char* value, size_t size);
  inline ::std::string* mutable_subsysid();
  inline ::std::string* release_subsysid();
  inline void set_allocated_subsysid(::std::string* subsysid);

  // optional string ConfType = 4 [default = ""];
  inline bool has_conftype() const;
  inline void clear_conftype();
  static const int kConfTypeFieldNumber = 4;
  inline const ::std::string& conftype() const;
  inline void set_conftype(const ::std::string& value);
  inline void set_conftype(const char* value);
  inline void set_conftype(const char* value, size_t size);
  inline ::std::string* mutable_conftype();
  inline ::std::string* release_conftype();
  inline void set_allocated_conftype(::std::string* conftype);

  // @@protoc_insertion_point(class_scope:Proto.DeviceModule)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_subsysid();
  inline void clear_has_subsysid();
  inline void set_has_conftype();
  inline void clear_has_conftype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 channel_;
  ::std::string* subsysid_;
  ::std::string* conftype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceModule* default_instance_;
};
// -------------------------------------------------------------------

class DeviceController : public ::google::protobuf::Message {
 public:
  DeviceController();
  virtual ~DeviceController();

  DeviceController(const DeviceController& from);

  inline DeviceController& operator=(const DeviceController& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceController& default_instance();

  void Swap(DeviceController* other);

  // implements Message ----------------------------------------------

  DeviceController* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceController& from);
  void MergeFrom(const DeviceController& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Proto.DeviceController)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceController* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSignal : public ::google::protobuf::Message {
 public:
  DeviceSignal();
  virtual ~DeviceSignal();

  DeviceSignal(const DeviceSignal& from);

  inline DeviceSignal& operator=(const DeviceSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSignal& default_instance();

  void Swap(DeviceSignal* other);

  // implements Message ----------------------------------------------

  DeviceSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSignal& from);
  void MergeFrom(const DeviceSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 obsoletetype = 1 [default = 0];
  inline bool has_obsoletetype() const;
  inline void clear_obsoletetype();
  static const int kObsoletetypeFieldNumber = 1;
  inline ::google::protobuf::int32 obsoletetype() const;
  inline void set_obsoletetype(::google::protobuf::int32 value);

  // optional int32 byteOrder = 2 [default = 0];
  inline bool has_byteorder() const;
  inline void clear_byteorder();
  static const int kByteOrderFieldNumber = 2;
  inline ::google::protobuf::int32 byteorder() const;
  inline void set_byteorder(::google::protobuf::int32 value);

  // optional int32 format = 3 [default = 0];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 3;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);

  // optional int32 size = 4 [default = 0];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int32 validityOffset = 5 [default = 0];
  inline bool has_validityoffset() const;
  inline void clear_validityoffset();
  static const int kValidityOffsetFieldNumber = 5;
  inline ::google::protobuf::int32 validityoffset() const;
  inline void set_validityoffset(::google::protobuf::int32 value);

  // optional int32 validityBit = 6 [default = 0];
  inline bool has_validitybit() const;
  inline void clear_validitybit();
  static const int kValidityBitFieldNumber = 6;
  inline ::google::protobuf::int32 validitybit() const;
  inline void set_validitybit(::google::protobuf::int32 value);

  // optional int32 valueOffset = 7 [default = 0];
  inline bool has_valueoffset() const;
  inline void clear_valueoffset();
  static const int kValueOffsetFieldNumber = 7;
  inline ::google::protobuf::int32 valueoffset() const;
  inline void set_valueoffset(::google::protobuf::int32 value);

  // optional int32 valueBit = 8 [default = 0];
  inline bool has_valuebit() const;
  inline void clear_valuebit();
  static const int kValueBitFieldNumber = 8;
  inline ::google::protobuf::int32 valuebit() const;
  inline void set_valuebit(::google::protobuf::int32 value);

  // optional int32 type = 9 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 function = 10 [default = 0];
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 10;
  inline ::google::protobuf::int32 function() const;
  inline void set_function(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DeviceSignal)
 private:
  inline void set_has_obsoletetype();
  inline void clear_has_obsoletetype();
  inline void set_has_byteorder();
  inline void clear_has_byteorder();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_validityoffset();
  inline void clear_has_validityoffset();
  inline void set_has_validitybit();
  inline void clear_has_validitybit();
  inline void set_has_valueoffset();
  inline void clear_has_valueoffset();
  inline void set_has_valuebit();
  inline void clear_has_valuebit();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_function();
  inline void clear_has_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 obsoletetype_;
  ::google::protobuf::int32 byteorder_;
  ::google::protobuf::int32 format_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 validityoffset_;
  ::google::protobuf::int32 validitybit_;
  ::google::protobuf::int32 valueoffset_;
  ::google::protobuf::int32 valuebit_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 function_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static DeviceSignal* default_instance_;
};
// -------------------------------------------------------------------

class Workstation : public ::google::protobuf::Message {
 public:
  Workstation();
  virtual ~Workstation();

  Workstation(const Workstation& from);

  inline Workstation& operator=(const Workstation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Workstation& default_instance();

  void Swap(Workstation* other);

  // implements Message ----------------------------------------------

  Workstation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Workstation& from);
  void MergeFrom(const Workstation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Workstation)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Workstation* default_instance_;
};
// -------------------------------------------------------------------

class Software : public ::google::protobuf::Message {
 public:
  Software();
  virtual ~Software();

  Software(const Software& from);

  inline Software& operator=(const Software& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Software& default_instance();

  void Swap(Software* other);

  // implements Message ----------------------------------------------

  Software* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Software& from);
  void MergeFrom(const Software& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Software)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Software* default_instance_;
};
// -------------------------------------------------------------------

class ModuleConfiguration : public ::google::protobuf::Message {
 public:
  ModuleConfiguration();
  virtual ~ModuleConfiguration();

  ModuleConfiguration(const ModuleConfiguration& from);

  inline ModuleConfiguration& operator=(const ModuleConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleConfiguration& default_instance();

  void Swap(ModuleConfiguration* other);

  // implements Message ----------------------------------------------

  ModuleConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleConfiguration& from);
  void MergeFrom(const ModuleConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string struct_description = 1;
  inline bool has_struct_description() const;
  inline void clear_struct_description();
  static const int kStructDescriptionFieldNumber = 1;
  inline const ::std::string& struct_description() const;
  inline void set_struct_description(const ::std::string& value);
  inline void set_struct_description(const char* value);
  inline void set_struct_description(const char* value, size_t size);
  inline ::std::string* mutable_struct_description();
  inline ::std::string* release_struct_description();
  inline void set_allocated_struct_description(::std::string* struct_description);

  // repeated .Proto.ModuleConfigurationValue values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::Proto::ModuleConfigurationValue& values(int index) const;
  inline ::Proto::ModuleConfigurationValue* mutable_values(int index);
  inline ::Proto::ModuleConfigurationValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >*
      mutable_values();

  // optional string name = 3 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Proto.ModuleConfiguration)
 private:
  inline void set_has_struct_description();
  inline void clear_has_struct_description();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* struct_description_;
  ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue > values_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static ModuleConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class ModuleConfigurationValue : public ::google::protobuf::Message {
 public:
  ModuleConfigurationValue();
  virtual ~ModuleConfigurationValue();

  ModuleConfigurationValue(const ModuleConfigurationValue& from);

  inline ModuleConfigurationValue& operator=(const ModuleConfigurationValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleConfigurationValue& default_instance();

  void Swap(ModuleConfigurationValue* other);

  // implements Message ----------------------------------------------

  ModuleConfigurationValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleConfigurationValue& from);
  void MergeFrom(const ModuleConfigurationValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Proto.ModuleConfigurationValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static ModuleConfigurationValue* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  void Swap(Property* other);

  // implements Message ----------------------------------------------

  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Proto.Property)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_serialization_2eproto();
  friend void protobuf_AssignDesc_serialization_2eproto();
  friend void protobuf_ShutdownFile_serialization_2eproto();

  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// ===================================================================


// ===================================================================

// Uuid

// required bytes uuid = 1;
inline bool Uuid::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uuid::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uuid::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uuid::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Uuid::uuid() const {
  return *uuid_;
}
inline void Uuid::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Uuid::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Uuid::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Uuid::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Uuid::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Uuid::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// qvariant

// required int32 type = 1;
inline bool qvariant::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void qvariant::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void qvariant::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void qvariant::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 qvariant::type() const {
  return type_;
}
inline void qvariant::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 intValue = 2 [default = 0];
inline bool qvariant::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qvariant::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void qvariant::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void qvariant::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 qvariant::intvalue() const {
  return intvalue_;
}
inline void qvariant::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional uint32 uintValue = 3 [default = 0];
inline bool qvariant::has_uintvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qvariant::set_has_uintvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void qvariant::clear_has_uintvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void qvariant::clear_uintvalue() {
  uintvalue_ = 0u;
  clear_has_uintvalue();
}
inline ::google::protobuf::uint32 qvariant::uintvalue() const {
  return uintvalue_;
}
inline void qvariant::set_uintvalue(::google::protobuf::uint32 value) {
  set_has_uintvalue();
  uintvalue_ = value;
}

// optional double doubleValue = 4 [default = 0];
inline bool qvariant::has_doublevalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qvariant::set_has_doublevalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void qvariant::clear_has_doublevalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void qvariant::clear_doublevalue() {
  doublevalue_ = 0;
  clear_has_doublevalue();
}
inline double qvariant::doublevalue() const {
  return doublevalue_;
}
inline void qvariant::set_doublevalue(double value) {
  set_has_doublevalue();
  doublevalue_ = value;
}

// optional bool boolValue = 5 [default = false];
inline bool qvariant::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void qvariant::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void qvariant::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void qvariant::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool qvariant::boolvalue() const {
  return boolvalue_;
}
inline void qvariant::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// -------------------------------------------------------------------

// wstring

// required bytes text = 1;
inline bool wstring::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wstring::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wstring::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wstring::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& wstring::text() const {
  return *text_;
}
inline void wstring::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void wstring::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void wstring::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* wstring::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* wstring::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void wstring::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FontParam

// required .Proto.wstring name = 1;
inline bool FontParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FontParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FontParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FontParam::clear_name() {
  if (name_ != NULL) name_->::Proto::wstring::Clear();
  clear_has_name();
}
inline const ::Proto::wstring& FontParam::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::Proto::wstring* FontParam::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::Proto::wstring;
  return name_;
}
inline ::Proto::wstring* FontParam::release_name() {
  clear_has_name();
  ::Proto::wstring* temp = name_;
  name_ = NULL;
  return temp;
}
inline void FontParam::set_allocated_name(::Proto::wstring* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// required double size = 2;
inline bool FontParam::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FontParam::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FontParam::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FontParam::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double FontParam::size() const {
  return size_;
}
inline void FontParam::set_size(double value) {
  set_has_size();
  size_ = value;
}

// required bool bold = 3;
inline bool FontParam::has_bold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FontParam::set_has_bold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FontParam::clear_has_bold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FontParam::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool FontParam::bold() const {
  return bold_;
}
inline void FontParam::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
}

// required bool italic = 4;
inline bool FontParam::has_italic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FontParam::set_has_italic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FontParam::clear_has_italic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FontParam::clear_italic() {
  italic_ = false;
  clear_has_italic();
}
inline bool FontParam::italic() const {
  return italic_;
}
inline void FontParam::set_italic(bool value) {
  set_has_italic();
  italic_ = value;
}

// -------------------------------------------------------------------

// SchemePoint

// required double x = 1;
inline bool SchemePoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemePoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemePoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemePoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SchemePoint::x() const {
  return x_;
}
inline void SchemePoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool SchemePoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemePoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemePoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemePoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SchemePoint::y() const {
  return y_;
}
inline void SchemePoint::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Envelope

// required uint32 classnamehash = 1;
inline bool Envelope::has_classnamehash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_classnamehash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_classnamehash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_classnamehash() {
  classnamehash_ = 0u;
  clear_has_classnamehash();
}
inline ::google::protobuf::uint32 Envelope::classnamehash() const {
  return classnamehash_;
}
inline void Envelope::set_classnamehash(::google::protobuf::uint32 value) {
  set_has_classnamehash();
  classnamehash_ = value;
}

// optional .Proto.SchemeItem schemeitem = 6;
inline bool Envelope::has_schemeitem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_schemeitem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_schemeitem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_schemeitem() {
  if (schemeitem_ != NULL) schemeitem_->::Proto::SchemeItem::Clear();
  clear_has_schemeitem();
}
inline const ::Proto::SchemeItem& Envelope::schemeitem() const {
  return schemeitem_ != NULL ? *schemeitem_ : *default_instance_->schemeitem_;
}
inline ::Proto::SchemeItem* Envelope::mutable_schemeitem() {
  set_has_schemeitem();
  if (schemeitem_ == NULL) schemeitem_ = new ::Proto::SchemeItem;
  return schemeitem_;
}
inline ::Proto::SchemeItem* Envelope::release_schemeitem() {
  clear_has_schemeitem();
  ::Proto::SchemeItem* temp = schemeitem_;
  schemeitem_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemeitem(::Proto::SchemeItem* schemeitem) {
  delete schemeitem_;
  schemeitem_ = schemeitem;
  if (schemeitem) {
    set_has_schemeitem();
  } else {
    clear_has_schemeitem();
  }
}

// optional .Proto.DeviceObject deviceobject = 7;
inline bool Envelope::has_deviceobject() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_deviceobject() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_deviceobject() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_deviceobject() {
  if (deviceobject_ != NULL) deviceobject_->::Proto::DeviceObject::Clear();
  clear_has_deviceobject();
}
inline const ::Proto::DeviceObject& Envelope::deviceobject() const {
  return deviceobject_ != NULL ? *deviceobject_ : *default_instance_->deviceobject_;
}
inline ::Proto::DeviceObject* Envelope::mutable_deviceobject() {
  set_has_deviceobject();
  if (deviceobject_ == NULL) deviceobject_ = new ::Proto::DeviceObject;
  return deviceobject_;
}
inline ::Proto::DeviceObject* Envelope::release_deviceobject() {
  clear_has_deviceobject();
  ::Proto::DeviceObject* temp = deviceobject_;
  deviceobject_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_deviceobject(::Proto::DeviceObject* deviceobject) {
  delete deviceobject_;
  deviceobject_ = deviceobject;
  if (deviceobject) {
    set_has_deviceobject();
  } else {
    clear_has_deviceobject();
  }
}

// optional .Proto.Scheme scheme = 100;
inline bool Envelope::has_scheme() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_scheme() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_scheme() {
  if (scheme_ != NULL) scheme_->::Proto::Scheme::Clear();
  clear_has_scheme();
}
inline const ::Proto::Scheme& Envelope::scheme() const {
  return scheme_ != NULL ? *scheme_ : *default_instance_->scheme_;
}
inline ::Proto::Scheme* Envelope::mutable_scheme() {
  set_has_scheme();
  if (scheme_ == NULL) scheme_ = new ::Proto::Scheme;
  return scheme_;
}
inline ::Proto::Scheme* Envelope::release_scheme() {
  clear_has_scheme();
  ::Proto::Scheme* temp = scheme_;
  scheme_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_scheme(::Proto::Scheme* scheme) {
  delete scheme_;
  scheme_ = scheme;
  if (scheme) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
}

// optional .Proto.SchemeLayer schemelayer = 101;
inline bool Envelope::has_schemelayer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Envelope::set_has_schemelayer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Envelope::clear_has_schemelayer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Envelope::clear_schemelayer() {
  if (schemelayer_ != NULL) schemelayer_->::Proto::SchemeLayer::Clear();
  clear_has_schemelayer();
}
inline const ::Proto::SchemeLayer& Envelope::schemelayer() const {
  return schemelayer_ != NULL ? *schemelayer_ : *default_instance_->schemelayer_;
}
inline ::Proto::SchemeLayer* Envelope::mutable_schemelayer() {
  set_has_schemelayer();
  if (schemelayer_ == NULL) schemelayer_ = new ::Proto::SchemeLayer;
  return schemelayer_;
}
inline ::Proto::SchemeLayer* Envelope::release_schemelayer() {
  clear_has_schemelayer();
  ::Proto::SchemeLayer* temp = schemelayer_;
  schemelayer_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_schemelayer(::Proto::SchemeLayer* schemelayer) {
  delete schemelayer_;
  schemelayer_ = schemelayer;
  if (schemelayer) {
    set_has_schemelayer();
  } else {
    clear_has_schemelayer();
  }
}

// optional .Proto.FblElement fblelement = 102;
inline bool Envelope::has_fblelement() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Envelope::set_has_fblelement() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Envelope::clear_has_fblelement() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Envelope::clear_fblelement() {
  if (fblelement_ != NULL) fblelement_->::Proto::FblElement::Clear();
  clear_has_fblelement();
}
inline const ::Proto::FblElement& Envelope::fblelement() const {
  return fblelement_ != NULL ? *fblelement_ : *default_instance_->fblelement_;
}
inline ::Proto::FblElement* Envelope::mutable_fblelement() {
  set_has_fblelement();
  if (fblelement_ == NULL) fblelement_ = new ::Proto::FblElement;
  return fblelement_;
}
inline ::Proto::FblElement* Envelope::release_fblelement() {
  clear_has_fblelement();
  ::Proto::FblElement* temp = fblelement_;
  fblelement_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_fblelement(::Proto::FblElement* fblelement) {
  delete fblelement_;
  fblelement_ = fblelement;
  if (fblelement) {
    set_has_fblelement();
  } else {
    clear_has_fblelement();
  }
}

// optional .Proto.Configuration configuration = 103;
inline bool Envelope::has_configuration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Envelope::set_has_configuration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Envelope::clear_has_configuration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Envelope::clear_configuration() {
  if (configuration_ != NULL) configuration_->::Proto::Configuration::Clear();
  clear_has_configuration();
}
inline const ::Proto::Configuration& Envelope::configuration() const {
  return configuration_ != NULL ? *configuration_ : *default_instance_->configuration_;
}
inline ::Proto::Configuration* Envelope::mutable_configuration() {
  set_has_configuration();
  if (configuration_ == NULL) configuration_ = new ::Proto::Configuration;
  return configuration_;
}
inline ::Proto::Configuration* Envelope::release_configuration() {
  clear_has_configuration();
  ::Proto::Configuration* temp = configuration_;
  configuration_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_configuration(::Proto::Configuration* configuration) {
  delete configuration_;
  configuration_ = configuration;
  if (configuration) {
    set_has_configuration();
  } else {
    clear_has_configuration();
  }
}

// -------------------------------------------------------------------

// Configuration

// required .Proto.Uuid uuid = 1;
inline bool Configuration::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Configuration::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Configuration::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Configuration::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring strID = 2;
inline bool Configuration::has_strid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_strid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_strid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& Configuration::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* Configuration::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* Configuration::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool Configuration::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& Configuration::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* Configuration::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* Configuration::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.wstring variables = 4;
inline bool Configuration::has_variables() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_variables() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_variables() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_variables() {
  if (variables_ != NULL) variables_->::Proto::wstring::Clear();
  clear_has_variables();
}
inline const ::Proto::wstring& Configuration::variables() const {
  return variables_ != NULL ? *variables_ : *default_instance_->variables_;
}
inline ::Proto::wstring* Configuration::mutable_variables() {
  set_has_variables();
  if (variables_ == NULL) variables_ = new ::Proto::wstring;
  return variables_;
}
inline ::Proto::wstring* Configuration::release_variables() {
  clear_has_variables();
  ::Proto::wstring* temp = variables_;
  variables_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_variables(::Proto::wstring* variables) {
  delete variables_;
  variables_ = variables;
  if (variables) {
    set_has_variables();
  } else {
    clear_has_variables();
  }
}

// required .Proto.wstring globals = 5;
inline bool Configuration::has_globals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_globals() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_globals() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_globals() {
  if (globals_ != NULL) globals_->::Proto::wstring::Clear();
  clear_has_globals();
}
inline const ::Proto::wstring& Configuration::globals() const {
  return globals_ != NULL ? *globals_ : *default_instance_->globals_;
}
inline ::Proto::wstring* Configuration::mutable_globals() {
  set_has_globals();
  if (globals_ == NULL) globals_ = new ::Proto::wstring;
  return globals_;
}
inline ::Proto::wstring* Configuration::release_globals() {
  clear_has_globals();
  ::Proto::wstring* temp = globals_;
  globals_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_globals(::Proto::wstring* globals) {
  delete globals_;
  globals_ = globals;
  if (globals) {
    set_has_globals();
  } else {
    clear_has_globals();
  }
}

// repeated .Proto.Uuid schemesIDs = 100;
inline int Configuration::schemesids_size() const {
  return schemesids_.size();
}
inline void Configuration::clear_schemesids() {
  schemesids_.Clear();
}
inline const ::Proto::Uuid& Configuration::schemesids(int index) const {
  return schemesids_.Get(index);
}
inline ::Proto::Uuid* Configuration::mutable_schemesids(int index) {
  return schemesids_.Mutable(index);
}
inline ::Proto::Uuid* Configuration::add_schemesids() {
  return schemesids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >&
Configuration::schemesids() const {
  return schemesids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Uuid >*
Configuration::mutable_schemesids() {
  return &schemesids_;
}

// repeated .Proto.Envelope schemes = 101;
inline int Configuration::schemes_size() const {
  return schemes_.size();
}
inline void Configuration::clear_schemes() {
  schemes_.Clear();
}
inline const ::Proto::Envelope& Configuration::schemes(int index) const {
  return schemes_.Get(index);
}
inline ::Proto::Envelope* Configuration::mutable_schemes(int index) {
  return schemes_.Mutable(index);
}
inline ::Proto::Envelope* Configuration::add_schemes() {
  return schemes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
Configuration::schemes() const {
  return schemes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
Configuration::mutable_schemes() {
  return &schemes_;
}

// -------------------------------------------------------------------

// AfbElementCollection

// repeated .Proto.AfbElementXml elements = 1;
inline int AfbElementCollection::elements_size() const {
  return elements_.size();
}
inline void AfbElementCollection::clear_elements() {
  elements_.Clear();
}
inline const ::Proto::AfbElementXml& AfbElementCollection::elements(int index) const {
  return elements_.Get(index);
}
inline ::Proto::AfbElementXml* AfbElementCollection::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::Proto::AfbElementXml* AfbElementCollection::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >&
AfbElementCollection::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::AfbElementXml >*
AfbElementCollection::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// AfbElementXml

// required bytes data = 1;
inline bool AfbElementXml::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfbElementXml::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AfbElementXml::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AfbElementXml::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AfbElementXml::data() const {
  return *data_;
}
inline void AfbElementXml::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AfbElementXml::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AfbElementXml::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AfbElementXml::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AfbElementXml::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AfbElementXml::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FblElement

// required .Proto.wstring strID = 2;
inline bool FblElement::has_strid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblElement::set_has_strid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblElement::clear_has_strid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblElement::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& FblElement::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* FblElement::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* FblElement::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool FblElement::has_caption() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblElement::set_has_caption() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblElement::clear_has_caption() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblElement::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& FblElement::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* FblElement::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* FblElement::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required uint32 opcode = 4;
inline bool FblElement::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblElement::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblElement::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblElement::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 FblElement::opcode() const {
  return opcode_;
}
inline void FblElement::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
}

// optional bool hasRam = 5 [default = false];
inline bool FblElement::has_hasram() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblElement::set_has_hasram() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblElement::clear_has_hasram() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblElement::clear_hasram() {
  hasram_ = false;
  clear_has_hasram();
}
inline bool FblElement::hasram() const {
  return hasram_;
}
inline void FblElement::set_hasram(bool value) {
  set_has_hasram();
  hasram_ = value;
}

// optional bool requiredStart = 6 [default = true];
inline bool FblElement::has_requiredstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblElement::set_has_requiredstart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblElement::clear_has_requiredstart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblElement::clear_requiredstart() {
  requiredstart_ = true;
  clear_has_requiredstart();
}
inline bool FblElement::requiredstart() const {
  return requiredstart_;
}
inline void FblElement::set_requiredstart(bool value) {
  set_has_requiredstart();
  requiredstart_ = value;
}

// repeated .Proto.FblElementSignal inputSignals = 11;
inline int FblElement::inputsignals_size() const {
  return inputsignals_.size();
}
inline void FblElement::clear_inputsignals() {
  inputsignals_.Clear();
}
inline const ::Proto::FblElementSignal& FblElement::inputsignals(int index) const {
  return inputsignals_.Get(index);
}
inline ::Proto::FblElementSignal* FblElement::mutable_inputsignals(int index) {
  return inputsignals_.Mutable(index);
}
inline ::Proto::FblElementSignal* FblElement::add_inputsignals() {
  return inputsignals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >&
FblElement::inputsignals() const {
  return inputsignals_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >*
FblElement::mutable_inputsignals() {
  return &inputsignals_;
}

// repeated .Proto.FblElementSignal outputSignals = 12;
inline int FblElement::outputsignals_size() const {
  return outputsignals_.size();
}
inline void FblElement::clear_outputsignals() {
  outputsignals_.Clear();
}
inline const ::Proto::FblElementSignal& FblElement::outputsignals(int index) const {
  return outputsignals_.Get(index);
}
inline ::Proto::FblElementSignal* FblElement::mutable_outputsignals(int index) {
  return outputsignals_.Mutable(index);
}
inline ::Proto::FblElementSignal* FblElement::add_outputsignals() {
  return outputsignals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >&
FblElement::outputsignals() const {
  return outputsignals_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementSignal >*
FblElement::mutable_outputsignals() {
  return &outputsignals_;
}

// repeated .Proto.FblElementParam params = 13;
inline int FblElement::params_size() const {
  return params_.size();
}
inline void FblElement::clear_params() {
  params_.Clear();
}
inline const ::Proto::FblElementParam& FblElement::params(int index) const {
  return params_.Get(index);
}
inline ::Proto::FblElementParam* FblElement::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Proto::FblElementParam* FblElement::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >&
FblElement::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >*
FblElement::mutable_params() {
  return &params_;
}

// optional .Proto.wstring description = 14;
inline bool FblElement::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FblElement::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FblElement::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FblElement::clear_description() {
  if (description_ != NULL) description_->::Proto::wstring::Clear();
  clear_has_description();
}
inline const ::Proto::wstring& FblElement::description() const {
  return description_ != NULL ? *description_ : *default_instance_->description_;
}
inline ::Proto::wstring* FblElement::mutable_description() {
  set_has_description();
  if (description_ == NULL) description_ = new ::Proto::wstring;
  return description_;
}
inline ::Proto::wstring* FblElement::release_description() {
  clear_has_description();
  ::Proto::wstring* temp = description_;
  description_ = NULL;
  return temp;
}
inline void FblElement::set_allocated_description(::Proto::wstring* description) {
  delete description_;
  description_ = description;
  if (description) {
    set_has_description();
  } else {
    clear_has_description();
  }
}

// -------------------------------------------------------------------

// FblElementSignal

// required .Proto.wstring caption = 1;
inline bool FblElementSignal::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblElementSignal::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblElementSignal::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblElementSignal::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& FblElementSignal::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* FblElementSignal::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* FblElementSignal::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void FblElementSignal::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.FblSignalType type = 2;
inline bool FblElementSignal::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblElementSignal::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblElementSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblElementSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto::FblSignalType FblElementSignal::type() const {
  return static_cast< ::Proto::FblSignalType >(type_);
}
inline void FblElementSignal::set_type(::Proto::FblSignalType value) {
  assert(::Proto::FblSignalType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 operandIndex = 3 [default = 0];
inline bool FblElementSignal::has_operandindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblElementSignal::set_has_operandindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblElementSignal::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblElementSignal::clear_operandindex() {
  operandindex_ = 0;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 FblElementSignal::operandindex() const {
  return operandindex_;
}
inline void FblElementSignal::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional int32 size = 4 [default = 0];
inline bool FblElementSignal::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblElementSignal::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblElementSignal::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblElementSignal::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 FblElementSignal::size() const {
  return size_;
}
inline void FblElementSignal::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional .Proto.wstring opName = 5;
inline bool FblElementSignal::has_opname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblElementSignal::set_has_opname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblElementSignal::clear_has_opname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblElementSignal::clear_opname() {
  if (opname_ != NULL) opname_->::Proto::wstring::Clear();
  clear_has_opname();
}
inline const ::Proto::wstring& FblElementSignal::opname() const {
  return opname_ != NULL ? *opname_ : *default_instance_->opname_;
}
inline ::Proto::wstring* FblElementSignal::mutable_opname() {
  set_has_opname();
  if (opname_ == NULL) opname_ = new ::Proto::wstring;
  return opname_;
}
inline ::Proto::wstring* FblElementSignal::release_opname() {
  clear_has_opname();
  ::Proto::wstring* temp = opname_;
  opname_ = NULL;
  return temp;
}
inline void FblElementSignal::set_allocated_opname(::Proto::wstring* opname) {
  delete opname_;
  opname_ = opname;
  if (opname) {
    set_has_opname();
  } else {
    clear_has_opname();
  }
}

// -------------------------------------------------------------------

// FblElementParam

// required .Proto.wstring caption = 1;
inline bool FblElementParam::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblElementParam::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblElementParam::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblElementParam::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& FblElementParam::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* FblElementParam::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* FblElementParam::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required .Proto.FblParamType type = 2;
inline bool FblElementParam::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblElementParam::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblElementParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblElementParam::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto::FblParamType FblElementParam::type() const {
  return static_cast< ::Proto::FblParamType >(type_);
}
inline void FblElementParam::set_type(::Proto::FblParamType value) {
  assert(::Proto::FblParamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bool visible = 7;
inline bool FblElementParam::has_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblElementParam::set_has_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblElementParam::clear_has_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblElementParam::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool FblElementParam::visible() const {
  return visible_;
}
inline void FblElementParam::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional int32 operandIndex = 8 [default = 0];
inline bool FblElementParam::has_operandindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblElementParam::set_has_operandindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblElementParam::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblElementParam::clear_operandindex() {
  operandindex_ = 0;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 FblElementParam::operandindex() const {
  return operandindex_;
}
inline void FblElementParam::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional int32 size = 9 [default = 0];
inline bool FblElementParam::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblElementParam::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblElementParam::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblElementParam::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 FblElementParam::size() const {
  return size_;
}
inline void FblElementParam::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional bool instantiator = 10 [default = false];
inline bool FblElementParam::has_instantiator() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FblElementParam::set_has_instantiator() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FblElementParam::clear_has_instantiator() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FblElementParam::clear_instantiator() {
  instantiator_ = false;
  clear_has_instantiator();
}
inline bool FblElementParam::instantiator() const {
  return instantiator_;
}
inline void FblElementParam::set_instantiator(bool value) {
  set_has_instantiator();
  instantiator_ = value;
}

// optional bool user = 11 [default = false];
inline bool FblElementParam::has_user() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FblElementParam::set_has_user() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FblElementParam::clear_has_user() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FblElementParam::clear_user() {
  user_ = false;
  clear_has_user();
}
inline bool FblElementParam::user() const {
  return user_;
}
inline void FblElementParam::set_user(bool value) {
  set_has_user();
  user_ = value;
}

// optional .Proto.wstring changedScript = 12;
inline bool FblElementParam::has_changedscript() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FblElementParam::set_has_changedscript() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FblElementParam::clear_has_changedscript() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FblElementParam::clear_changedscript() {
  if (changedscript_ != NULL) changedscript_->::Proto::wstring::Clear();
  clear_has_changedscript();
}
inline const ::Proto::wstring& FblElementParam::changedscript() const {
  return changedscript_ != NULL ? *changedscript_ : *default_instance_->changedscript_;
}
inline ::Proto::wstring* FblElementParam::mutable_changedscript() {
  set_has_changedscript();
  if (changedscript_ == NULL) changedscript_ = new ::Proto::wstring;
  return changedscript_;
}
inline ::Proto::wstring* FblElementParam::release_changedscript() {
  clear_has_changedscript();
  ::Proto::wstring* temp = changedscript_;
  changedscript_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_changedscript(::Proto::wstring* changedscript) {
  delete changedscript_;
  changedscript_ = changedscript;
  if (changedscript) {
    set_has_changedscript();
  } else {
    clear_has_changedscript();
  }
}

// optional .Proto.qvariant value = 13;
inline bool FblElementParam::has_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FblElementParam::set_has_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FblElementParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FblElementParam::clear_value() {
  if (value_ != NULL) value_->::Proto::qvariant::Clear();
  clear_has_value();
}
inline const ::Proto::qvariant& FblElementParam::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Proto::qvariant* FblElementParam::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Proto::qvariant;
  return value_;
}
inline ::Proto::qvariant* FblElementParam::release_value() {
  clear_has_value();
  ::Proto::qvariant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_value(::Proto::qvariant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional .Proto.qvariant defaultvalue = 14;
inline bool FblElementParam::has_defaultvalue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FblElementParam::set_has_defaultvalue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FblElementParam::clear_has_defaultvalue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FblElementParam::clear_defaultvalue() {
  if (defaultvalue_ != NULL) defaultvalue_->::Proto::qvariant::Clear();
  clear_has_defaultvalue();
}
inline const ::Proto::qvariant& FblElementParam::defaultvalue() const {
  return defaultvalue_ != NULL ? *defaultvalue_ : *default_instance_->defaultvalue_;
}
inline ::Proto::qvariant* FblElementParam::mutable_defaultvalue() {
  set_has_defaultvalue();
  if (defaultvalue_ == NULL) defaultvalue_ = new ::Proto::qvariant;
  return defaultvalue_;
}
inline ::Proto::qvariant* FblElementParam::release_defaultvalue() {
  clear_has_defaultvalue();
  ::Proto::qvariant* temp = defaultvalue_;
  defaultvalue_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_defaultvalue(::Proto::qvariant* defaultvalue) {
  delete defaultvalue_;
  defaultvalue_ = defaultvalue;
  if (defaultvalue) {
    set_has_defaultvalue();
  } else {
    clear_has_defaultvalue();
  }
}

// optional .Proto.qvariant lowlimit = 15;
inline bool FblElementParam::has_lowlimit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FblElementParam::set_has_lowlimit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FblElementParam::clear_has_lowlimit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FblElementParam::clear_lowlimit() {
  if (lowlimit_ != NULL) lowlimit_->::Proto::qvariant::Clear();
  clear_has_lowlimit();
}
inline const ::Proto::qvariant& FblElementParam::lowlimit() const {
  return lowlimit_ != NULL ? *lowlimit_ : *default_instance_->lowlimit_;
}
inline ::Proto::qvariant* FblElementParam::mutable_lowlimit() {
  set_has_lowlimit();
  if (lowlimit_ == NULL) lowlimit_ = new ::Proto::qvariant;
  return lowlimit_;
}
inline ::Proto::qvariant* FblElementParam::release_lowlimit() {
  clear_has_lowlimit();
  ::Proto::qvariant* temp = lowlimit_;
  lowlimit_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_lowlimit(::Proto::qvariant* lowlimit) {
  delete lowlimit_;
  lowlimit_ = lowlimit;
  if (lowlimit) {
    set_has_lowlimit();
  } else {
    clear_has_lowlimit();
  }
}

// optional .Proto.qvariant highlimit = 16;
inline bool FblElementParam::has_highlimit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FblElementParam::set_has_highlimit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FblElementParam::clear_has_highlimit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FblElementParam::clear_highlimit() {
  if (highlimit_ != NULL) highlimit_->::Proto::qvariant::Clear();
  clear_has_highlimit();
}
inline const ::Proto::qvariant& FblElementParam::highlimit() const {
  return highlimit_ != NULL ? *highlimit_ : *default_instance_->highlimit_;
}
inline ::Proto::qvariant* FblElementParam::mutable_highlimit() {
  set_has_highlimit();
  if (highlimit_ == NULL) highlimit_ = new ::Proto::qvariant;
  return highlimit_;
}
inline ::Proto::qvariant* FblElementParam::release_highlimit() {
  clear_has_highlimit();
  ::Proto::qvariant* temp = highlimit_;
  highlimit_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_highlimit(::Proto::qvariant* highlimit) {
  delete highlimit_;
  highlimit_ = highlimit;
  if (highlimit) {
    set_has_highlimit();
  } else {
    clear_has_highlimit();
  }
}

// optional .Proto.wstring opName = 17;
inline bool FblElementParam::has_opname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FblElementParam::set_has_opname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FblElementParam::clear_has_opname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FblElementParam::clear_opname() {
  if (opname_ != NULL) opname_->::Proto::wstring::Clear();
  clear_has_opname();
}
inline const ::Proto::wstring& FblElementParam::opname() const {
  return opname_ != NULL ? *opname_ : *default_instance_->opname_;
}
inline ::Proto::wstring* FblElementParam::mutable_opname() {
  set_has_opname();
  if (opname_ == NULL) opname_ = new ::Proto::wstring;
  return opname_;
}
inline ::Proto::wstring* FblElementParam::release_opname() {
  clear_has_opname();
  ::Proto::wstring* temp = opname_;
  opname_ = NULL;
  return temp;
}
inline void FblElementParam::set_allocated_opname(::Proto::wstring* opname) {
  delete opname_;
  opname_ = opname;
  if (opname) {
    set_has_opname();
  } else {
    clear_has_opname();
  }
}

// -------------------------------------------------------------------

// Scheme

// required .Proto.Uuid uuid = 1;
inline bool Scheme::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scheme::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scheme::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scheme::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& Scheme::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* Scheme::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* Scheme::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void Scheme::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring strID = 2;
inline bool Scheme::has_strid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scheme::set_has_strid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scheme::clear_has_strid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scheme::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& Scheme::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* Scheme::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* Scheme::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void Scheme::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool Scheme::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scheme::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scheme::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scheme::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& Scheme::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* Scheme::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* Scheme::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void Scheme::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// required double width = 4;
inline bool Scheme::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Scheme::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Scheme::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Scheme::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double Scheme::width() const {
  return width_;
}
inline void Scheme::set_width(double value) {
  set_has_width();
  width_ = value;
}

// required double height = 5;
inline bool Scheme::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Scheme::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Scheme::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Scheme::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double Scheme::height() const {
  return height_;
}
inline void Scheme::set_height(double value) {
  set_has_height();
  height_ = value;
}

// required .Proto.SchemeUnit unit = 6;
inline bool Scheme::has_unit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Scheme::set_has_unit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Scheme::clear_has_unit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Scheme::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::Proto::SchemeUnit Scheme::unit() const {
  return static_cast< ::Proto::SchemeUnit >(unit_);
}
inline void Scheme::set_unit(::Proto::SchemeUnit value) {
  assert(::Proto::SchemeUnit_IsValid(value));
  set_has_unit();
  unit_ = value;
}

// optional bool excludeFromBuild = 7 [default = false];
inline bool Scheme::has_excludefrombuild() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Scheme::set_has_excludefrombuild() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Scheme::clear_has_excludefrombuild() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Scheme::clear_excludefrombuild() {
  excludefrombuild_ = false;
  clear_has_excludefrombuild();
}
inline bool Scheme::excludefrombuild() const {
  return excludefrombuild_;
}
inline void Scheme::set_excludefrombuild(bool value) {
  set_has_excludefrombuild();
  excludefrombuild_ = value;
}

// repeated .Proto.Envelope layers = 100;
inline int Scheme::layers_size() const {
  return layers_.size();
}
inline void Scheme::clear_layers() {
  layers_.Clear();
}
inline const ::Proto::Envelope& Scheme::layers(int index) const {
  return layers_.Get(index);
}
inline ::Proto::Envelope* Scheme::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::Proto::Envelope* Scheme::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
Scheme::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
Scheme::mutable_layers() {
  return &layers_;
}

// required .Proto.AfbElementCollection afbs = 101;
inline bool Scheme::has_afbs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Scheme::set_has_afbs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Scheme::clear_has_afbs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Scheme::clear_afbs() {
  if (afbs_ != NULL) afbs_->::Proto::AfbElementCollection::Clear();
  clear_has_afbs();
}
inline const ::Proto::AfbElementCollection& Scheme::afbs() const {
  return afbs_ != NULL ? *afbs_ : *default_instance_->afbs_;
}
inline ::Proto::AfbElementCollection* Scheme::mutable_afbs() {
  set_has_afbs();
  if (afbs_ == NULL) afbs_ = new ::Proto::AfbElementCollection;
  return afbs_;
}
inline ::Proto::AfbElementCollection* Scheme::release_afbs() {
  clear_has_afbs();
  ::Proto::AfbElementCollection* temp = afbs_;
  afbs_ = NULL;
  return temp;
}
inline void Scheme::set_allocated_afbs(::Proto::AfbElementCollection* afbs) {
  delete afbs_;
  afbs_ = afbs;
  if (afbs) {
    set_has_afbs();
  } else {
    clear_has_afbs();
  }
}

// optional .Proto.LogicScheme logics_scheme = 200;
inline bool Scheme::has_logics_scheme() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Scheme::set_has_logics_scheme() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Scheme::clear_has_logics_scheme() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Scheme::clear_logics_scheme() {
  if (logics_scheme_ != NULL) logics_scheme_->::Proto::LogicScheme::Clear();
  clear_has_logics_scheme();
}
inline const ::Proto::LogicScheme& Scheme::logics_scheme() const {
  return logics_scheme_ != NULL ? *logics_scheme_ : *default_instance_->logics_scheme_;
}
inline ::Proto::LogicScheme* Scheme::mutable_logics_scheme() {
  set_has_logics_scheme();
  if (logics_scheme_ == NULL) logics_scheme_ = new ::Proto::LogicScheme;
  return logics_scheme_;
}
inline ::Proto::LogicScheme* Scheme::release_logics_scheme() {
  clear_has_logics_scheme();
  ::Proto::LogicScheme* temp = logics_scheme_;
  logics_scheme_ = NULL;
  return temp;
}
inline void Scheme::set_allocated_logics_scheme(::Proto::LogicScheme* logics_scheme) {
  delete logics_scheme_;
  logics_scheme_ = logics_scheme;
  if (logics_scheme) {
    set_has_logics_scheme();
  } else {
    clear_has_logics_scheme();
  }
}

// -------------------------------------------------------------------

// LogicScheme

// repeated .Proto.wstring hardware_strids = 1;
inline int LogicScheme::hardware_strids_size() const {
  return hardware_strids_.size();
}
inline void LogicScheme::clear_hardware_strids() {
  hardware_strids_.Clear();
}
inline const ::Proto::wstring& LogicScheme::hardware_strids(int index) const {
  return hardware_strids_.Get(index);
}
inline ::Proto::wstring* LogicScheme::mutable_hardware_strids(int index) {
  return hardware_strids_.Mutable(index);
}
inline ::Proto::wstring* LogicScheme::add_hardware_strids() {
  return hardware_strids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
LogicScheme::hardware_strids() const {
  return hardware_strids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
LogicScheme::mutable_hardware_strids() {
  return &hardware_strids_;
}

// -------------------------------------------------------------------

// SchemeLayer

// required .Proto.Uuid uuid = 1;
inline bool SchemeLayer::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemeLayer::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemeLayer::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemeLayer::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& SchemeLayer::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* SchemeLayer::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* SchemeLayer::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void SchemeLayer::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring name = 2;
inline bool SchemeLayer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeLayer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeLayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeLayer::clear_name() {
  if (name_ != NULL) name_->::Proto::wstring::Clear();
  clear_has_name();
}
inline const ::Proto::wstring& SchemeLayer::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::Proto::wstring* SchemeLayer::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::Proto::wstring;
  return name_;
}
inline ::Proto::wstring* SchemeLayer::release_name() {
  clear_has_name();
  ::Proto::wstring* temp = name_;
  name_ = NULL;
  return temp;
}
inline void SchemeLayer::set_allocated_name(::Proto::wstring* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// required bool compile = 3;
inline bool SchemeLayer::has_compile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemeLayer::set_has_compile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemeLayer::clear_has_compile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemeLayer::clear_compile() {
  compile_ = false;
  clear_has_compile();
}
inline bool SchemeLayer::compile() const {
  return compile_;
}
inline void SchemeLayer::set_compile(bool value) {
  set_has_compile();
  compile_ = value;
}

// required bool show = 4;
inline bool SchemeLayer::has_show() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemeLayer::set_has_show() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemeLayer::clear_has_show() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemeLayer::clear_show() {
  show_ = false;
  clear_has_show();
}
inline bool SchemeLayer::show() const {
  return show_;
}
inline void SchemeLayer::set_show(bool value) {
  set_has_show();
  show_ = value;
}

// required bool print = 5;
inline bool SchemeLayer::has_print() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemeLayer::set_has_print() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemeLayer::clear_has_print() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemeLayer::clear_print() {
  print_ = false;
  clear_has_print();
}
inline bool SchemeLayer::print() const {
  return print_;
}
inline void SchemeLayer::set_print(bool value) {
  set_has_print();
  print_ = value;
}

// repeated .Proto.Envelope items = 15;
inline int SchemeLayer::items_size() const {
  return items_.size();
}
inline void SchemeLayer::clear_items() {
  items_.Clear();
}
inline const ::Proto::Envelope& SchemeLayer::items(int index) const {
  return items_.Get(index);
}
inline ::Proto::Envelope* SchemeLayer::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Proto::Envelope* SchemeLayer::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >&
SchemeLayer::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Envelope >*
SchemeLayer::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// SchemeItem

// required .Proto.Uuid uuid = 1;
inline bool SchemeItem::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemeItem::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemeItem::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemeItem::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& SchemeItem::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* SchemeItem::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* SchemeItem::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required bool isStatic = 2;
inline bool SchemeItem::has_isstatic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeItem::set_has_isstatic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeItem::clear_has_isstatic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeItem::clear_isstatic() {
  isstatic_ = false;
  clear_has_isstatic();
}
inline bool SchemeItem::isstatic() const {
  return isstatic_;
}
inline void SchemeItem::set_isstatic(bool value) {
  set_has_isstatic();
  isstatic_ = value;
}

// required bool isLocked = 3;
inline bool SchemeItem::has_islocked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemeItem::set_has_islocked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemeItem::clear_has_islocked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemeItem::clear_islocked() {
  islocked_ = false;
  clear_has_islocked();
}
inline bool SchemeItem::islocked() const {
  return islocked_;
}
inline void SchemeItem::set_islocked(bool value) {
  set_has_islocked();
  islocked_ = value;
}

// required .Proto.SchemeUnit itemUnit = 4;
inline bool SchemeItem::has_itemunit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemeItem::set_has_itemunit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemeItem::clear_has_itemunit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemeItem::clear_itemunit() {
  itemunit_ = 0;
  clear_has_itemunit();
}
inline ::Proto::SchemeUnit SchemeItem::itemunit() const {
  return static_cast< ::Proto::SchemeUnit >(itemunit_);
}
inline void SchemeItem::set_itemunit(::Proto::SchemeUnit value) {
  assert(::Proto::SchemeUnit_IsValid(value));
  set_has_itemunit();
  itemunit_ = value;
}

// optional bool acceptClick = 5 [default = false];
inline bool SchemeItem::has_acceptclick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemeItem::set_has_acceptclick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemeItem::clear_has_acceptclick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemeItem::clear_acceptclick() {
  acceptclick_ = false;
  clear_has_acceptclick();
}
inline bool SchemeItem::acceptclick() const {
  return acceptclick_;
}
inline void SchemeItem::set_acceptclick(bool value) {
  set_has_acceptclick();
  acceptclick_ = value;
}

// optional .Proto.wstring clickScript = 6;
inline bool SchemeItem::has_clickscript() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemeItem::set_has_clickscript() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemeItem::clear_has_clickscript() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemeItem::clear_clickscript() {
  if (clickscript_ != NULL) clickscript_->::Proto::wstring::Clear();
  clear_has_clickscript();
}
inline const ::Proto::wstring& SchemeItem::clickscript() const {
  return clickscript_ != NULL ? *clickscript_ : *default_instance_->clickscript_;
}
inline ::Proto::wstring* SchemeItem::mutable_clickscript() {
  set_has_clickscript();
  if (clickscript_ == NULL) clickscript_ = new ::Proto::wstring;
  return clickscript_;
}
inline ::Proto::wstring* SchemeItem::release_clickscript() {
  clear_has_clickscript();
  ::Proto::wstring* temp = clickscript_;
  clickscript_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_clickscript(::Proto::wstring* clickscript) {
  delete clickscript_;
  clickscript_ = clickscript;
  if (clickscript) {
    set_has_clickscript();
  } else {
    clear_has_clickscript();
  }
}

// optional .Proto.PosRectImpl PosRectImpl = 10;
inline bool SchemeItem::has_posrectimpl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemeItem::set_has_posrectimpl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemeItem::clear_has_posrectimpl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemeItem::clear_posrectimpl() {
  if (posrectimpl_ != NULL) posrectimpl_->::Proto::PosRectImpl::Clear();
  clear_has_posrectimpl();
}
inline const ::Proto::PosRectImpl& SchemeItem::posrectimpl() const {
  return posrectimpl_ != NULL ? *posrectimpl_ : *default_instance_->posrectimpl_;
}
inline ::Proto::PosRectImpl* SchemeItem::mutable_posrectimpl() {
  set_has_posrectimpl();
  if (posrectimpl_ == NULL) posrectimpl_ = new ::Proto::PosRectImpl;
  return posrectimpl_;
}
inline ::Proto::PosRectImpl* SchemeItem::release_posrectimpl() {
  clear_has_posrectimpl();
  ::Proto::PosRectImpl* temp = posrectimpl_;
  posrectimpl_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_posrectimpl(::Proto::PosRectImpl* posrectimpl) {
  delete posrectimpl_;
  posrectimpl_ = posrectimpl;
  if (posrectimpl) {
    set_has_posrectimpl();
  } else {
    clear_has_posrectimpl();
  }
}

// optional .Proto.PosLineImpl PosLineImpl = 11;
inline bool SchemeItem::has_poslineimpl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemeItem::set_has_poslineimpl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemeItem::clear_has_poslineimpl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemeItem::clear_poslineimpl() {
  if (poslineimpl_ != NULL) poslineimpl_->::Proto::PosLineImpl::Clear();
  clear_has_poslineimpl();
}
inline const ::Proto::PosLineImpl& SchemeItem::poslineimpl() const {
  return poslineimpl_ != NULL ? *poslineimpl_ : *default_instance_->poslineimpl_;
}
inline ::Proto::PosLineImpl* SchemeItem::mutable_poslineimpl() {
  set_has_poslineimpl();
  if (poslineimpl_ == NULL) poslineimpl_ = new ::Proto::PosLineImpl;
  return poslineimpl_;
}
inline ::Proto::PosLineImpl* SchemeItem::release_poslineimpl() {
  clear_has_poslineimpl();
  ::Proto::PosLineImpl* temp = poslineimpl_;
  poslineimpl_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_poslineimpl(::Proto::PosLineImpl* poslineimpl) {
  delete poslineimpl_;
  poslineimpl_ = poslineimpl;
  if (poslineimpl) {
    set_has_poslineimpl();
  } else {
    clear_has_poslineimpl();
  }
}

// optional .Proto.PosConnectionImpl PosConnectionImpl = 12;
inline bool SchemeItem::has_posconnectionimpl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SchemeItem::set_has_posconnectionimpl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SchemeItem::clear_has_posconnectionimpl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SchemeItem::clear_posconnectionimpl() {
  if (posconnectionimpl_ != NULL) posconnectionimpl_->::Proto::PosConnectionImpl::Clear();
  clear_has_posconnectionimpl();
}
inline const ::Proto::PosConnectionImpl& SchemeItem::posconnectionimpl() const {
  return posconnectionimpl_ != NULL ? *posconnectionimpl_ : *default_instance_->posconnectionimpl_;
}
inline ::Proto::PosConnectionImpl* SchemeItem::mutable_posconnectionimpl() {
  set_has_posconnectionimpl();
  if (posconnectionimpl_ == NULL) posconnectionimpl_ = new ::Proto::PosConnectionImpl;
  return posconnectionimpl_;
}
inline ::Proto::PosConnectionImpl* SchemeItem::release_posconnectionimpl() {
  clear_has_posconnectionimpl();
  ::Proto::PosConnectionImpl* temp = posconnectionimpl_;
  posconnectionimpl_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_posconnectionimpl(::Proto::PosConnectionImpl* posconnectionimpl) {
  delete posconnectionimpl_;
  posconnectionimpl_ = posconnectionimpl;
  if (posconnectionimpl) {
    set_has_posconnectionimpl();
  } else {
    clear_has_posconnectionimpl();
  }
}

// optional .Proto.FblItem FblItem = 106;
inline bool SchemeItem::has_fblitem() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SchemeItem::set_has_fblitem() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SchemeItem::clear_has_fblitem() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SchemeItem::clear_fblitem() {
  if (fblitem_ != NULL) fblitem_->::Proto::FblItem::Clear();
  clear_has_fblitem();
}
inline const ::Proto::FblItem& SchemeItem::fblitem() const {
  return fblitem_ != NULL ? *fblitem_ : *default_instance_->fblitem_;
}
inline ::Proto::FblItem* SchemeItem::mutable_fblitem() {
  set_has_fblitem();
  if (fblitem_ == NULL) fblitem_ = new ::Proto::FblItem;
  return fblitem_;
}
inline ::Proto::FblItem* SchemeItem::release_fblitem() {
  clear_has_fblitem();
  ::Proto::FblItem* temp = fblitem_;
  fblitem_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_fblitem(::Proto::FblItem* fblitem) {
  delete fblitem_;
  fblitem_ = fblitem;
  if (fblitem) {
    set_has_fblitem();
  } else {
    clear_has_fblitem();
  }
}

// optional .Proto.FblItemRect FblItemRect = 107;
inline bool SchemeItem::has_fblitemrect() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SchemeItem::set_has_fblitemrect() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SchemeItem::clear_has_fblitemrect() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SchemeItem::clear_fblitemrect() {
  if (fblitemrect_ != NULL) fblitemrect_->::Proto::FblItemRect::Clear();
  clear_has_fblitemrect();
}
inline const ::Proto::FblItemRect& SchemeItem::fblitemrect() const {
  return fblitemrect_ != NULL ? *fblitemrect_ : *default_instance_->fblitemrect_;
}
inline ::Proto::FblItemRect* SchemeItem::mutable_fblitemrect() {
  set_has_fblitemrect();
  if (fblitemrect_ == NULL) fblitemrect_ = new ::Proto::FblItemRect;
  return fblitemrect_;
}
inline ::Proto::FblItemRect* SchemeItem::release_fblitemrect() {
  clear_has_fblitemrect();
  ::Proto::FblItemRect* temp = fblitemrect_;
  fblitemrect_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_fblitemrect(::Proto::FblItemRect* fblitemrect) {
  delete fblitemrect_;
  fblitemrect_ = fblitemrect;
  if (fblitemrect) {
    set_has_fblitemrect();
  } else {
    clear_has_fblitemrect();
  }
}

// optional .Proto.FblItemLine FblItemLine = 108;
inline bool SchemeItem::has_fblitemline() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SchemeItem::set_has_fblitemline() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SchemeItem::clear_has_fblitemline() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SchemeItem::clear_fblitemline() {
  if (fblitemline_ != NULL) fblitemline_->::Proto::FblItemLine::Clear();
  clear_has_fblitemline();
}
inline const ::Proto::FblItemLine& SchemeItem::fblitemline() const {
  return fblitemline_ != NULL ? *fblitemline_ : *default_instance_->fblitemline_;
}
inline ::Proto::FblItemLine* SchemeItem::mutable_fblitemline() {
  set_has_fblitemline();
  if (fblitemline_ == NULL) fblitemline_ = new ::Proto::FblItemLine;
  return fblitemline_;
}
inline ::Proto::FblItemLine* SchemeItem::release_fblitemline() {
  clear_has_fblitemline();
  ::Proto::FblItemLine* temp = fblitemline_;
  fblitemline_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_fblitemline(::Proto::FblItemLine* fblitemline) {
  delete fblitemline_;
  fblitemline_ = fblitemline;
  if (fblitemline) {
    set_has_fblitemline();
  } else {
    clear_has_fblitemline();
  }
}

// optional .Proto.SchemeItemRect Rect = 116;
inline bool SchemeItem::has_rect() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SchemeItem::set_has_rect() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SchemeItem::clear_has_rect() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SchemeItem::clear_rect() {
  if (rect_ != NULL) rect_->::Proto::SchemeItemRect::Clear();
  clear_has_rect();
}
inline const ::Proto::SchemeItemRect& SchemeItem::rect() const {
  return rect_ != NULL ? *rect_ : *default_instance_->rect_;
}
inline ::Proto::SchemeItemRect* SchemeItem::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) rect_ = new ::Proto::SchemeItemRect;
  return rect_;
}
inline ::Proto::SchemeItemRect* SchemeItem::release_rect() {
  clear_has_rect();
  ::Proto::SchemeItemRect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_rect(::Proto::SchemeItemRect* rect) {
  delete rect_;
  rect_ = rect;
  if (rect) {
    set_has_rect();
  } else {
    clear_has_rect();
  }
}

// optional .Proto.SchemeItemLine Line = 117;
inline bool SchemeItem::has_line() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SchemeItem::set_has_line() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SchemeItem::clear_has_line() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SchemeItem::clear_line() {
  if (line_ != NULL) line_->::Proto::SchemeItemLine::Clear();
  clear_has_line();
}
inline const ::Proto::SchemeItemLine& SchemeItem::line() const {
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::Proto::SchemeItemLine* SchemeItem::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::Proto::SchemeItemLine;
  return line_;
}
inline ::Proto::SchemeItemLine* SchemeItem::release_line() {
  clear_has_line();
  ::Proto::SchemeItemLine* temp = line_;
  line_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_line(::Proto::SchemeItemLine* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
}

// optional .Proto.SchemeItemPath Path = 118;
inline bool SchemeItem::has_path() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SchemeItem::set_has_path() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SchemeItem::clear_has_path() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SchemeItem::clear_path() {
  if (path_ != NULL) path_->::Proto::SchemeItemPath::Clear();
  clear_has_path();
}
inline const ::Proto::SchemeItemPath& SchemeItem::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::Proto::SchemeItemPath* SchemeItem::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::Proto::SchemeItemPath;
  return path_;
}
inline ::Proto::SchemeItemPath* SchemeItem::release_path() {
  clear_has_path();
  ::Proto::SchemeItemPath* temp = path_;
  path_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_path(::Proto::SchemeItemPath* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
}

// optional .Proto.SchemeItemSignal Signal = 124;
inline bool SchemeItem::has_signal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SchemeItem::set_has_signal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SchemeItem::clear_has_signal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SchemeItem::clear_signal() {
  if (signal_ != NULL) signal_->::Proto::SchemeItemSignal::Clear();
  clear_has_signal();
}
inline const ::Proto::SchemeItemSignal& SchemeItem::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Proto::SchemeItemSignal* SchemeItem::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Proto::SchemeItemSignal;
  return signal_;
}
inline ::Proto::SchemeItemSignal* SchemeItem::release_signal() {
  clear_has_signal();
  ::Proto::SchemeItemSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_signal(::Proto::SchemeItemSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Proto.SchemeItemInput InputSignal = 125;
inline bool SchemeItem::has_inputsignal() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SchemeItem::set_has_inputsignal() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SchemeItem::clear_has_inputsignal() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SchemeItem::clear_inputsignal() {
  if (inputsignal_ != NULL) inputsignal_->::Proto::SchemeItemInput::Clear();
  clear_has_inputsignal();
}
inline const ::Proto::SchemeItemInput& SchemeItem::inputsignal() const {
  return inputsignal_ != NULL ? *inputsignal_ : *default_instance_->inputsignal_;
}
inline ::Proto::SchemeItemInput* SchemeItem::mutable_inputsignal() {
  set_has_inputsignal();
  if (inputsignal_ == NULL) inputsignal_ = new ::Proto::SchemeItemInput;
  return inputsignal_;
}
inline ::Proto::SchemeItemInput* SchemeItem::release_inputsignal() {
  clear_has_inputsignal();
  ::Proto::SchemeItemInput* temp = inputsignal_;
  inputsignal_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_inputsignal(::Proto::SchemeItemInput* inputsignal) {
  delete inputsignal_;
  inputsignal_ = inputsignal;
  if (inputsignal) {
    set_has_inputsignal();
  } else {
    clear_has_inputsignal();
  }
}

// optional .Proto.SchemeItemOutput OutputSignal = 126;
inline bool SchemeItem::has_outputsignal() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SchemeItem::set_has_outputsignal() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SchemeItem::clear_has_outputsignal() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SchemeItem::clear_outputsignal() {
  if (outputsignal_ != NULL) outputsignal_->::Proto::SchemeItemOutput::Clear();
  clear_has_outputsignal();
}
inline const ::Proto::SchemeItemOutput& SchemeItem::outputsignal() const {
  return outputsignal_ != NULL ? *outputsignal_ : *default_instance_->outputsignal_;
}
inline ::Proto::SchemeItemOutput* SchemeItem::mutable_outputsignal() {
  set_has_outputsignal();
  if (outputsignal_ == NULL) outputsignal_ = new ::Proto::SchemeItemOutput;
  return outputsignal_;
}
inline ::Proto::SchemeItemOutput* SchemeItem::release_outputsignal() {
  clear_has_outputsignal();
  ::Proto::SchemeItemOutput* temp = outputsignal_;
  outputsignal_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_outputsignal(::Proto::SchemeItemOutput* outputsignal) {
  delete outputsignal_;
  outputsignal_ = outputsignal;
  if (outputsignal) {
    set_has_outputsignal();
  } else {
    clear_has_outputsignal();
  }
}

// optional .Proto.SchemeItemLink Link = 127;
inline bool SchemeItem::has_link() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SchemeItem::set_has_link() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SchemeItem::clear_has_link() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SchemeItem::clear_link() {
  if (link_ != NULL) link_->::Proto::SchemeItemLink::Clear();
  clear_has_link();
}
inline const ::Proto::SchemeItemLink& SchemeItem::link() const {
  return link_ != NULL ? *link_ : *default_instance_->link_;
}
inline ::Proto::SchemeItemLink* SchemeItem::mutable_link() {
  set_has_link();
  if (link_ == NULL) link_ = new ::Proto::SchemeItemLink;
  return link_;
}
inline ::Proto::SchemeItemLink* SchemeItem::release_link() {
  clear_has_link();
  ::Proto::SchemeItemLink* temp = link_;
  link_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_link(::Proto::SchemeItemLink* link) {
  delete link_;
  link_ = link;
  if (link) {
    set_has_link();
  } else {
    clear_has_link();
  }
}

// optional .Proto.SchemeItemAfb Afb = 128;
inline bool SchemeItem::has_afb() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SchemeItem::set_has_afb() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SchemeItem::clear_has_afb() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SchemeItem::clear_afb() {
  if (afb_ != NULL) afb_->::Proto::SchemeItemAfb::Clear();
  clear_has_afb();
}
inline const ::Proto::SchemeItemAfb& SchemeItem::afb() const {
  return afb_ != NULL ? *afb_ : *default_instance_->afb_;
}
inline ::Proto::SchemeItemAfb* SchemeItem::mutable_afb() {
  set_has_afb();
  if (afb_ == NULL) afb_ = new ::Proto::SchemeItemAfb;
  return afb_;
}
inline ::Proto::SchemeItemAfb* SchemeItem::release_afb() {
  clear_has_afb();
  ::Proto::SchemeItemAfb* temp = afb_;
  afb_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_afb(::Proto::SchemeItemAfb* afb) {
  delete afb_;
  afb_ = afb;
  if (afb) {
    set_has_afb();
  } else {
    clear_has_afb();
  }
}

// optional .Proto.SchemeItemConst ConstItem = 129;
inline bool SchemeItem::has_constitem() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SchemeItem::set_has_constitem() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SchemeItem::clear_has_constitem() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SchemeItem::clear_constitem() {
  if (constitem_ != NULL) constitem_->::Proto::SchemeItemConst::Clear();
  clear_has_constitem();
}
inline const ::Proto::SchemeItemConst& SchemeItem::constitem() const {
  return constitem_ != NULL ? *constitem_ : *default_instance_->constitem_;
}
inline ::Proto::SchemeItemConst* SchemeItem::mutable_constitem() {
  set_has_constitem();
  if (constitem_ == NULL) constitem_ = new ::Proto::SchemeItemConst;
  return constitem_;
}
inline ::Proto::SchemeItemConst* SchemeItem::release_constitem() {
  clear_has_constitem();
  ::Proto::SchemeItemConst* temp = constitem_;
  constitem_ = NULL;
  return temp;
}
inline void SchemeItem::set_allocated_constitem(::Proto::SchemeItemConst* constitem) {
  delete constitem_;
  constitem_ = constitem;
  if (constitem) {
    set_has_constitem();
  } else {
    clear_has_constitem();
  }
}

// -------------------------------------------------------------------

// PosRectImpl

// required double leftDocPt = 1;
inline bool PosRectImpl::has_leftdocpt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosRectImpl::set_has_leftdocpt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosRectImpl::clear_has_leftdocpt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosRectImpl::clear_leftdocpt() {
  leftdocpt_ = 0;
  clear_has_leftdocpt();
}
inline double PosRectImpl::leftdocpt() const {
  return leftdocpt_;
}
inline void PosRectImpl::set_leftdocpt(double value) {
  set_has_leftdocpt();
  leftdocpt_ = value;
}

// required double topDocPt = 2;
inline bool PosRectImpl::has_topdocpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosRectImpl::set_has_topdocpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosRectImpl::clear_has_topdocpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosRectImpl::clear_topdocpt() {
  topdocpt_ = 0;
  clear_has_topdocpt();
}
inline double PosRectImpl::topdocpt() const {
  return topdocpt_;
}
inline void PosRectImpl::set_topdocpt(double value) {
  set_has_topdocpt();
  topdocpt_ = value;
}

// required double widthDocPt = 3;
inline bool PosRectImpl::has_widthdocpt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosRectImpl::set_has_widthdocpt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosRectImpl::clear_has_widthdocpt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosRectImpl::clear_widthdocpt() {
  widthdocpt_ = 0;
  clear_has_widthdocpt();
}
inline double PosRectImpl::widthdocpt() const {
  return widthdocpt_;
}
inline void PosRectImpl::set_widthdocpt(double value) {
  set_has_widthdocpt();
  widthdocpt_ = value;
}

// required double heightDocPt = 4;
inline bool PosRectImpl::has_heightdocpt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosRectImpl::set_has_heightdocpt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosRectImpl::clear_has_heightdocpt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosRectImpl::clear_heightdocpt() {
  heightdocpt_ = 0;
  clear_has_heightdocpt();
}
inline double PosRectImpl::heightdocpt() const {
  return heightdocpt_;
}
inline void PosRectImpl::set_heightdocpt(double value) {
  set_has_heightdocpt();
  heightdocpt_ = value;
}

// -------------------------------------------------------------------

// PosLineImpl

// required double startXDocPt = 1;
inline bool PosLineImpl::has_startxdocpt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosLineImpl::set_has_startxdocpt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosLineImpl::clear_has_startxdocpt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosLineImpl::clear_startxdocpt() {
  startxdocpt_ = 0;
  clear_has_startxdocpt();
}
inline double PosLineImpl::startxdocpt() const {
  return startxdocpt_;
}
inline void PosLineImpl::set_startxdocpt(double value) {
  set_has_startxdocpt();
  startxdocpt_ = value;
}

// required double startYDocPt = 2;
inline bool PosLineImpl::has_startydocpt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosLineImpl::set_has_startydocpt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosLineImpl::clear_has_startydocpt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosLineImpl::clear_startydocpt() {
  startydocpt_ = 0;
  clear_has_startydocpt();
}
inline double PosLineImpl::startydocpt() const {
  return startydocpt_;
}
inline void PosLineImpl::set_startydocpt(double value) {
  set_has_startydocpt();
  startydocpt_ = value;
}

// required double endXDocPt = 3;
inline bool PosLineImpl::has_endxdocpt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosLineImpl::set_has_endxdocpt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosLineImpl::clear_has_endxdocpt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosLineImpl::clear_endxdocpt() {
  endxdocpt_ = 0;
  clear_has_endxdocpt();
}
inline double PosLineImpl::endxdocpt() const {
  return endxdocpt_;
}
inline void PosLineImpl::set_endxdocpt(double value) {
  set_has_endxdocpt();
  endxdocpt_ = value;
}

// required double endYDocPt = 4;
inline bool PosLineImpl::has_endydocpt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosLineImpl::set_has_endydocpt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosLineImpl::clear_has_endydocpt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosLineImpl::clear_endydocpt() {
  endydocpt_ = 0;
  clear_has_endydocpt();
}
inline double PosLineImpl::endydocpt() const {
  return endydocpt_;
}
inline void PosLineImpl::set_endydocpt(double value) {
  set_has_endydocpt();
  endydocpt_ = value;
}

// -------------------------------------------------------------------

// PosConnectionImpl

// repeated .Proto.SchemePoint points = 1;
inline int PosConnectionImpl::points_size() const {
  return points_.size();
}
inline void PosConnectionImpl::clear_points() {
  points_.Clear();
}
inline const ::Proto::SchemePoint& PosConnectionImpl::points(int index) const {
  return points_.Get(index);
}
inline ::Proto::SchemePoint* PosConnectionImpl::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::Proto::SchemePoint* PosConnectionImpl::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::SchemePoint >&
PosConnectionImpl::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::SchemePoint >*
PosConnectionImpl::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// SchemeItemRect

// required double weight = 1;
inline bool SchemeItemRect::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemeItemRect::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemeItemRect::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemeItemRect::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemeItemRect::weight() const {
  return weight_;
}
inline void SchemeItemRect::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemeItemRect::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeItemRect::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeItemRect::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeItemRect::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemeItemRect::linecolor() const {
  return linecolor_;
}
inline void SchemeItemRect::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// required uint32 fillColor = 3;
inline bool SchemeItemRect::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemeItemRect::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemeItemRect::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemeItemRect::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 SchemeItemRect::fillcolor() const {
  return fillcolor_;
}
inline void SchemeItemRect::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// required .Proto.wstring text = 4;
inline bool SchemeItemRect::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SchemeItemRect::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SchemeItemRect::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SchemeItemRect::clear_text() {
  if (text_ != NULL) text_->::Proto::wstring::Clear();
  clear_has_text();
}
inline const ::Proto::wstring& SchemeItemRect::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::Proto::wstring* SchemeItemRect::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::Proto::wstring;
  return text_;
}
inline ::Proto::wstring* SchemeItemRect::release_text() {
  clear_has_text();
  ::Proto::wstring* temp = text_;
  text_ = NULL;
  return temp;
}
inline void SchemeItemRect::set_allocated_text(::Proto::wstring* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// required uint32 textColor = 5;
inline bool SchemeItemRect::has_textcolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SchemeItemRect::set_has_textcolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SchemeItemRect::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SchemeItemRect::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 SchemeItemRect::textcolor() const {
  return textcolor_;
}
inline void SchemeItemRect::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// required .Proto.FontParam font = 6;
inline bool SchemeItemRect::has_font() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SchemeItemRect::set_has_font() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SchemeItemRect::clear_has_font() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SchemeItemRect::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& SchemeItemRect::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* SchemeItemRect::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* SchemeItemRect::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void SchemeItemRect::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// required bool fill = 7;
inline bool SchemeItemRect::has_fill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SchemeItemRect::set_has_fill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SchemeItemRect::clear_has_fill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SchemeItemRect::clear_fill() {
  fill_ = false;
  clear_has_fill();
}
inline bool SchemeItemRect::fill() const {
  return fill_;
}
inline void SchemeItemRect::set_fill(bool value) {
  set_has_fill();
  fill_ = value;
}

// optional bool drawrect = 8 [default = true];
inline bool SchemeItemRect::has_drawrect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SchemeItemRect::set_has_drawrect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SchemeItemRect::clear_has_drawrect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SchemeItemRect::clear_drawrect() {
  drawrect_ = true;
  clear_has_drawrect();
}
inline bool SchemeItemRect::drawrect() const {
  return drawrect_;
}
inline void SchemeItemRect::set_drawrect(bool value) {
  set_has_drawrect();
  drawrect_ = value;
}

// -------------------------------------------------------------------

// SchemeItemLine

// required double weight = 1;
inline bool SchemeItemLine::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemeItemLine::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemeItemLine::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemeItemLine::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemeItemLine::weight() const {
  return weight_;
}
inline void SchemeItemLine::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemeItemLine::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeItemLine::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeItemLine::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeItemLine::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemeItemLine::linecolor() const {
  return linecolor_;
}
inline void SchemeItemLine::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// SchemeItemPath

// required double weight = 1;
inline bool SchemeItemPath::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemeItemPath::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemeItemPath::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemeItemPath::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double SchemeItemPath::weight() const {
  return weight_;
}
inline void SchemeItemPath::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool SchemeItemPath::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeItemPath::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeItemPath::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeItemPath::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 SchemeItemPath::linecolor() const {
  return linecolor_;
}
inline void SchemeItemPath::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// FblConnectionPoint

// optional .Proto.SchemePoint point = 1;
inline bool FblConnectionPoint::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblConnectionPoint::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblConnectionPoint::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblConnectionPoint::clear_point() {
  if (point_ != NULL) point_->::Proto::SchemePoint::Clear();
  clear_has_point();
}
inline const ::Proto::SchemePoint& FblConnectionPoint::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::Proto::SchemePoint* FblConnectionPoint::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::Proto::SchemePoint;
  return point_;
}
inline ::Proto::SchemePoint* FblConnectionPoint::release_point() {
  clear_has_point();
  ::Proto::SchemePoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void FblConnectionPoint::set_allocated_point(::Proto::SchemePoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// optional .Proto.ConnectionDirrection dirrection = 2;
inline bool FblConnectionPoint::has_dirrection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblConnectionPoint::set_has_dirrection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblConnectionPoint::clear_has_dirrection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblConnectionPoint::clear_dirrection() {
  dirrection_ = 0;
  clear_has_dirrection();
}
inline ::Proto::ConnectionDirrection FblConnectionPoint::dirrection() const {
  return static_cast< ::Proto::ConnectionDirrection >(dirrection_);
}
inline void FblConnectionPoint::set_dirrection(::Proto::ConnectionDirrection value) {
  assert(::Proto::ConnectionDirrection_IsValid(value));
  set_has_dirrection();
  dirrection_ = value;
}

// optional .Proto.Uuid uuid = 3;
inline bool FblConnectionPoint::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblConnectionPoint::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblConnectionPoint::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblConnectionPoint::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& FblConnectionPoint::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* FblConnectionPoint::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* FblConnectionPoint::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void FblConnectionPoint::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// optional int32 operandIndex = 4 [default = -1];
inline bool FblConnectionPoint::has_operandindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblConnectionPoint::set_has_operandindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblConnectionPoint::clear_has_operandindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblConnectionPoint::clear_operandindex() {
  operandindex_ = -1;
  clear_has_operandindex();
}
inline ::google::protobuf::int32 FblConnectionPoint::operandindex() const {
  return operandindex_;
}
inline void FblConnectionPoint::set_operandindex(::google::protobuf::int32 value) {
  set_has_operandindex();
  operandindex_ = value;
}

// optional string caption = 5 [default = ""];
inline bool FblConnectionPoint::has_caption() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblConnectionPoint::set_has_caption() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblConnectionPoint::clear_has_caption() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblConnectionPoint::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& FblConnectionPoint::caption() const {
  return *caption_;
}
inline void FblConnectionPoint::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void FblConnectionPoint::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void FblConnectionPoint::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FblConnectionPoint::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* FblConnectionPoint::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FblConnectionPoint::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FblItem

// repeated .Proto.FblConnectionPoint points = 1;
inline int FblItem::points_size() const {
  return points_.size();
}
inline void FblItem::clear_points() {
  points_.Clear();
}
inline const ::Proto::FblConnectionPoint& FblItem::points(int index) const {
  return points_.Get(index);
}
inline ::Proto::FblConnectionPoint* FblItem::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::Proto::FblConnectionPoint* FblItem::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >&
FblItem::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblConnectionPoint >*
FblItem::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// FblItemRect

// required double weight = 1;
inline bool FblItemRect::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblItemRect::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblItemRect::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblItemRect::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double FblItemRect::weight() const {
  return weight_;
}
inline void FblItemRect::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool FblItemRect::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblItemRect::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblItemRect::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblItemRect::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 FblItemRect::linecolor() const {
  return linecolor_;
}
inline void FblItemRect::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// required uint32 fillColor = 3;
inline bool FblItemRect::has_fillcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FblItemRect::set_has_fillcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FblItemRect::clear_has_fillcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FblItemRect::clear_fillcolor() {
  fillcolor_ = 0u;
  clear_has_fillcolor();
}
inline ::google::protobuf::uint32 FblItemRect::fillcolor() const {
  return fillcolor_;
}
inline void FblItemRect::set_fillcolor(::google::protobuf::uint32 value) {
  set_has_fillcolor();
  fillcolor_ = value;
}

// required uint32 textColor = 4;
inline bool FblItemRect::has_textcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FblItemRect::set_has_textcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FblItemRect::clear_has_textcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FblItemRect::clear_textcolor() {
  textcolor_ = 0u;
  clear_has_textcolor();
}
inline ::google::protobuf::uint32 FblItemRect::textcolor() const {
  return textcolor_;
}
inline void FblItemRect::set_textcolor(::google::protobuf::uint32 value) {
  set_has_textcolor();
  textcolor_ = value;
}

// required .Proto.FontParam font = 5;
inline bool FblItemRect::has_font() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FblItemRect::set_has_font() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FblItemRect::clear_has_font() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FblItemRect::clear_font() {
  if (font_ != NULL) font_->::Proto::FontParam::Clear();
  clear_has_font();
}
inline const ::Proto::FontParam& FblItemRect::font() const {
  return font_ != NULL ? *font_ : *default_instance_->font_;
}
inline ::Proto::FontParam* FblItemRect::mutable_font() {
  set_has_font();
  if (font_ == NULL) font_ = new ::Proto::FontParam;
  return font_;
}
inline ::Proto::FontParam* FblItemRect::release_font() {
  clear_has_font();
  ::Proto::FontParam* temp = font_;
  font_ = NULL;
  return temp;
}
inline void FblItemRect::set_allocated_font(::Proto::FontParam* font) {
  delete font_;
  font_ = font;
  if (font) {
    set_has_font();
  } else {
    clear_has_font();
  }
}

// -------------------------------------------------------------------

// FblItemLine

// required double weight = 1;
inline bool FblItemLine::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FblItemLine::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FblItemLine::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FblItemLine::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double FblItemLine::weight() const {
  return weight_;
}
inline void FblItemLine::set_weight(double value) {
  set_has_weight();
  weight_ = value;
}

// required uint32 lineColor = 2;
inline bool FblItemLine::has_linecolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FblItemLine::set_has_linecolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FblItemLine::clear_has_linecolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FblItemLine::clear_linecolor() {
  linecolor_ = 0u;
  clear_has_linecolor();
}
inline ::google::protobuf::uint32 FblItemLine::linecolor() const {
  return linecolor_;
}
inline void FblItemLine::set_linecolor(::google::protobuf::uint32 value) {
  set_has_linecolor();
  linecolor_ = value;
}

// -------------------------------------------------------------------

// SchemeItemSignal

// repeated .Proto.wstring signalStrIDs = 1;
inline int SchemeItemSignal::signalstrids_size() const {
  return signalstrids_.size();
}
inline void SchemeItemSignal::clear_signalstrids() {
  signalstrids_.Clear();
}
inline const ::Proto::wstring& SchemeItemSignal::signalstrids(int index) const {
  return signalstrids_.Get(index);
}
inline ::Proto::wstring* SchemeItemSignal::mutable_signalstrids(int index) {
  return signalstrids_.Mutable(index);
}
inline ::Proto::wstring* SchemeItemSignal::add_signalstrids() {
  return signalstrids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::wstring >&
SchemeItemSignal::signalstrids() const {
  return signalstrids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::wstring >*
SchemeItemSignal::mutable_signalstrids() {
  return &signalstrids_;
}

// -------------------------------------------------------------------

// SchemeItemInput

// -------------------------------------------------------------------

// SchemeItemOutput

// -------------------------------------------------------------------

// SchemeItemLink

// -------------------------------------------------------------------

// SchemeItemAfb

// repeated .Proto.FblElementParam params = 2;
inline int SchemeItemAfb::params_size() const {
  return params_.size();
}
inline void SchemeItemAfb::clear_params() {
  params_.Clear();
}
inline const ::Proto::FblElementParam& SchemeItemAfb::params(int index) const {
  return params_.Get(index);
}
inline ::Proto::FblElementParam* SchemeItemAfb::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Proto::FblElementParam* SchemeItemAfb::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >&
SchemeItemAfb::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::FblElementParam >*
SchemeItemAfb::mutable_params() {
  return &params_;
}

// optional .Proto.wstring afbStrid = 3;
inline bool SchemeItemAfb::has_afbstrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeItemAfb::set_has_afbstrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeItemAfb::clear_has_afbstrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeItemAfb::clear_afbstrid() {
  if (afbstrid_ != NULL) afbstrid_->::Proto::wstring::Clear();
  clear_has_afbstrid();
}
inline const ::Proto::wstring& SchemeItemAfb::afbstrid() const {
  return afbstrid_ != NULL ? *afbstrid_ : *default_instance_->afbstrid_;
}
inline ::Proto::wstring* SchemeItemAfb::mutable_afbstrid() {
  set_has_afbstrid();
  if (afbstrid_ == NULL) afbstrid_ = new ::Proto::wstring;
  return afbstrid_;
}
inline ::Proto::wstring* SchemeItemAfb::release_afbstrid() {
  clear_has_afbstrid();
  ::Proto::wstring* temp = afbstrid_;
  afbstrid_ = NULL;
  return temp;
}
inline void SchemeItemAfb::set_allocated_afbstrid(::Proto::wstring* afbstrid) {
  delete afbstrid_;
  afbstrid_ = afbstrid;
  if (afbstrid) {
    set_has_afbstrid();
  } else {
    clear_has_afbstrid();
  }
}

// -------------------------------------------------------------------

// SchemeItemConst

// optional int32 type = 1 [default = 0];
inline bool SchemeItemConst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchemeItemConst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchemeItemConst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchemeItemConst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SchemeItemConst::type() const {
  return type_;
}
inline void SchemeItemConst::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 intValue = 2 [default = 0];
inline bool SchemeItemConst::has_intvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchemeItemConst::set_has_intvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchemeItemConst::clear_has_intvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchemeItemConst::clear_intvalue() {
  intvalue_ = 0;
  clear_has_intvalue();
}
inline ::google::protobuf::int32 SchemeItemConst::intvalue() const {
  return intvalue_;
}
inline void SchemeItemConst::set_intvalue(::google::protobuf::int32 value) {
  set_has_intvalue();
  intvalue_ = value;
}

// optional double floatValue = 3 [default = 0];
inline bool SchemeItemConst::has_floatvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchemeItemConst::set_has_floatvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchemeItemConst::clear_has_floatvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchemeItemConst::clear_floatvalue() {
  floatvalue_ = 0;
  clear_has_floatvalue();
}
inline double SchemeItemConst::floatvalue() const {
  return floatvalue_;
}
inline void SchemeItemConst::set_floatvalue(double value) {
  set_has_floatvalue();
  floatvalue_ = value;
}

// -------------------------------------------------------------------

// DeviceObject

// required .Proto.Uuid uuid = 1;
inline bool DeviceObject::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceObject::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceObject::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceObject::clear_uuid() {
  if (uuid_ != NULL) uuid_->::Proto::Uuid::Clear();
  clear_has_uuid();
}
inline const ::Proto::Uuid& DeviceObject::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::Proto::Uuid* DeviceObject::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::Proto::Uuid;
  return uuid_;
}
inline ::Proto::Uuid* DeviceObject::release_uuid() {
  clear_has_uuid();
  ::Proto::Uuid* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_uuid(::Proto::Uuid* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// required .Proto.wstring strId = 2;
inline bool DeviceObject::has_strid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceObject::set_has_strid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceObject::clear_has_strid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceObject::clear_strid() {
  if (strid_ != NULL) strid_->::Proto::wstring::Clear();
  clear_has_strid();
}
inline const ::Proto::wstring& DeviceObject::strid() const {
  return strid_ != NULL ? *strid_ : *default_instance_->strid_;
}
inline ::Proto::wstring* DeviceObject::mutable_strid() {
  set_has_strid();
  if (strid_ == NULL) strid_ = new ::Proto::wstring;
  return strid_;
}
inline ::Proto::wstring* DeviceObject::release_strid() {
  clear_has_strid();
  ::Proto::wstring* temp = strid_;
  strid_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_strid(::Proto::wstring* strid) {
  delete strid_;
  strid_ = strid;
  if (strid) {
    set_has_strid();
  } else {
    clear_has_strid();
  }
}

// required .Proto.wstring caption = 3;
inline bool DeviceObject::has_caption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceObject::set_has_caption() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceObject::clear_has_caption() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceObject::clear_caption() {
  if (caption_ != NULL) caption_->::Proto::wstring::Clear();
  clear_has_caption();
}
inline const ::Proto::wstring& DeviceObject::caption() const {
  return caption_ != NULL ? *caption_ : *default_instance_->caption_;
}
inline ::Proto::wstring* DeviceObject::mutable_caption() {
  set_has_caption();
  if (caption_ == NULL) caption_ = new ::Proto::wstring;
  return caption_;
}
inline ::Proto::wstring* DeviceObject::release_caption() {
  clear_has_caption();
  ::Proto::wstring* temp = caption_;
  caption_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_caption(::Proto::wstring* caption) {
  delete caption_;
  caption_ = caption;
  if (caption) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
}

// optional .Proto.wstring childRestriction = 4;
inline bool DeviceObject::has_childrestriction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceObject::set_has_childrestriction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceObject::clear_has_childrestriction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceObject::clear_childrestriction() {
  if (childrestriction_ != NULL) childrestriction_->::Proto::wstring::Clear();
  clear_has_childrestriction();
}
inline const ::Proto::wstring& DeviceObject::childrestriction() const {
  return childrestriction_ != NULL ? *childrestriction_ : *default_instance_->childrestriction_;
}
inline ::Proto::wstring* DeviceObject::mutable_childrestriction() {
  set_has_childrestriction();
  if (childrestriction_ == NULL) childrestriction_ = new ::Proto::wstring;
  return childrestriction_;
}
inline ::Proto::wstring* DeviceObject::release_childrestriction() {
  clear_has_childrestriction();
  ::Proto::wstring* temp = childrestriction_;
  childrestriction_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_childrestriction(::Proto::wstring* childrestriction) {
  delete childrestriction_;
  childrestriction_ = childrestriction;
  if (childrestriction) {
    set_has_childrestriction();
  } else {
    clear_has_childrestriction();
  }
}

// optional int32 place = 5 [default = 0];
inline bool DeviceObject::has_place() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceObject::set_has_place() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceObject::clear_has_place() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceObject::clear_place() {
  place_ = 0;
  clear_has_place();
}
inline ::google::protobuf::int32 DeviceObject::place() const {
  return place_;
}
inline void DeviceObject::set_place(::google::protobuf::int32 value) {
  set_has_place();
  place_ = value;
}

// optional string dynamic_properties_struct = 6;
inline bool DeviceObject::has_dynamic_properties_struct() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceObject::set_has_dynamic_properties_struct() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceObject::clear_has_dynamic_properties_struct() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceObject::clear_dynamic_properties_struct() {
  if (dynamic_properties_struct_ != &::google::protobuf::internal::kEmptyString) {
    dynamic_properties_struct_->clear();
  }
  clear_has_dynamic_properties_struct();
}
inline const ::std::string& DeviceObject::dynamic_properties_struct() const {
  return *dynamic_properties_struct_;
}
inline void DeviceObject::set_dynamic_properties_struct(const ::std::string& value) {
  set_has_dynamic_properties_struct();
  if (dynamic_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_properties_struct_ = new ::std::string;
  }
  dynamic_properties_struct_->assign(value);
}
inline void DeviceObject::set_dynamic_properties_struct(const char* value) {
  set_has_dynamic_properties_struct();
  if (dynamic_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_properties_struct_ = new ::std::string;
  }
  dynamic_properties_struct_->assign(value);
}
inline void DeviceObject::set_dynamic_properties_struct(const char* value, size_t size) {
  set_has_dynamic_properties_struct();
  if (dynamic_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_properties_struct_ = new ::std::string;
  }
  dynamic_properties_struct_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceObject::mutable_dynamic_properties_struct() {
  set_has_dynamic_properties_struct();
  if (dynamic_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_properties_struct_ = new ::std::string;
  }
  return dynamic_properties_struct_;
}
inline ::std::string* DeviceObject::release_dynamic_properties_struct() {
  clear_has_dynamic_properties_struct();
  if (dynamic_properties_struct_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dynamic_properties_struct_;
    dynamic_properties_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceObject::set_allocated_dynamic_properties_struct(::std::string* dynamic_properties_struct) {
  if (dynamic_properties_struct_ != &::google::protobuf::internal::kEmptyString) {
    delete dynamic_properties_struct_;
  }
  if (dynamic_properties_struct) {
    set_has_dynamic_properties_struct();
    dynamic_properties_struct_ = dynamic_properties_struct;
  } else {
    clear_has_dynamic_properties_struct();
    dynamic_properties_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.Property properties = 7;
inline int DeviceObject::properties_size() const {
  return properties_.size();
}
inline void DeviceObject::clear_properties() {
  properties_.Clear();
}
inline const ::Proto::Property& DeviceObject::properties(int index) const {
  return properties_.Get(index);
}
inline ::Proto::Property* DeviceObject::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Proto::Property* DeviceObject::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Property >&
DeviceObject::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Property >*
DeviceObject::mutable_properties() {
  return &properties_;
}

// optional bool preset = 32 [default = false];
inline bool DeviceObject::has_preset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceObject::set_has_preset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceObject::clear_has_preset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceObject::clear_preset() {
  preset_ = false;
  clear_has_preset();
}
inline bool DeviceObject::preset() const {
  return preset_;
}
inline void DeviceObject::set_preset(bool value) {
  set_has_preset();
  preset_ = value;
}

// optional bool presetRoot = 33 [default = false];
inline bool DeviceObject::has_presetroot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceObject::set_has_presetroot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceObject::clear_has_presetroot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceObject::clear_presetroot() {
  presetroot_ = false;
  clear_has_presetroot();
}
inline bool DeviceObject::presetroot() const {
  return presetroot_;
}
inline void DeviceObject::set_presetroot(bool value) {
  set_has_presetroot();
  presetroot_ = value;
}

// optional .Proto.wstring presetName = 34;
inline bool DeviceObject::has_presetname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceObject::set_has_presetname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceObject::clear_has_presetname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceObject::clear_presetname() {
  if (presetname_ != NULL) presetname_->::Proto::wstring::Clear();
  clear_has_presetname();
}
inline const ::Proto::wstring& DeviceObject::presetname() const {
  return presetname_ != NULL ? *presetname_ : *default_instance_->presetname_;
}
inline ::Proto::wstring* DeviceObject::mutable_presetname() {
  set_has_presetname();
  if (presetname_ == NULL) presetname_ = new ::Proto::wstring;
  return presetname_;
}
inline ::Proto::wstring* DeviceObject::release_presetname() {
  clear_has_presetname();
  ::Proto::wstring* temp = presetname_;
  presetname_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_presetname(::Proto::wstring* presetname) {
  delete presetname_;
  presetname_ = presetname;
  if (presetname) {
    set_has_presetname();
  } else {
    clear_has_presetname();
  }
}

// optional .Proto.DeviceRoot Root = 100;
inline bool DeviceObject::has_root() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceObject::set_has_root() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeviceObject::clear_has_root() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceObject::clear_root() {
  if (root_ != NULL) root_->::Proto::DeviceRoot::Clear();
  clear_has_root();
}
inline const ::Proto::DeviceRoot& DeviceObject::root() const {
  return root_ != NULL ? *root_ : *default_instance_->root_;
}
inline ::Proto::DeviceRoot* DeviceObject::mutable_root() {
  set_has_root();
  if (root_ == NULL) root_ = new ::Proto::DeviceRoot;
  return root_;
}
inline ::Proto::DeviceRoot* DeviceObject::release_root() {
  clear_has_root();
  ::Proto::DeviceRoot* temp = root_;
  root_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_root(::Proto::DeviceRoot* root) {
  delete root_;
  root_ = root;
  if (root) {
    set_has_root();
  } else {
    clear_has_root();
  }
}

// optional .Proto.DeviceSystem System = 101;
inline bool DeviceObject::has_system() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceObject::set_has_system() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeviceObject::clear_has_system() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceObject::clear_system() {
  if (system_ != NULL) system_->::Proto::DeviceSystem::Clear();
  clear_has_system();
}
inline const ::Proto::DeviceSystem& DeviceObject::system() const {
  return system_ != NULL ? *system_ : *default_instance_->system_;
}
inline ::Proto::DeviceSystem* DeviceObject::mutable_system() {
  set_has_system();
  if (system_ == NULL) system_ = new ::Proto::DeviceSystem;
  return system_;
}
inline ::Proto::DeviceSystem* DeviceObject::release_system() {
  clear_has_system();
  ::Proto::DeviceSystem* temp = system_;
  system_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_system(::Proto::DeviceSystem* system) {
  delete system_;
  system_ = system;
  if (system) {
    set_has_system();
  } else {
    clear_has_system();
  }
}

// optional .Proto.DeviceRack Rack = 102;
inline bool DeviceObject::has_rack() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceObject::set_has_rack() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DeviceObject::clear_has_rack() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceObject::clear_rack() {
  if (rack_ != NULL) rack_->::Proto::DeviceRack::Clear();
  clear_has_rack();
}
inline const ::Proto::DeviceRack& DeviceObject::rack() const {
  return rack_ != NULL ? *rack_ : *default_instance_->rack_;
}
inline ::Proto::DeviceRack* DeviceObject::mutable_rack() {
  set_has_rack();
  if (rack_ == NULL) rack_ = new ::Proto::DeviceRack;
  return rack_;
}
inline ::Proto::DeviceRack* DeviceObject::release_rack() {
  clear_has_rack();
  ::Proto::DeviceRack* temp = rack_;
  rack_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_rack(::Proto::DeviceRack* rack) {
  delete rack_;
  rack_ = rack;
  if (rack) {
    set_has_rack();
  } else {
    clear_has_rack();
  }
}

// optional .Proto.DeviceChassis Chassis = 103;
inline bool DeviceObject::has_chassis() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceObject::set_has_chassis() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DeviceObject::clear_has_chassis() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceObject::clear_chassis() {
  if (chassis_ != NULL) chassis_->::Proto::DeviceChassis::Clear();
  clear_has_chassis();
}
inline const ::Proto::DeviceChassis& DeviceObject::chassis() const {
  return chassis_ != NULL ? *chassis_ : *default_instance_->chassis_;
}
inline ::Proto::DeviceChassis* DeviceObject::mutable_chassis() {
  set_has_chassis();
  if (chassis_ == NULL) chassis_ = new ::Proto::DeviceChassis;
  return chassis_;
}
inline ::Proto::DeviceChassis* DeviceObject::release_chassis() {
  clear_has_chassis();
  ::Proto::DeviceChassis* temp = chassis_;
  chassis_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_chassis(::Proto::DeviceChassis* chassis) {
  delete chassis_;
  chassis_ = chassis;
  if (chassis) {
    set_has_chassis();
  } else {
    clear_has_chassis();
  }
}

// optional .Proto.DeviceModule Module = 104;
inline bool DeviceObject::has_module() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceObject::set_has_module() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DeviceObject::clear_has_module() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceObject::clear_module() {
  if (module_ != NULL) module_->::Proto::DeviceModule::Clear();
  clear_has_module();
}
inline const ::Proto::DeviceModule& DeviceObject::module() const {
  return module_ != NULL ? *module_ : *default_instance_->module_;
}
inline ::Proto::DeviceModule* DeviceObject::mutable_module() {
  set_has_module();
  if (module_ == NULL) module_ = new ::Proto::DeviceModule;
  return module_;
}
inline ::Proto::DeviceModule* DeviceObject::release_module() {
  clear_has_module();
  ::Proto::DeviceModule* temp = module_;
  module_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_module(::Proto::DeviceModule* module) {
  delete module_;
  module_ = module;
  if (module) {
    set_has_module();
  } else {
    clear_has_module();
  }
}

// optional .Proto.DeviceController Controller = 105;
inline bool DeviceObject::has_controller() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceObject::set_has_controller() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DeviceObject::clear_has_controller() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceObject::clear_controller() {
  if (controller_ != NULL) controller_->::Proto::DeviceController::Clear();
  clear_has_controller();
}
inline const ::Proto::DeviceController& DeviceObject::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::Proto::DeviceController* DeviceObject::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::Proto::DeviceController;
  return controller_;
}
inline ::Proto::DeviceController* DeviceObject::release_controller() {
  clear_has_controller();
  ::Proto::DeviceController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_controller(::Proto::DeviceController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// optional .Proto.DeviceSignal Signal = 106;
inline bool DeviceObject::has_signal() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceObject::set_has_signal() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DeviceObject::clear_has_signal() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceObject::clear_signal() {
  if (signal_ != NULL) signal_->::Proto::DeviceSignal::Clear();
  clear_has_signal();
}
inline const ::Proto::DeviceSignal& DeviceObject::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Proto::DeviceSignal* DeviceObject::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Proto::DeviceSignal;
  return signal_;
}
inline ::Proto::DeviceSignal* DeviceObject::release_signal() {
  clear_has_signal();
  ::Proto::DeviceSignal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_signal(::Proto::DeviceSignal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Proto.Workstation Workstation = 107;
inline bool DeviceObject::has_workstation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceObject::set_has_workstation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DeviceObject::clear_has_workstation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceObject::clear_workstation() {
  if (workstation_ != NULL) workstation_->::Proto::Workstation::Clear();
  clear_has_workstation();
}
inline const ::Proto::Workstation& DeviceObject::workstation() const {
  return workstation_ != NULL ? *workstation_ : *default_instance_->workstation_;
}
inline ::Proto::Workstation* DeviceObject::mutable_workstation() {
  set_has_workstation();
  if (workstation_ == NULL) workstation_ = new ::Proto::Workstation;
  return workstation_;
}
inline ::Proto::Workstation* DeviceObject::release_workstation() {
  clear_has_workstation();
  ::Proto::Workstation* temp = workstation_;
  workstation_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_workstation(::Proto::Workstation* workstation) {
  delete workstation_;
  workstation_ = workstation;
  if (workstation) {
    set_has_workstation();
  } else {
    clear_has_workstation();
  }
}

// optional .Proto.Software Software = 108;
inline bool DeviceObject::has_software() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceObject::set_has_software() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DeviceObject::clear_has_software() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DeviceObject::clear_software() {
  if (software_ != NULL) software_->::Proto::Software::Clear();
  clear_has_software();
}
inline const ::Proto::Software& DeviceObject::software() const {
  return software_ != NULL ? *software_ : *default_instance_->software_;
}
inline ::Proto::Software* DeviceObject::mutable_software() {
  set_has_software();
  if (software_ == NULL) software_ = new ::Proto::Software;
  return software_;
}
inline ::Proto::Software* DeviceObject::release_software() {
  clear_has_software();
  ::Proto::Software* temp = software_;
  software_ = NULL;
  return temp;
}
inline void DeviceObject::set_allocated_software(::Proto::Software* software) {
  delete software_;
  software_ = software;
  if (software) {
    set_has_software();
  } else {
    clear_has_software();
  }
}

// -------------------------------------------------------------------

// DeviceRoot

// -------------------------------------------------------------------

// DeviceSystem

// -------------------------------------------------------------------

// DeviceRack

// -------------------------------------------------------------------

// DeviceChassis

// optional int32 type = 1 [default = 0];
inline bool DeviceChassis::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceChassis::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceChassis::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceChassis::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceChassis::type() const {
  return type_;
}
inline void DeviceChassis::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// DeviceModule

// optional int32 type = 1 [default = 0];
inline bool DeviceModule::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceModule::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceModule::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceModule::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceModule::type() const {
  return type_;
}
inline void DeviceModule::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 Channel = 2 [default = 0];
inline bool DeviceModule::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceModule::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceModule::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceModule::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 DeviceModule::channel() const {
  return channel_;
}
inline void DeviceModule::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string SubsysID = 3 [default = ""];
inline bool DeviceModule::has_subsysid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceModule::set_has_subsysid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceModule::clear_has_subsysid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceModule::clear_subsysid() {
  if (subsysid_ != &::google::protobuf::internal::kEmptyString) {
    subsysid_->clear();
  }
  clear_has_subsysid();
}
inline const ::std::string& DeviceModule::subsysid() const {
  return *subsysid_;
}
inline void DeviceModule::set_subsysid(const ::std::string& value) {
  set_has_subsysid();
  if (subsysid_ == &::google::protobuf::internal::kEmptyString) {
    subsysid_ = new ::std::string;
  }
  subsysid_->assign(value);
}
inline void DeviceModule::set_subsysid(const char* value) {
  set_has_subsysid();
  if (subsysid_ == &::google::protobuf::internal::kEmptyString) {
    subsysid_ = new ::std::string;
  }
  subsysid_->assign(value);
}
inline void DeviceModule::set_subsysid(const char* value, size_t size) {
  set_has_subsysid();
  if (subsysid_ == &::google::protobuf::internal::kEmptyString) {
    subsysid_ = new ::std::string;
  }
  subsysid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceModule::mutable_subsysid() {
  set_has_subsysid();
  if (subsysid_ == &::google::protobuf::internal::kEmptyString) {
    subsysid_ = new ::std::string;
  }
  return subsysid_;
}
inline ::std::string* DeviceModule::release_subsysid() {
  clear_has_subsysid();
  if (subsysid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subsysid_;
    subsysid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceModule::set_allocated_subsysid(::std::string* subsysid) {
  if (subsysid_ != &::google::protobuf::internal::kEmptyString) {
    delete subsysid_;
  }
  if (subsysid) {
    set_has_subsysid();
    subsysid_ = subsysid;
  } else {
    clear_has_subsysid();
    subsysid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ConfType = 4 [default = ""];
inline bool DeviceModule::has_conftype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceModule::set_has_conftype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceModule::clear_has_conftype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceModule::clear_conftype() {
  if (conftype_ != &::google::protobuf::internal::kEmptyString) {
    conftype_->clear();
  }
  clear_has_conftype();
}
inline const ::std::string& DeviceModule::conftype() const {
  return *conftype_;
}
inline void DeviceModule::set_conftype(const ::std::string& value) {
  set_has_conftype();
  if (conftype_ == &::google::protobuf::internal::kEmptyString) {
    conftype_ = new ::std::string;
  }
  conftype_->assign(value);
}
inline void DeviceModule::set_conftype(const char* value) {
  set_has_conftype();
  if (conftype_ == &::google::protobuf::internal::kEmptyString) {
    conftype_ = new ::std::string;
  }
  conftype_->assign(value);
}
inline void DeviceModule::set_conftype(const char* value, size_t size) {
  set_has_conftype();
  if (conftype_ == &::google::protobuf::internal::kEmptyString) {
    conftype_ = new ::std::string;
  }
  conftype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceModule::mutable_conftype() {
  set_has_conftype();
  if (conftype_ == &::google::protobuf::internal::kEmptyString) {
    conftype_ = new ::std::string;
  }
  return conftype_;
}
inline ::std::string* DeviceModule::release_conftype() {
  clear_has_conftype();
  if (conftype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conftype_;
    conftype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceModule::set_allocated_conftype(::std::string* conftype) {
  if (conftype_ != &::google::protobuf::internal::kEmptyString) {
    delete conftype_;
  }
  if (conftype) {
    set_has_conftype();
    conftype_ = conftype;
  } else {
    clear_has_conftype();
    conftype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeviceController

// -------------------------------------------------------------------

// DeviceSignal

// optional int32 obsoletetype = 1 [default = 0];
inline bool DeviceSignal::has_obsoletetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceSignal::set_has_obsoletetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceSignal::clear_has_obsoletetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceSignal::clear_obsoletetype() {
  obsoletetype_ = 0;
  clear_has_obsoletetype();
}
inline ::google::protobuf::int32 DeviceSignal::obsoletetype() const {
  return obsoletetype_;
}
inline void DeviceSignal::set_obsoletetype(::google::protobuf::int32 value) {
  set_has_obsoletetype();
  obsoletetype_ = value;
}

// optional int32 byteOrder = 2 [default = 0];
inline bool DeviceSignal::has_byteorder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceSignal::set_has_byteorder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceSignal::clear_has_byteorder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceSignal::clear_byteorder() {
  byteorder_ = 0;
  clear_has_byteorder();
}
inline ::google::protobuf::int32 DeviceSignal::byteorder() const {
  return byteorder_;
}
inline void DeviceSignal::set_byteorder(::google::protobuf::int32 value) {
  set_has_byteorder();
  byteorder_ = value;
}

// optional int32 format = 3 [default = 0];
inline bool DeviceSignal::has_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceSignal::set_has_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceSignal::clear_has_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceSignal::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 DeviceSignal::format() const {
  return format_;
}
inline void DeviceSignal::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
}

// optional int32 size = 4 [default = 0];
inline bool DeviceSignal::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceSignal::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceSignal::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceSignal::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 DeviceSignal::size() const {
  return size_;
}
inline void DeviceSignal::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int32 validityOffset = 5 [default = 0];
inline bool DeviceSignal::has_validityoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceSignal::set_has_validityoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceSignal::clear_has_validityoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceSignal::clear_validityoffset() {
  validityoffset_ = 0;
  clear_has_validityoffset();
}
inline ::google::protobuf::int32 DeviceSignal::validityoffset() const {
  return validityoffset_;
}
inline void DeviceSignal::set_validityoffset(::google::protobuf::int32 value) {
  set_has_validityoffset();
  validityoffset_ = value;
}

// optional int32 validityBit = 6 [default = 0];
inline bool DeviceSignal::has_validitybit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceSignal::set_has_validitybit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceSignal::clear_has_validitybit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceSignal::clear_validitybit() {
  validitybit_ = 0;
  clear_has_validitybit();
}
inline ::google::protobuf::int32 DeviceSignal::validitybit() const {
  return validitybit_;
}
inline void DeviceSignal::set_validitybit(::google::protobuf::int32 value) {
  set_has_validitybit();
  validitybit_ = value;
}

// optional int32 valueOffset = 7 [default = 0];
inline bool DeviceSignal::has_valueoffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceSignal::set_has_valueoffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceSignal::clear_has_valueoffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceSignal::clear_valueoffset() {
  valueoffset_ = 0;
  clear_has_valueoffset();
}
inline ::google::protobuf::int32 DeviceSignal::valueoffset() const {
  return valueoffset_;
}
inline void DeviceSignal::set_valueoffset(::google::protobuf::int32 value) {
  set_has_valueoffset();
  valueoffset_ = value;
}

// optional int32 valueBit = 8 [default = 0];
inline bool DeviceSignal::has_valuebit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceSignal::set_has_valuebit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceSignal::clear_has_valuebit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceSignal::clear_valuebit() {
  valuebit_ = 0;
  clear_has_valuebit();
}
inline ::google::protobuf::int32 DeviceSignal::valuebit() const {
  return valuebit_;
}
inline void DeviceSignal::set_valuebit(::google::protobuf::int32 value) {
  set_has_valuebit();
  valuebit_ = value;
}

// optional int32 type = 9 [default = 0];
inline bool DeviceSignal::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceSignal::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceSignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceSignal::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceSignal::type() const {
  return type_;
}
inline void DeviceSignal::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 function = 10 [default = 0];
inline bool DeviceSignal::has_function() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceSignal::set_has_function() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceSignal::clear_has_function() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceSignal::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::google::protobuf::int32 DeviceSignal::function() const {
  return function_;
}
inline void DeviceSignal::set_function(::google::protobuf::int32 value) {
  set_has_function();
  function_ = value;
}

// -------------------------------------------------------------------

// Workstation

// optional int32 type = 1 [default = 0];
inline bool Workstation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Workstation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Workstation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Workstation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Workstation::type() const {
  return type_;
}
inline void Workstation::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// Software

// optional int32 type = 1 [default = 0];
inline bool Software::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Software::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Software::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Software::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Software::type() const {
  return type_;
}
inline void Software::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ModuleConfiguration

// optional string struct_description = 1;
inline bool ModuleConfiguration::has_struct_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleConfiguration::set_has_struct_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleConfiguration::clear_has_struct_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleConfiguration::clear_struct_description() {
  if (struct_description_ != &::google::protobuf::internal::kEmptyString) {
    struct_description_->clear();
  }
  clear_has_struct_description();
}
inline const ::std::string& ModuleConfiguration::struct_description() const {
  return *struct_description_;
}
inline void ModuleConfiguration::set_struct_description(const ::std::string& value) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(value);
}
inline void ModuleConfiguration::set_struct_description(const char* value) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(value);
}
inline void ModuleConfiguration::set_struct_description(const char* value, size_t size) {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  struct_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfiguration::mutable_struct_description() {
  set_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    struct_description_ = new ::std::string;
  }
  return struct_description_;
}
inline ::std::string* ModuleConfiguration::release_struct_description() {
  clear_has_struct_description();
  if (struct_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = struct_description_;
    struct_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfiguration::set_allocated_struct_description(::std::string* struct_description) {
  if (struct_description_ != &::google::protobuf::internal::kEmptyString) {
    delete struct_description_;
  }
  if (struct_description) {
    set_has_struct_description();
    struct_description_ = struct_description;
  } else {
    clear_has_struct_description();
    struct_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Proto.ModuleConfigurationValue values = 2;
inline int ModuleConfiguration::values_size() const {
  return values_.size();
}
inline void ModuleConfiguration::clear_values() {
  values_.Clear();
}
inline const ::Proto::ModuleConfigurationValue& ModuleConfiguration::values(int index) const {
  return values_.Get(index);
}
inline ::Proto::ModuleConfigurationValue* ModuleConfiguration::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::Proto::ModuleConfigurationValue* ModuleConfiguration::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >&
ModuleConfiguration::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::ModuleConfigurationValue >*
ModuleConfiguration::mutable_values() {
  return &values_;
}

// optional string name = 3 [default = ""];
inline bool ModuleConfiguration::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModuleConfiguration::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModuleConfiguration::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModuleConfiguration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleConfiguration::name() const {
  return *name_;
}
inline void ModuleConfiguration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfiguration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfiguration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfiguration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleConfiguration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfiguration::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModuleConfigurationValue

// required string name = 1;
inline bool ModuleConfigurationValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleConfigurationValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleConfigurationValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleConfigurationValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModuleConfigurationValue::name() const {
  return *name_;
}
inline void ModuleConfigurationValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfigurationValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModuleConfigurationValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfigurationValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModuleConfigurationValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfigurationValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool ModuleConfigurationValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleConfigurationValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleConfigurationValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleConfigurationValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ModuleConfigurationValue::value() const {
  return *value_;
}
inline void ModuleConfigurationValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ModuleConfigurationValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ModuleConfigurationValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleConfigurationValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ModuleConfigurationValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleConfigurationValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Property

// required string name = 1;
inline bool Property::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Property::name() const {
  return *name_;
}
inline void Property::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Property::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Property::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Property::value() const {
  return *value_;
}
inline void Property::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Property::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Property::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Property::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::SchemeUnit>() {
  return ::Proto::SchemeUnit_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::ConnectionDirrection>() {
  return ::Proto::ConnectionDirrection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::FblSignalType>() {
  return ::Proto::FblSignalType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::FblParamType>() {
  return ::Proto::FblParamType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_serialization_2eproto__INCLUDED
